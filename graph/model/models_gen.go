// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

// Represents a cart line common fields.
type BaseCartLine interface {
	IsBaseCartLine()
	// An attribute associated with the cart line.
	GetAttribute() *Attribute
	// The attributes associated with the cart line. Attributes are represented as key-value pairs.
	GetAttributes() []*Attribute
	// The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout.
	GetCost() *CartLineCost
	// The discounts that have been applied to the cart line.
	GetDiscountAllocations() []CartDiscountAllocation
	// The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
	GetEstimatedCost() *CartLineEstimatedCost
	// A globally-unique ID.
	GetID() string
	// The merchandise that the buyer intends to purchase.
	GetMerchandise() Merchandise
	// The quantity of the merchandise that the customer intends to purchase.
	GetQuantity() int32
	// The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased.
	GetSellingPlanAllocation() *SellingPlanAllocation
}

// A delivery address of the buyer that is interacting with the cart.
type CartAddress interface {
	IsCartAddress()
}

// The completion action to checkout a cart.
type CartCompletionAction interface {
	IsCartCompletionAction()
}

// The result of a cart completion attempt.
type CartCompletionAttemptResult interface {
	IsCartCompletionAttemptResult()
}

// The discounts that have been applied to the cart line.
type CartDiscountAllocation interface {
	IsCartDiscountAllocation()
	// The discount that have been applied on the cart line.
	GetDiscountApplication() *CartDiscountApplication
	// The discounted amount that has been applied to the cart line.
	GetDiscountedAmount() *MoneyV2
	// The type of line that the discount is applicable towards.
	GetTargetType() DiscountApplicationTargetType
}

// The result of cart preparation.
type CartPrepareForCompletionResult interface {
	IsCartPrepareForCompletionResult()
}

// The result of cart submit completion.
type CartSubmitForCompletionResult interface {
	IsCartSubmitForCompletionResult()
}

// A delivery address of the buyer that is interacting with the cart.
type DeliveryAddress interface {
	IsDeliveryAddress()
}

// Discount applications capture the intentions of a discount source at
// the time of application.
type DiscountApplication interface {
	IsDiscountApplication()
	// The method by which the discount's value is allocated to its entitled items.
	GetAllocationMethod() DiscountApplicationAllocationMethod
	// Which lines of targetType that the discount is allocated over.
	GetTargetSelection() DiscountApplicationTargetSelection
	// The type of line that the discount is applicable towards.
	GetTargetType() DiscountApplicationTargetType
	// The value of the discount application.
	GetValue() PricingValue
}

// Represents an error in the input of a mutation.
type DisplayableError interface {
	IsDisplayableError()
	// The path to the input field that caused the error.
	GetField() []string
	// The error message.
	GetMessage() string
}

// Represents information about the metafields associated to the specified resource.
type HasMetafields interface {
	IsHasMetafields()
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	GetMetafield() *Metafield
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	GetMetafields() []*Metafield
}

// Represents a media interface.
type Media interface {
	IsMedia()
	// A word or phrase to share the nature or contents of a media.
	GetAlt() *string
	// A globally-unique ID.
	GetID() string
	// The media content type.
	GetMediaContentType() MediaContentType
	// The presentation for a media.
	GetPresentation() *MediaPresentation
	// The preview image for the media.
	GetPreviewImage() *Image
}

// The list of possible resources a `MenuItem` can reference.
type MenuItemResource interface {
	IsMenuItemResource()
}

// The merchandise to be purchased at checkout.
type Merchandise interface {
	IsMerchandise()
}

// A resource that the metafield belongs to.
type MetafieldParentResource interface {
	IsMetafieldParentResource()
}

// Returns the resource which is being referred to by a metafield.
type MetafieldReference interface {
	IsMetafieldReference()
}

// An object with an ID field to support global identification, in accordance with the
// [Relay specification](https://relay.dev/graphql/objectidentification.htm#sec-Node-Interface).
// This interface is used by the [node](/docs/api/storefront/latest/queries/node)
// and [nodes](/docs/api/storefront/latest/queries/nodes) queries.
type Node interface {
	IsNode()
	// A globally-unique ID.
	GetID() string
}

// Represents a resource that can be published to the Online Store sales channel.
type OnlineStorePublishable interface {
	IsOnlineStorePublishable()
	// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
	GetOnlineStoreURL() *string
}

// The price value (fixed or percentage) for a discount application.
type PricingValue interface {
	IsPricingValue()
}

// A search result that matches the search query.
type SearchResultItem interface {
	IsSearchResultItem()
}

// The selling plan billing policy.
type SellingPlanBillingPolicy interface {
	IsSellingPlanBillingPolicy()
}

// The portion of the price to be charged at checkout.
type SellingPlanCheckoutChargeValue interface {
	IsSellingPlanCheckoutChargeValue()
}

// The selling plan delivery policy.
type SellingPlanDeliveryPolicy interface {
	IsSellingPlanDeliveryPolicy()
}

// Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments.
type SellingPlanPriceAdjustmentValue interface {
	IsSellingPlanPriceAdjustmentValue()
}

// Represents the common fields for all sitemap resource types.
type SitemapResourceInterface interface {
	IsSitemapResourceInterface()
	// Resource's handle.
	GetHandle() string
	// The date and time when the resource was updated.
	GetUpdatedAt() string
}

// Represents a resource that you can track the origin of the search traffic.
type Trackable interface {
	IsTrackable()
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	GetTrackingParameters() *string
}

// A version of the API, as defined by [Shopify API versioning](https://shopify.dev/api/usage/versioning).
// Versions are commonly referred to by their handle (for example, `2021-10`).
type APIVersion struct {
	// The human-readable name of the version.
	DisplayName string `json:"displayName"`
	// The unique identifier of an ApiVersion. All supported API versions have a date-based (YYYY-MM) or `unstable` handle.
	Handle string `json:"handle"`
	// Whether the version is actively supported by Shopify. Supported API versions are guaranteed to be stable. Unsupported API versions include unstable, release candidate, and end-of-life versions that are marked as unsupported. For more information, refer to [Versioning](https://shopify.dev/api/usage/versioning).
	Supported bool `json:"supported"`
}

// The input fields for submitting Apple Pay payment method information for checkout.
type ApplePayWalletContentInput struct {
	// The customer's billing address.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// The data for the Apple Pay wallet.
	Data string `json:"data"`
	// The header data for the Apple Pay wallet.
	Header *ApplePayWalletHeaderInput `json:"header"`
	// The last digits of the card used to create the payment.
	LastDigits *string `json:"lastDigits,omitempty"`
	// The signature for the Apple Pay wallet.
	Signature string `json:"signature"`
	// The version for the Apple Pay wallet.
	Version string `json:"version"`
}

// The input fields for submitting wallet payment method information for checkout.
type ApplePayWalletHeaderInput struct {
	// The application data for the Apple Pay wallet.
	ApplicationData *string `json:"applicationData,omitempty"`
	// The ephemeral public key for the Apple Pay wallet.
	EphemeralPublicKey string `json:"ephemeralPublicKey"`
	// The public key hash for the Apple Pay wallet.
	PublicKeyHash string `json:"publicKeyHash"`
	// The transaction ID for the Apple Pay wallet.
	TransactionID string `json:"transactionId"`
}

// Details about the gift card used on the checkout.
type AppliedGiftCard struct {
	// The amount that was taken from the gift card by applying it.
	AmountUsed *MoneyV2 `json:"amountUsed"`
	// The amount that was taken from the gift card by applying it.
	AmountUsedV2 *MoneyV2 `json:"amountUsedV2"`
	// The amount left on the gift card.
	Balance *MoneyV2 `json:"balance"`
	// The amount left on the gift card.
	BalanceV2 *MoneyV2 `json:"balanceV2"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The last characters of the gift card.
	LastCharacters string `json:"lastCharacters"`
	// The amount that was applied to the checkout in its currency.
	PresentmentAmountUsed *MoneyV2 `json:"presentmentAmountUsed"`
}

func (AppliedGiftCard) IsNode() {}

// A globally-unique ID.
func (this AppliedGiftCard) GetID() string { return this.ID }

// An article in an online store blog.
type Article struct {
	// The article's author.
	Author *ArticleAuthor `json:"author"`
	// The article's author.
	AuthorV2 *ArticleAuthor `json:"authorV2,omitempty"`
	// The blog that the article belongs to.
	Blog *Blog `json:"blog"`
	// List of comments posted on the article.
	Comments *CommentConnection `json:"comments"`
	// Stripped content of the article, single line with HTML tags removed.
	Content string `json:"content"`
	// The content of the article, complete with HTML formatting.
	ContentHTML string `json:"contentHtml"`
	// Stripped excerpt of the article, single line with HTML tags removed.
	Excerpt *string `json:"excerpt,omitempty"`
	// The excerpt of the article, complete with HTML formatting.
	ExcerptHTML *string `json:"excerptHtml,omitempty"`
	// A human-friendly unique string for the Article automatically generated from its title.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The image associated with the article.
	Image *Image `json:"image,omitempty"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// The date and time when the article was published.
	PublishedAt string `json:"publishedAt"`
	// The article’s SEO information.
	Seo *Seo `json:"seo,omitempty"`
	// A categorization that a article can be tagged with.
	Tags []string `json:"tags"`
	// The article’s name.
	Title string `json:"title"`
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	TrackingParameters *string `json:"trackingParameters,omitempty"`
}

func (Article) IsMenuItemResource() {}

func (Article) IsMetafieldParentResource() {}

func (Article) IsSearchResultItem() {}

func (Article) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Article) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Article) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Article) IsNode() {}

// A globally-unique ID.
func (this Article) GetID() string { return this.ID }

func (Article) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Article) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

func (Article) IsTrackable() {}

// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
func (this Article) GetTrackingParameters() *string { return this.TrackingParameters }

// The author of an article.
type ArticleAuthor struct {
	// The author's bio.
	Bio *string `json:"bio,omitempty"`
	// The author’s email.
	Email string `json:"email"`
	// The author's first name.
	FirstName string `json:"firstName"`
	// The author's last name.
	LastName string `json:"lastName"`
	// The author's full name.
	Name string `json:"name"`
}

// An auto-generated type for paginating through multiple Articles.
type ArticleConnection struct {
	// A list of edges.
	Edges []*ArticleEdge `json:"edges"`
	// A list of the nodes contained in ArticleEdge.
	Nodes []*Article `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Article and a cursor during pagination.
type ArticleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ArticleEdge.
	Node *Article `json:"node"`
}

// Represents a generic custom attribute, such as whether an order is a customer's first.
type Attribute struct {
	// The key or name of the attribute. For example, `"customersFirstOrder"`.
	Key string `json:"key"`
	// The value of the attribute. For example, `"true"`.
	Value *string `json:"value,omitempty"`
}

// The input fields for an attribute.
type AttributeInput struct {
	// Key or name of the attribute.
	Key string `json:"key"`
	// Value of the attribute.
	Value string `json:"value"`
}

// Automatic discount applications capture the intentions of a discount that was automatically applied.
type AutomaticDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (AutomaticDiscountApplication) IsDiscountApplication() {}

// The method by which the discount's value is allocated to its entitled items.
func (this AutomaticDiscountApplication) GetAllocationMethod() DiscountApplicationAllocationMethod {
	return this.AllocationMethod
}

// Which lines of targetType that the discount is allocated over.
func (this AutomaticDiscountApplication) GetTargetSelection() DiscountApplicationTargetSelection {
	return this.TargetSelection
}

// The type of line that the discount is applicable towards.
func (this AutomaticDiscountApplication) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The value of the discount application.
func (this AutomaticDiscountApplication) GetValue() PricingValue { return this.Value }

// A collection of available shipping rates for a checkout.
type AvailableShippingRates struct {
	// Whether or not the shipping rates are ready.
	// The `shippingRates` field is `null` when this value is `false`.
	// This field should be polled until its value becomes `true`.
	Ready bool `json:"ready"`
	// The fetched shipping rates. `null` until the `ready` field is `true`.
	ShippingRates []*ShippingRate `json:"shippingRates,omitempty"`
}

// An auto-generated type for paginating through multiple BaseCartLines.
type BaseCartLineConnection struct {
	// A list of edges.
	Edges []*BaseCartLineEdge `json:"edges"`
	// A list of the nodes contained in BaseCartLineEdge.
	Nodes []BaseCartLine `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one BaseCartLine and a cursor during pagination.
type BaseCartLineEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of BaseCartLineEdge.
	Node BaseCartLine `json:"node"`
}

// An online store blog.
type Blog struct {
	// Find an article by its handle.
	ArticleByHandle *Article `json:"articleByHandle,omitempty"`
	// List of the blog's articles.
	Articles *ArticleConnection `json:"articles"`
	// The authors who have contributed to the blog.
	Authors []*ArticleAuthor `json:"authors"`
	// A human-friendly unique string for the Blog automatically generated from its title.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// The blog's SEO information.
	Seo *Seo `json:"seo,omitempty"`
	// The blogs’s title.
	Title string `json:"title"`
}

func (Blog) IsMenuItemResource() {}

func (Blog) IsMetafieldParentResource() {}

func (Blog) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Blog) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Blog) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Blog) IsNode() {}

// A globally-unique ID.
func (this Blog) GetID() string { return this.ID }

func (Blog) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Blog) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

// An auto-generated type for paginating through multiple Blogs.
type BlogConnection struct {
	// A list of edges.
	Edges []*BlogEdge `json:"edges"`
	// A list of the nodes contained in BlogEdge.
	Nodes []*Blog `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Blog and a cursor during pagination.
type BlogEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of BlogEdge.
	Node *Blog `json:"node"`
}

// The store's [branding configuration](https://help.shopify.com/en/manual/promoting-marketing/managing-brand-assets).
type Brand struct {
	// The colors of the store's brand.
	Colors *BrandColors `json:"colors"`
	// The store's cover image.
	CoverImage *MediaImage `json:"coverImage,omitempty"`
	// The store's default logo.
	Logo *MediaImage `json:"logo,omitempty"`
	// The store's short description.
	ShortDescription *string `json:"shortDescription,omitempty"`
	// The store's slogan.
	Slogan *string `json:"slogan,omitempty"`
	// The store's preferred logo for square UI elements.
	SquareLogo *MediaImage `json:"squareLogo,omitempty"`
}

// A group of related colors for the shop's brand.
type BrandColorGroup struct {
	// The background color.
	Background *string `json:"background,omitempty"`
	// The foreground color.
	Foreground *string `json:"foreground,omitempty"`
}

// The colors of the shop's brand.
type BrandColors struct {
	// The shop's primary brand colors.
	Primary []*BrandColorGroup `json:"primary"`
	// The shop's secondary brand colors.
	Secondary []*BrandColorGroup `json:"secondary"`
}

// The input fields for obtaining the buyer's identity.
type BuyerInput struct {
	// The identifier of the company location.
	CompanyLocationID *string `json:"companyLocationId,omitempty"`
	// The customer access token retrieved from the [Customer Accounts API](https://shopify.dev/docs/api/customer#step-obtain-access-token).
	CustomerAccessToken string `json:"customerAccessToken"`
}

// A cart represents the merchandise that a buyer intends to purchase,
// and the estimated cost associated with the cart. Learn how to
// [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
// during a customer's session.
type Cart struct {
	// The gift cards that have been applied to the cart.
	AppliedGiftCards []*AppliedGiftCard `json:"appliedGiftCards"`
	// An attribute associated with the cart.
	Attribute *Attribute `json:"attribute,omitempty"`
	// The attributes associated with the cart. Attributes are represented as key-value pairs.
	Attributes []*Attribute `json:"attributes"`
	// Information about the buyer that's interacting with the cart.
	BuyerIdentity *CartBuyerIdentity `json:"buyerIdentity"`
	// The URL of the checkout for the cart.
	CheckoutURL string `json:"checkoutUrl"`
	// The estimated costs that the buyer will pay at checkout. The costs are subject to change and changes will be reflected at checkout. The `cost` field uses the `buyerIdentity` field to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
	Cost *CartCost `json:"cost"`
	// The date and time when the cart was created.
	CreatedAt string `json:"createdAt"`
	// The delivery properties of the cart.
	Delivery *CartDelivery `json:"delivery"`
	// The delivery groups available for the cart, based on the buyer identity default
	// delivery address preference or the default address of the logged-in customer.
	DeliveryGroups *CartDeliveryGroupConnection `json:"deliveryGroups"`
	// The discounts that have been applied to the entire cart.
	DiscountAllocations []CartDiscountAllocation `json:"discountAllocations"`
	// The case-insensitive discount codes that the customer added at checkout.
	DiscountCodes []*CartDiscountCode `json:"discountCodes"`
	// The estimated costs that the buyer will pay at checkout. The estimated costs are subject to change and changes will be reflected at checkout. The `estimatedCost` field uses the `buyerIdentity` field to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
	EstimatedCost *CartEstimatedCost `json:"estimatedCost"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A list of lines containing information about the items the customer intends to purchase.
	Lines *BaseCartLineConnection `json:"lines"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// A note that's associated with the cart. For example, the note can be a personalized message to the buyer.
	Note *string `json:"note,omitempty"`
	// The total number of items in the cart.
	TotalQuantity int32 `json:"totalQuantity"`
	// The date and time when the cart was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (Cart) IsMetafieldParentResource() {}

func (Cart) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Cart) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Cart) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Cart) IsNode() {}

// A globally-unique ID.
func (this Cart) GetID() string { return this.ID }

// The input fields to provide exactly one of a variety of delivery address types.
type CartAddressInput struct {
	// Copies details from the customer address to an address on this cart.
	CopyFromCustomerAddressID *string `json:"copyFromCustomerAddressId,omitempty"`
	// A delivery address stored on this cart.
	DeliveryAddress *CartDeliveryAddressInput `json:"deliveryAddress,omitempty"`
}

// Return type for `cartAttributesUpdate` mutation.
type CartAttributesUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The discounts automatically applied to the cart line based on prerequisites that have been met.
type CartAutomaticDiscountAllocation struct {
	// The discount that have been applied on the cart line.
	DiscountApplication *CartDiscountApplication `json:"discountApplication"`
	// The discounted amount that has been applied to the cart line.
	DiscountedAmount *MoneyV2 `json:"discountedAmount"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the allocated discount.
	Title string `json:"title"`
}

func (CartAutomaticDiscountAllocation) IsCartDiscountAllocation() {}

// The discount that have been applied on the cart line.
func (this CartAutomaticDiscountAllocation) GetDiscountApplication() *CartDiscountApplication {
	return this.DiscountApplication
}

// The discounted amount that has been applied to the cart line.
func (this CartAutomaticDiscountAllocation) GetDiscountedAmount() *MoneyV2 {
	return this.DiscountedAmount
}

// The type of line that the discount is applicable towards.
func (this CartAutomaticDiscountAllocation) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// Return type for `cartBillingAddressUpdate` mutation.
type CartBillingAddressUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Represents information about the buyer that is interacting with the cart.
type CartBuyerIdentity struct {
	// The country where the buyer is located.
	CountryCode *CountryCode `json:"countryCode,omitempty"`
	// The customer account associated with the cart.
	Customer *Customer `json:"customer,omitempty"`
	// An ordered set of delivery addresses tied to the buyer that is interacting with the cart.
	// The rank of the preferences is determined by the order of the addresses in the array. Preferences
	// can be used to populate relevant fields in the checkout flow.
	//
	// As of the `2025-01` release, `buyerIdentity.deliveryAddressPreferences` is deprecated.
	// Delivery addresses are now part of the `CartDelivery` object and managed with three new mutations:
	// - `cartDeliveryAddressAdd`
	// - `cartDeliveryAddressUpdate`
	// - `cartDeliveryAddressDelete`
	DeliveryAddressPreferences []DeliveryAddress `json:"deliveryAddressPreferences"`
	// The email address of the buyer that's interacting with the cart.
	Email *string `json:"email,omitempty"`
	// The phone number of the buyer that's interacting with the cart.
	Phone *string `json:"phone,omitempty"`
	// A set of preferences tied to the buyer interacting with the cart. Preferences are used to prefill fields in at checkout to streamline information collection.
	// Preferences are not synced back to the cart if they are overwritten.
	Preferences *CartPreferences `json:"preferences,omitempty"`
	// The purchasing company associated with the cart.
	PurchasingCompany *PurchasingCompany `json:"purchasingCompany,omitempty"`
}

// Specifies the input fields to update the buyer information associated with a cart.
// Buyer identity is used to determine
// [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
// and should match the customer's shipping address.
type CartBuyerIdentityInput struct {
	// The company location of the buyer that is interacting with the cart.
	CompanyLocationID *string `json:"companyLocationId,omitempty"`
	// The country where the buyer is located.
	CountryCode *CountryCode `json:"countryCode,omitempty"`
	// The access token used to identify the customer associated with the cart.
	CustomerAccessToken *string `json:"customerAccessToken,omitempty"`
	// The email address of the buyer that is interacting with the cart.
	Email *string `json:"email,omitempty"`
	// The phone number of the buyer that is interacting with the cart.
	Phone *string `json:"phone,omitempty"`
	// A set of preferences tied to the buyer interacting with the cart. Preferences are used to prefill fields in at checkout to streamline information collection.
	// Preferences are not synced back to the cart if they are overwritten.
	Preferences *CartPreferencesInput `json:"preferences,omitempty"`
}

// Return type for `cartBuyerIdentityUpdate` mutation.
type CartBuyerIdentityUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The discount that has been applied to the cart line using a discount code.
type CartCodeDiscountAllocation struct {
	// The code used to apply the discount.
	Code string `json:"code"`
	// The discount that have been applied on the cart line.
	DiscountApplication *CartDiscountApplication `json:"discountApplication"`
	// The discounted amount that has been applied to the cart line.
	DiscountedAmount *MoneyV2 `json:"discountedAmount"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
}

func (CartCodeDiscountAllocation) IsCartDiscountAllocation() {}

// The discount that have been applied on the cart line.
func (this CartCodeDiscountAllocation) GetDiscountApplication() *CartDiscountApplication {
	return this.DiscountApplication
}

// The discounted amount that has been applied to the cart line.
func (this CartCodeDiscountAllocation) GetDiscountedAmount() *MoneyV2 { return this.DiscountedAmount }

// The type of line that the discount is applicable towards.
func (this CartCodeDiscountAllocation) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The required completion action to checkout a cart.
type CartCompletionActionRequired struct {
	// The action required to complete the cart completion attempt.
	Action CartCompletionAction `json:"action,omitempty"`
	// The ID of the cart completion attempt.
	ID string `json:"id"`
}

func (CartCompletionActionRequired) IsCartCompletionAttemptResult() {}

// A failed completion to checkout a cart.
type CartCompletionFailed struct {
	// The errors that caused the checkout to fail.
	Errors []*CompletionError `json:"errors"`
	// The ID of the cart completion attempt.
	ID string `json:"id"`
}

func (CartCompletionFailed) IsCartCompletionAttemptResult() {}

// A cart checkout completion that's still processing.
type CartCompletionProcessing struct {
	// The ID of the cart completion attempt.
	ID string `json:"id"`
	// The number of milliseconds to wait before polling again.
	PollDelay int32 `json:"pollDelay"`
}

func (CartCompletionProcessing) IsCartCompletionAttemptResult() {}

// A successful completion to checkout a cart and a created order.
type CartCompletionSuccess struct {
	// The date and time when the job completed.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The ID of the cart completion attempt.
	ID string `json:"id"`
	// The ID of the order that's created in Shopify.
	OrderID string `json:"orderId"`
	// The URL of the order confirmation in Shopify.
	OrderURL string `json:"orderUrl"`
}

func (CartCompletionSuccess) IsCartCompletionAttemptResult() {}

// The costs that the buyer will pay at checkout.
// The cart cost uses [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity) to determine
// [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
type CartCost struct {
	// The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to `subtotalAmount`.
	CheckoutChargeAmount *MoneyV2 `json:"checkoutChargeAmount"`
	// The amount, before taxes and cart-level discounts, for the customer to pay.
	SubtotalAmount *MoneyV2 `json:"subtotalAmount"`
	// Whether the subtotal amount is estimated.
	SubtotalAmountEstimated bool `json:"subtotalAmountEstimated"`
	// The total amount for the customer to pay.
	TotalAmount *MoneyV2 `json:"totalAmount"`
	// Whether the total amount is estimated.
	TotalAmountEstimated bool `json:"totalAmountEstimated"`
	// The duty amount for the customer to pay at checkout.
	TotalDutyAmount *MoneyV2 `json:"totalDutyAmount,omitempty"`
	// Whether the total duty amount is estimated.
	TotalDutyAmountEstimated bool `json:"totalDutyAmountEstimated"`
	// The tax amount for the customer to pay at checkout.
	TotalTaxAmount *MoneyV2 `json:"totalTaxAmount,omitempty"`
	// Whether the total tax amount is estimated.
	TotalTaxAmountEstimated bool `json:"totalTaxAmountEstimated"`
}

// Return type for `cartCreate` mutation.
type CartCreatePayload struct {
	// The new cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The discounts automatically applied to the cart line based on prerequisites that have been met.
type CartCustomDiscountAllocation struct {
	// The discount that have been applied on the cart line.
	DiscountApplication *CartDiscountApplication `json:"discountApplication"`
	// The discounted amount that has been applied to the cart line.
	DiscountedAmount *MoneyV2 `json:"discountedAmount"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the allocated discount.
	Title string `json:"title"`
}

func (CartCustomDiscountAllocation) IsCartDiscountAllocation() {}

// The discount that have been applied on the cart line.
func (this CartCustomDiscountAllocation) GetDiscountApplication() *CartDiscountApplication {
	return this.DiscountApplication
}

// The discounted amount that has been applied to the cart line.
func (this CartCustomDiscountAllocation) GetDiscountedAmount() *MoneyV2 { return this.DiscountedAmount }

// The type of line that the discount is applicable towards.
func (this CartCustomDiscountAllocation) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The delivery properties of the cart.
type CartDelivery struct {
	// Selectable addresses to present to the buyer on the cart.
	Addresses []*CartSelectableAddress `json:"addresses"`
}

// Represents a mailing address for customers and shipping.
type CartDeliveryAddress struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2,omitempty"`
	// The name of the city, district, village, or town.
	City *string `json:"city,omitempty"`
	// The name of the customer's company or organization.
	Company *string `json:"company,omitempty"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	CountryCode *string `json:"countryCode,omitempty"`
	// The first name of the customer.
	FirstName *string `json:"firstName,omitempty"`
	// A formatted version of the address, customized by the provided arguments.
	Formatted []string `json:"formatted"`
	// A comma-separated list of the values for city, province, and country.
	FormattedArea *string `json:"formattedArea,omitempty"`
	// The last name of the customer.
	LastName *string `json:"lastName,omitempty"`
	// The latitude coordinate of the customer address.
	Latitude *float64 `json:"latitude,omitempty"`
	// The longitude coordinate of the customer address.
	Longitude *float64 `json:"longitude,omitempty"`
	// The full name of the customer, based on firstName and lastName.
	Name *string `json:"name,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone,omitempty"`
	// The alphanumeric code for the region.
	//
	// For example, ON.
	ProvinceCode *string `json:"provinceCode,omitempty"`
	// The zip or postal code of the address.
	Zip *string `json:"zip,omitempty"`
}

func (CartDeliveryAddress) IsCartAddress() {}

// The input fields to create or update a cart address.
type CartDeliveryAddressInput struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2,omitempty"`
	// The name of the city, district, village, or town.
	City *string `json:"city,omitempty"`
	// The name of the customer's company or organization.
	Company *string `json:"company,omitempty"`
	// The name of the country.
	CountryCode *CountryCode `json:"countryCode,omitempty"`
	// The first name of the customer.
	FirstName *string `json:"firstName,omitempty"`
	// The last name of the customer.
	LastName *string `json:"lastName,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone,omitempty"`
	// The region of the address, such as the province, state, or district.
	ProvinceCode *string `json:"provinceCode,omitempty"`
	// The zip or postal code of the address.
	Zip *string `json:"zip,omitempty"`
}

// Return type for `cartDeliveryAddressesAdd` mutation.
type CartDeliveryAddressesAddPayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartDeliveryAddressesRemove` mutation.
type CartDeliveryAddressesRemovePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartDeliveryAddressesReplace` mutation.
type CartDeliveryAddressesReplacePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartDeliveryAddressesUpdate` mutation.
type CartDeliveryAddressesUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Preferred location used to find the closest pick up point based on coordinates.
type CartDeliveryCoordinatesPreference struct {
	// The two-letter code for the country of the preferred location.
	//
	// For example, US.
	CountryCode CountryCode `json:"countryCode"`
	// The geographic latitude for a given location. Coordinates are required in order to set pickUpHandle for pickup points.
	Latitude float64 `json:"latitude"`
	// The geographic longitude for a given location. Coordinates are required in order to set pickUpHandle for pickup points.
	Longitude float64 `json:"longitude"`
}

// Preferred location used to find the closest pick up point based on coordinates.
type CartDeliveryCoordinatesPreferenceInput struct {
	// The two-letter code for the country of the preferred location.
	//
	// For example, US.
	CountryCode CountryCode `json:"countryCode"`
	// The geographic latitude for a given location. Coordinates are required in order to set pickUpHandle for pickup points.
	Latitude float64 `json:"latitude"`
	// The geographic longitude for a given location. Coordinates are required in order to set pickUpHandle for pickup points.
	Longitude float64 `json:"longitude"`
}

// Information about the options available for one or more line items to be delivered to a specific address.
type CartDeliveryGroup struct {
	// A list of cart lines for the delivery group.
	CartLines *BaseCartLineConnection `json:"cartLines"`
	// The destination address for the delivery group.
	DeliveryAddress *MailingAddress `json:"deliveryAddress"`
	// The delivery options available for the delivery group.
	DeliveryOptions []*CartDeliveryOption `json:"deliveryOptions"`
	// The type of merchandise in the delivery group.
	GroupType CartDeliveryGroupType `json:"groupType"`
	// The ID for the delivery group.
	ID string `json:"id"`
	// The selected delivery option for the delivery group.
	SelectedDeliveryOption *CartDeliveryOption `json:"selectedDeliveryOption,omitempty"`
}

// An auto-generated type for paginating through multiple CartDeliveryGroups.
type CartDeliveryGroupConnection struct {
	// A list of edges.
	Edges []*CartDeliveryGroupEdge `json:"edges"`
	// A list of the nodes contained in CartDeliveryGroupEdge.
	Nodes []*CartDeliveryGroup `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one CartDeliveryGroup and a cursor during pagination.
type CartDeliveryGroupEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CartDeliveryGroupEdge.
	Node *CartDeliveryGroup `json:"node"`
}

// The input fields for the cart's delivery properties.
type CartDeliveryInput struct {
	// Selectable addresses to present to the buyer on the cart.
	//
	// The input must not contain more than `250` values.
	Addresses []*CartSelectableAddressInput `json:"addresses,omitempty"`
}

// Information about a delivery option.
type CartDeliveryOption struct {
	// The code of the delivery option.
	Code *string `json:"code,omitempty"`
	// The method for the delivery option.
	DeliveryMethodType DeliveryMethodType `json:"deliveryMethodType"`
	// The description of the delivery option.
	Description *string `json:"description,omitempty"`
	// The estimated cost for the delivery option.
	EstimatedCost *MoneyV2 `json:"estimatedCost"`
	// The unique identifier of the delivery option.
	Handle string `json:"handle"`
	// The title of the delivery option.
	Title *string `json:"title,omitempty"`
}

// A set of preferences tied to the buyer interacting with the cart. Preferences are used to prefill fields in at checkout to streamline information collection.
// Preferences are not synced back to the cart if they are overwritten.
type CartDeliveryPreference struct {
	// Preferred location used to find the closest pick up point based on coordinates.
	Coordinates *CartDeliveryCoordinatesPreference `json:"coordinates,omitempty"`
	// The preferred delivery methods such as shipping, local pickup or through pickup points.
	DeliveryMethod []PreferenceDeliveryMethodType `json:"deliveryMethod"`
	// The pickup handle prefills checkout fields with the location for either local pickup or pickup points delivery methods.
	// It accepts both location ID for local pickup and external IDs for pickup points.
	PickupHandle []string `json:"pickupHandle"`
}

// Delivery preferences can be used to prefill the delivery section at checkout.
type CartDeliveryPreferenceInput struct {
	// The coordinates of a delivery location in order of preference.
	Coordinates *CartDeliveryCoordinatesPreferenceInput `json:"coordinates,omitempty"`
	// The preferred delivery methods such as shipping, local pickup or through pickup points.
	//
	// The input must not contain more than `250` values.
	DeliveryMethod []PreferenceDeliveryMethodType `json:"deliveryMethod,omitempty"`
	// The pickup handle prefills checkout fields with the location for either local pickup or pickup points delivery methods.
	// It accepts both location ID for local pickup and external IDs for pickup points.
	//
	// The input must not contain more than `250` values.
	PickupHandle []string `json:"pickupHandle,omitempty"`
}

// The input fields for submitting direct payment method information for checkout.
type CartDirectPaymentMethodInput struct {
	// Indicates if the customer has accepted the subscription terms. Defaults to false.
	AcceptedSubscriptionTerms *bool `json:"acceptedSubscriptionTerms,omitempty"`
	// The customer's billing address.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// The source of the credit card payment.
	CardSource *CartCardSource `json:"cardSource,omitempty"`
	// The session ID for the direct payment method used to create the payment.
	SessionID string `json:"sessionId"`
}

// The discount application capture the intentions of a discount source at
// the time of application.
type CartDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

// The discount codes applied to the cart.
type CartDiscountCode struct {
	// Whether the discount code is applicable to the cart's current contents.
	Applicable bool `json:"applicable"`
	// The code for the discount.
	Code string `json:"code"`
}

// Return type for `cartDiscountCodesUpdate` mutation.
type CartDiscountCodesUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The estimated costs that the buyer will pay at checkout. The estimated cost uses [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity) to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
type CartEstimatedCost struct {
	// The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to`subtotal_amount`.
	CheckoutChargeAmount *MoneyV2 `json:"checkoutChargeAmount"`
	// The estimated amount, before taxes and discounts, for the customer to pay.
	SubtotalAmount *MoneyV2 `json:"subtotalAmount"`
	// The estimated total amount for the customer to pay.
	TotalAmount *MoneyV2 `json:"totalAmount"`
	// The estimated duty amount for the customer to pay at checkout.
	TotalDutyAmount *MoneyV2 `json:"totalDutyAmount,omitempty"`
	// The estimated tax amount for the customer to pay at checkout.
	TotalTaxAmount *MoneyV2 `json:"totalTaxAmount,omitempty"`
}

// The input fields for submitting a billing address without a selected payment method.
type CartFreePaymentMethodInput struct {
	// The customer's billing address.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
}

// Return type for `cartGiftCardCodesRemove` mutation.
type CartGiftCardCodesRemovePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartGiftCardCodesUpdate` mutation.
type CartGiftCardCodesUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The input fields to create a cart.
type CartInput struct {
	// An array of key-value pairs that contains additional information about the cart.
	//
	// The input must not contain more than `250` values.
	Attributes []*AttributeInput `json:"attributes,omitempty"`
	// The customer associated with the cart. Used to determine [international pricing]
	// (https://shopify.dev/custom-storefronts/internationalization/international-pricing).
	// Buyer identity should match the customer's shipping address.
	BuyerIdentity *CartBuyerIdentityInput `json:"buyerIdentity,omitempty"`
	// The delivery-related fields for the cart.
	Delivery *CartDeliveryInput `json:"delivery,omitempty"`
	// The case-insensitive discount codes that the customer added at checkout.
	//
	// The input must not contain more than `250` values.
	DiscountCodes []string `json:"discountCodes,omitempty"`
	// The case-insensitive gift card codes.
	//
	// The input must not contain more than `250` values.
	GiftCardCodes []string `json:"giftCardCodes,omitempty"`
	// A list of merchandise lines to add to the cart.
	//
	// The input must not contain more than `250` values.
	Lines []*CartLineInput `json:"lines,omitempty"`
	// The metafields to associate with this cart.
	//
	// The input must not contain more than `250` values.
	Metafields []*CartInputMetafieldInput `json:"metafields,omitempty"`
	// A note that's associated with the cart. For example, the note can be a personalized message to the buyer.
	Note *string `json:"note,omitempty"`
}

// The input fields for a cart metafield value to set.
type CartInputMetafieldInput struct {
	// The key name of the metafield.
	Key string `json:"key"`
	// The type of data that the cart metafield stores.
	// The type of data must be a [supported type](https://shopify.dev/apps/metafields/types).
	Type string `json:"type"`
	// The data to store in the cart metafield. The data is always stored as a string, regardless of the metafield's type.
	Value string `json:"value"`
}

// Represents information about the merchandise in the cart.
type CartLine struct {
	// An attribute associated with the cart line.
	Attribute *Attribute `json:"attribute,omitempty"`
	// The attributes associated with the cart line. Attributes are represented as key-value pairs.
	Attributes []*Attribute `json:"attributes"`
	// The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout.
	Cost *CartLineCost `json:"cost"`
	// The discounts that have been applied to the cart line.
	DiscountAllocations []CartDiscountAllocation `json:"discountAllocations"`
	// The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
	EstimatedCost *CartLineEstimatedCost `json:"estimatedCost"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The merchandise that the buyer intends to purchase.
	Merchandise Merchandise `json:"merchandise"`
	// The quantity of the merchandise that the customer intends to purchase.
	Quantity int32 `json:"quantity"`
	// The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased.
	SellingPlanAllocation *SellingPlanAllocation `json:"sellingPlanAllocation,omitempty"`
}

func (CartLine) IsBaseCartLine() {}

// An attribute associated with the cart line.
func (this CartLine) GetAttribute() *Attribute { return this.Attribute }

// The attributes associated with the cart line. Attributes are represented as key-value pairs.
func (this CartLine) GetAttributes() []*Attribute {
	if this.Attributes == nil {
		return nil
	}
	interfaceSlice := make([]*Attribute, 0, len(this.Attributes))
	for _, concrete := range this.Attributes {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout.
func (this CartLine) GetCost() *CartLineCost { return this.Cost }

// The discounts that have been applied to the cart line.
func (this CartLine) GetDiscountAllocations() []CartDiscountAllocation {
	if this.DiscountAllocations == nil {
		return nil
	}
	interfaceSlice := make([]CartDiscountAllocation, 0, len(this.DiscountAllocations))
	for _, concrete := range this.DiscountAllocations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
func (this CartLine) GetEstimatedCost() *CartLineEstimatedCost { return this.EstimatedCost }

// A globally-unique ID.
func (this CartLine) GetID() string { return this.ID }

// The merchandise that the buyer intends to purchase.
func (this CartLine) GetMerchandise() Merchandise { return this.Merchandise }

// The quantity of the merchandise that the customer intends to purchase.
func (this CartLine) GetQuantity() int32 { return this.Quantity }

// The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased.
func (this CartLine) GetSellingPlanAllocation() *SellingPlanAllocation {
	return this.SellingPlanAllocation
}

func (CartLine) IsNode() {}

// A globally-unique ID.

// The cost of the merchandise line that the buyer will pay at checkout.
type CartLineCost struct {
	// The amount of the merchandise line.
	AmountPerQuantity *MoneyV2 `json:"amountPerQuantity"`
	// The compare at amount of the merchandise line.
	CompareAtAmountPerQuantity *MoneyV2 `json:"compareAtAmountPerQuantity,omitempty"`
	// The cost of the merchandise line before line-level discounts.
	SubtotalAmount *MoneyV2 `json:"subtotalAmount"`
	// The total cost of the merchandise line.
	TotalAmount *MoneyV2 `json:"totalAmount"`
}

// The estimated cost of the merchandise line that the buyer will pay at checkout.
type CartLineEstimatedCost struct {
	// The amount of the merchandise line.
	Amount *MoneyV2 `json:"amount"`
	// The compare at amount of the merchandise line.
	CompareAtAmount *MoneyV2 `json:"compareAtAmount,omitempty"`
	// The estimated cost of the merchandise line before discounts.
	SubtotalAmount *MoneyV2 `json:"subtotalAmount"`
	// The estimated total cost of the merchandise line.
	TotalAmount *MoneyV2 `json:"totalAmount"`
}

// The input fields to create a merchandise line on a cart.
type CartLineInput struct {
	// An array of key-value pairs that contains additional information about the merchandise line.
	//
	// The input must not contain more than `250` values.
	Attributes []*AttributeInput `json:"attributes,omitempty"`
	// The ID of the merchandise that the buyer intends to purchase.
	MerchandiseID string `json:"merchandiseId"`
	// The quantity of the merchandise.
	Quantity *int32 `json:"quantity,omitempty"`
	// The ID of the selling plan that the merchandise is being purchased with.
	SellingPlanID *string `json:"sellingPlanId,omitempty"`
}

// The input fields to update a line item on a cart.
type CartLineUpdateInput struct {
	// An array of key-value pairs that contains additional information about the merchandise line.
	//
	// The input must not contain more than `250` values.
	Attributes []*AttributeInput `json:"attributes,omitempty"`
	// The ID of the merchandise line.
	ID string `json:"id"`
	// The ID of the merchandise for the line item.
	MerchandiseID *string `json:"merchandiseId,omitempty"`
	// The quantity of the line item.
	Quantity *int32 `json:"quantity,omitempty"`
	// The ID of the selling plan that the merchandise is being purchased with.
	SellingPlanID *string `json:"sellingPlanId,omitempty"`
}

// Return type for `cartLinesAdd` mutation.
type CartLinesAddPayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartLinesRemove` mutation.
type CartLinesRemovePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Return type for `cartLinesUpdate` mutation.
type CartLinesUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// The input fields to delete a cart metafield.
type CartMetafieldDeleteInput struct {
	// The key name of the cart metafield. Can either be a composite key (`namespace.key`) or a simple key
	// that relies on the default app-reserved namespace.
	Key string `json:"key"`
	// The ID of the cart resource.
	OwnerID string `json:"ownerId"`
}

// Return type for `cartMetafieldDelete` mutation.
type CartMetafieldDeletePayload struct {
	// The ID of the deleted cart metafield.
	DeletedID *string `json:"deletedId,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*MetafieldDeleteUserError `json:"userErrors"`
}

// The input fields for a cart metafield value to set.
type CartMetafieldsSetInput struct {
	// The key name of the cart metafield.
	Key string `json:"key"`
	// The ID of the cart resource.
	OwnerID string `json:"ownerId"`
	// The type of data that the cart metafield stores.
	// The type of data must be a [supported type](https://shopify.dev/apps/metafields/types).
	Type string `json:"type"`
	// The data to store in the cart metafield. The data is always stored as a string, regardless of the metafield's type.
	Value string `json:"value"`
}

// Return type for `cartMetafieldsSet` mutation.
type CartMetafieldsSetPayload struct {
	// The list of cart metafields that were set.
	Metafields []*Metafield `json:"metafields,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*MetafieldsSetUserError `json:"userErrors"`
}

// Return type for `cartNoteUpdate` mutation.
type CartNoteUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// An error occurred during the cart operation.
type CartOperationError struct {
	// The error code.
	Code string `json:"code"`
	// The error message.
	Message *string `json:"message,omitempty"`
}

// The input fields for updating the payment method that will be used to checkout.
type CartPaymentInput struct {
	// The amount that the customer will be charged at checkout.
	Amount *MoneyInput `json:"amount"`
	// The input fields to use when checking out a cart with a direct payment method (like a credit card).
	DirectPaymentMethod *CartDirectPaymentMethodInput `json:"directPaymentMethod,omitempty"`
	// The input fields to use to checkout a cart without providing a payment method.
	// Use this payment method input if the total cost of the cart is 0.
	FreePaymentMethod *CartFreePaymentMethodInput `json:"freePaymentMethod,omitempty"`
	// An ID of the order placed on the originating platform.
	// Note that this value doesn't correspond to the Shopify Order ID.
	SourceIdentifier *string `json:"sourceIdentifier,omitempty"`
	// The input fields to use when checking out a cart with a wallet payment method (like Shop Pay or Apple Pay).
	WalletPaymentMethod *CartWalletPaymentMethodInput `json:"walletPaymentMethod,omitempty"`
}

// Return type for `cartPaymentUpdate` mutation.
type CartPaymentUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// A set of preferences tied to the buyer interacting with the cart. Preferences are used to prefill fields in at checkout to streamline information collection.
// Preferences are not synced back to the cart if they are overwritten.
type CartPreferences struct {
	// Delivery preferences can be used to prefill the delivery section in at checkout.
	Delivery *CartDeliveryPreference `json:"delivery,omitempty"`
	// Wallet preferences are used to populate relevant payment fields in the checkout flow.
	// Accepted value: `["shop_pay"]`.
	Wallet []string `json:"wallet,omitempty"`
}

// The input fields represent preferences for the buyer that is interacting with the cart.
type CartPreferencesInput struct {
	// Delivery preferences can be used to prefill the delivery section in at checkout.
	Delivery *CartDeliveryPreferenceInput `json:"delivery,omitempty"`
	// Wallet preferences are used to populate relevant payment fields in the checkout flow.
	// Accepted value: `["shop_pay"]`.
	//
	// The input must not contain more than `250` values.
	Wallet []string `json:"wallet,omitempty"`
}

// Return type for `cartPrepareForCompletion` mutation.
type CartPrepareForCompletionPayload struct {
	// The result of cart preparation for completion.
	Result CartPrepareForCompletionResult `json:"result,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
}

// Return type for `cartRemovePersonalData` mutation.
type CartRemovePersonalDataPayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// A selectable delivery address for a cart.
type CartSelectableAddress struct {
	// The delivery address.
	Address CartAddress `json:"address"`
	// A unique identifier for the address, specific to this cart.
	ID string `json:"id"`
	// This delivery address will not be associated with the buyer after a successful checkout.
	OneTimeUse bool `json:"oneTimeUse"`
	// Sets exactly one address as pre-selected for the buyer.
	Selected bool `json:"selected"`
}

// The input fields for a selectable delivery address in a cart.
type CartSelectableAddressInput struct {
	// Exactly one kind of delivery address.
	Address *CartAddressInput `json:"address"`
	// When true, this delivery address will not be associated with the buyer after a successful checkout.
	OneTimeUse *bool `json:"oneTimeUse,omitempty"`
	// Sets exactly one address as pre-selected for the buyer.
	Selected *bool `json:"selected,omitempty"`
	// Defines what kind of address validation is requested.
	ValidationStrategy *DeliveryAddressValidationStrategy `json:"validationStrategy,omitempty"`
}

// The input fields to update a line item on a cart.
type CartSelectableAddressUpdateInput struct {
	// Exactly one kind of delivery address.
	Address *CartAddressInput `json:"address,omitempty"`
	// The id of the selectable address.
	ID string `json:"id"`
	// When true, this delivery address will not be associated with the buyer after a successful checkout.
	OneTimeUse *bool `json:"oneTimeUse,omitempty"`
	// Sets exactly one address as pre-selected for the buyer.
	Selected *bool `json:"selected,omitempty"`
	// Defines what kind of address validation is requested.
	ValidationStrategy *DeliveryAddressValidationStrategy `json:"validationStrategy,omitempty"`
}

// The input fields for updating the selected delivery options for a delivery group.
type CartSelectedDeliveryOptionInput struct {
	// The ID of the cart delivery group.
	DeliveryGroupID string `json:"deliveryGroupId"`
	// The handle of the selected delivery option.
	DeliveryOptionHandle string `json:"deliveryOptionHandle"`
}

// Return type for `cartSelectedDeliveryOptionsUpdate` mutation.
type CartSelectedDeliveryOptionsUpdatePayload struct {
	// The updated cart.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
	// A list of warnings that occurred during the mutation.
	Warnings []*CartWarning `json:"warnings"`
}

// Cart is not ready for payment update and completion.
type CartStatusNotReady struct {
	// The result of cart preparation for completion.
	Cart *Cart `json:"cart,omitempty"`
	// The list of errors that caused the cart to not be ready for payment update and completion.
	Errors []*CartOperationError `json:"errors"`
}

func (CartStatusNotReady) IsCartPrepareForCompletionResult() {}

// Cart is ready for payment update and completion.
type CartStatusReady struct {
	// The result of cart preparation for completion.
	Cart *Cart `json:"cart,omitempty"`
}

func (CartStatusReady) IsCartPrepareForCompletionResult() {}

// Return type for `cartSubmitForCompletion` mutation.
type CartSubmitForCompletionPayload struct {
	// The result of cart submission for completion.
	Result CartSubmitForCompletionResult `json:"result,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CartUserError `json:"userErrors"`
}

// Response signifying that the access to cart request is currently being throttled.
// The client can retry after `poll_after`.
type CartThrottled struct {
	// The result of cart preparation for completion.
	Cart *Cart `json:"cart,omitempty"`
	// The polling delay.
	PollAfter string `json:"pollAfter"`
}

func (CartThrottled) IsCartPrepareForCompletionResult() {}

// Represents an error that happens during execution of a cart mutation.
type CartUserError struct {
	// The error code.
	Code *CartErrorCode `json:"code,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (CartUserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this CartUserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this CartUserError) GetMessage() string { return this.Message }

// The input fields for submitting wallet payment method information for checkout.
type CartWalletPaymentMethodInput struct {
	// The payment method information for the Apple Pay wallet.
	ApplePayWalletContent *ApplePayWalletContentInput `json:"applePayWalletContent,omitempty"`
	// The payment method information for the Shop Pay wallet.
	ShopPayWalletContent *ShopPayWalletContentInput `json:"shopPayWalletContent,omitempty"`
}

// A warning that occurred during a cart mutation.
type CartWarning struct {
	// The code of the warning.
	Code CartWarningCode `json:"code"`
	// The message text of the warning.
	Message string `json:"message"`
	// The target of the warning.
	Target string `json:"target"`
}

// A filter used to view a subset of products in a collection matching a specific category value.
type CategoryFilter struct {
	// The id of the category to filter on.
	ID string `json:"id"`
}

// A container for all the information required to checkout items and pay.
//
// The Storefront GraphQL Checkout API is deprecated and will be removed in a future version. Please see https://shopify.dev/changelog/deprecation-of-checkout-apis for more information.
type Checkout struct {
	// The gift cards used on the checkout.
	AppliedGiftCards []*AppliedGiftCard `json:"appliedGiftCards"`
	// The available shipping rates for this Checkout.
	// Should only be used when checkout `requiresShipping` is `true` and
	// the shipping address is valid.
	AvailableShippingRates *AvailableShippingRates `json:"availableShippingRates,omitempty"`
	// The identity of the customer associated with the checkout.
	BuyerIdentity *CheckoutBuyerIdentity `json:"buyerIdentity"`
	// The date and time when the checkout was completed.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The date and time when the checkout was created.
	CreatedAt string `json:"createdAt"`
	// The currency code for the checkout.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// A list of extra information that's added to the checkout.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// Discounts that have been applied on the checkout.
	DiscountApplications *DiscountApplicationConnection `json:"discountApplications"`
	// The email attached to this checkout.
	Email *string `json:"email,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A list of line item objects, each one containing information about an item in the checkout.
	LineItems *CheckoutLineItemConnection `json:"lineItems"`
	// The sum of all the prices of all the items in the checkout. Duties, taxes, shipping and discounts excluded.
	LineItemsSubtotalPrice *MoneyV2 `json:"lineItemsSubtotalPrice"`
	// The note associated with the checkout.
	Note *string `json:"note,omitempty"`
	// The resulting order from a paid checkout.
	Order *Order `json:"order,omitempty"`
	// The <b>Order status</b> page for this Checkout, null when checkout isn't completed.
	OrderStatusURL *string `json:"orderStatusUrl,omitempty"`
	// The amount left to be paid. This is equal to the cost of the line items, taxes, and shipping, minus discounts and gift cards.
	PaymentDue *MoneyV2 `json:"paymentDue"`
	// The amount left to be paid. This is equal to the cost of the line items, duties, taxes, and shipping, minus discounts and gift cards.
	PaymentDueV2 *MoneyV2 `json:"paymentDueV2"`
	// Whether or not the Checkout is ready and can be completed. Checkouts may
	// have asynchronous operations that can take time to finish. If you want
	// to complete a checkout or ensure all the fields are populated and up to
	// date, polling is required until the value is true.
	Ready bool `json:"ready"`
	// States whether or not the fulfillment requires shipping.
	RequiresShipping bool `json:"requiresShipping"`
	// The shipping address to where the line items will be shipped.
	ShippingAddress *MailingAddress `json:"shippingAddress,omitempty"`
	// The discounts that have been allocated onto the shipping line by discount applications.
	ShippingDiscountAllocations []*DiscountAllocation `json:"shippingDiscountAllocations"`
	// Once a shipping rate is selected by the customer it's transitioned to a `shipping_line` object.
	ShippingLine *ShippingRate `json:"shippingLine,omitempty"`
	// The price at checkout before shipping and taxes.
	SubtotalPrice *MoneyV2 `json:"subtotalPrice"`
	// The price at checkout before duties, shipping, and taxes.
	SubtotalPriceV2 *MoneyV2 `json:"subtotalPriceV2"`
	// Whether the checkout is tax exempt.
	TaxExempt bool `json:"taxExempt"`
	// Whether taxes are included in the line item and shipping line prices.
	TaxesIncluded bool `json:"taxesIncluded"`
	// The sum of all the duties applied to the line items in the checkout.
	TotalDuties *MoneyV2 `json:"totalDuties,omitempty"`
	// The sum of all the prices of all the items in the checkout, including taxes and duties.
	TotalPrice *MoneyV2 `json:"totalPrice"`
	// The sum of all the prices of all the items in the checkout, including taxes and duties.
	TotalPriceV2 *MoneyV2 `json:"totalPriceV2"`
	// The sum of all the taxes applied to the line items and shipping lines in the checkout.
	TotalTax *MoneyV2 `json:"totalTax"`
	// The sum of all the taxes applied to the line items and shipping lines in the checkout.
	TotalTaxV2 *MoneyV2 `json:"totalTaxV2"`
	// The date and time when the checkout was last updated.
	UpdatedAt string `json:"updatedAt"`
	// The url pointing to the checkout accessible from the web.
	WebURL string `json:"webUrl"`
}

func (Checkout) IsNode() {}

// A globally-unique ID.
func (this Checkout) GetID() string { return this.ID }

// The input fields required to update a checkout's attributes.
type CheckoutAttributesUpdateV2Input struct {
	// Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
	// The required attributes are city, province, and country.
	// Full validation of the addresses is still done at completion time. Defaults to `false` with
	// each operation.
	AllowPartialAddresses *bool `json:"allowPartialAddresses,omitempty"`
	// A list of extra information that's added to the checkout.
	//
	// The input must not contain more than `250` values.
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The text of an optional note that a shop owner can attach to the checkout.
	Note *string `json:"note,omitempty"`
}

// Return type for `checkoutAttributesUpdateV2` mutation.
type CheckoutAttributesUpdateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The identity of the customer associated with the checkout.
type CheckoutBuyerIdentity struct {
	// The country code for the checkout. For example, `CA`.
	CountryCode *CountryCode `json:"countryCode,omitempty"`
}

// The input fields for the identity of the customer associated with the checkout.
type CheckoutBuyerIdentityInput struct {
	// The country code of one of the shop's
	// [enabled countries](https://help.shopify.com/en/manual/payments/shopify-payments/multi-currency/setup).
	// For example, `CA`. Including this field creates a checkout in the specified country's currency.
	CountryCode CountryCode `json:"countryCode"`
}

// Return type for `checkoutCompleteFree` mutation.
type CheckoutCompleteFreePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithCreditCardV2` mutation.
type CheckoutCompleteWithCreditCardV2Payload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCompleteWithTokenizedPaymentV3` mutation.
type CheckoutCompleteWithTokenizedPaymentV3Payload struct {
	// The checkout on which the payment was applied.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// A representation of the attempted payment.
	Payment *Payment `json:"payment,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields required to create a checkout.
type CheckoutCreateInput struct {
	// Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
	// The required attributes are city, province, and country.
	// Full validation of addresses is still done at completion time. Defaults to `null`.
	AllowPartialAddresses *bool `json:"allowPartialAddresses,omitempty"`
	// The identity of the customer associated with the checkout.
	BuyerIdentity *CheckoutBuyerIdentityInput `json:"buyerIdentity,omitempty"`
	// A list of extra information that's added to the checkout.
	//
	// The input must not contain more than `250` values.
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The email with which the customer wants to checkout.
	Email *string `json:"email,omitempty"`
	// A list of line item objects, each one containing information about an item in the checkout.
	//
	// The input must not contain more than `250` values.
	LineItems []*CheckoutLineItemInput `json:"lineItems,omitempty"`
	// The text of an optional note that a shop owner can attach to the checkout.
	Note *string `json:"note,omitempty"`
	// The shipping address to where the line items will be shipped.
	ShippingAddress *MailingAddressInput `json:"shippingAddress,omitempty"`
}

// Return type for `checkoutCreate` mutation.
type CheckoutCreatePayload struct {
	// The new checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The checkout queue token. Available only to selected stores.
	QueueToken *string `json:"queueToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerAssociateV2` mutation.
type CheckoutCustomerAssociateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The associated customer object.
	Customer *Customer `json:"customer,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutCustomerDisassociateV2` mutation.
type CheckoutCustomerDisassociateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutDiscountCodeApplyV2` mutation.
type CheckoutDiscountCodeApplyV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutDiscountCodeRemove` mutation.
type CheckoutDiscountCodeRemovePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutEmailUpdateV2` mutation.
type CheckoutEmailUpdateV2Payload struct {
	// The checkout object with the updated email.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardRemoveV2` mutation.
type CheckoutGiftCardRemoveV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutGiftCardsAppend` mutation.
type CheckoutGiftCardsAppendPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A single line item in the checkout, grouped by variant and attributes.
type CheckoutLineItem struct {
	// Extra information in the form of an array of Key-Value pairs about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the checkout line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The quantity of the line item.
	Quantity int32 `json:"quantity"`
	// Title of the line item. Defaults to the product's title.
	Title string `json:"title"`
	// Unit price of the line item.
	UnitPrice *MoneyV2 `json:"unitPrice,omitempty"`
	// Product variant of the line item.
	Variant *ProductVariant `json:"variant,omitempty"`
}

func (CheckoutLineItem) IsNode() {}

// A globally-unique ID.
func (this CheckoutLineItem) GetID() string { return this.ID }

// An auto-generated type for paginating through multiple CheckoutLineItems.
type CheckoutLineItemConnection struct {
	// A list of edges.
	Edges []*CheckoutLineItemEdge `json:"edges"`
	// A list of the nodes contained in CheckoutLineItemEdge.
	Nodes []*CheckoutLineItem `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one CheckoutLineItem and a cursor during pagination.
type CheckoutLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CheckoutLineItemEdge.
	Node *CheckoutLineItem `json:"node"`
}

// The input fields to create a line item on a checkout.
type CheckoutLineItemInput struct {
	// Extra information in the form of an array of Key-Value pairs about the line item.
	//
	// The input must not contain more than `250` values.
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The quantity of the line item.
	Quantity int32 `json:"quantity"`
	// The ID of the product variant for the line item.
	VariantID string `json:"variantId"`
}

// The input fields to update a line item on the checkout.
type CheckoutLineItemUpdateInput struct {
	// Extra information in the form of an array of Key-Value pairs about the line item.
	//
	// The input must not contain more than `250` values.
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The ID of the line item.
	ID *string `json:"id,omitempty"`
	// The quantity of the line item.
	Quantity *int32 `json:"quantity,omitempty"`
	// The variant ID of the line item.
	VariantID *string `json:"variantId,omitempty"`
}

// Return type for `checkoutLineItemsAdd` mutation.
type CheckoutLineItemsAddPayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsRemove` mutation.
type CheckoutLineItemsRemovePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsReplace` mutation.
type CheckoutLineItemsReplacePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*CheckoutUserError `json:"userErrors"`
}

// Return type for `checkoutLineItemsUpdate` mutation.
type CheckoutLineItemsUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutShippingAddressUpdateV2` mutation.
type CheckoutShippingAddressUpdateV2Payload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `checkoutShippingLineUpdate` mutation.
type CheckoutShippingLineUpdatePayload struct {
	// The updated checkout object.
	Checkout *Checkout `json:"checkout,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CheckoutUserErrors []*CheckoutUserError `json:"checkoutUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents an error that happens during execution of a checkout mutation.
type CheckoutUserError struct {
	// The error code.
	Code *CheckoutErrorCode `json:"code,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (CheckoutUserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this CheckoutUserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this CheckoutUserError) GetMessage() string { return this.Message }

// A collection represents a grouping of products that a shop owner can create to
// organize them or make their shops easier to browse.
type Collection struct {
	// Stripped description of the collection, single line with HTML tags removed.
	Description string `json:"description"`
	// The description of the collection, complete with HTML formatting.
	DescriptionHTML string `json:"descriptionHtml"`
	// A human-friendly unique string for the collection automatically generated from its title.
	// Limit of 255 characters.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// Image associated with the collection.
	Image *Image `json:"image,omitempty"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// List of products in the collection.
	Products *ProductConnection `json:"products"`
	// The collection's SEO information.
	Seo *Seo `json:"seo"`
	// The collection’s name. Limit of 255 characters.
	Title string `json:"title"`
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	TrackingParameters *string `json:"trackingParameters,omitempty"`
	// The date and time when the collection was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (Collection) IsMenuItemResource() {}

func (Collection) IsMetafieldParentResource() {}

func (Collection) IsMetafieldReference() {}

func (Collection) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Collection) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Collection) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Collection) IsNode() {}

// A globally-unique ID.
func (this Collection) GetID() string { return this.ID }

func (Collection) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Collection) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

func (Collection) IsTrackable() {}

// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
func (this Collection) GetTrackingParameters() *string { return this.TrackingParameters }

// An auto-generated type for paginating through multiple Collections.
type CollectionConnection struct {
	// A list of edges.
	Edges []*CollectionEdge `json:"edges"`
	// A list of the nodes contained in CollectionEdge.
	Nodes []*Collection `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total count of Collections.
	TotalCount string `json:"totalCount"`
}

// An auto-generated type which holds one Collection and a cursor during pagination.
type CollectionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CollectionEdge.
	Node *Collection `json:"node"`
}

// A comment on an article.
type Comment struct {
	// The comment’s author.
	Author *CommentAuthor `json:"author"`
	// Stripped content of the comment, single line with HTML tags removed.
	Content string `json:"content"`
	// The content of the comment, complete with HTML formatting.
	ContentHTML string `json:"contentHtml"`
	// A globally-unique ID.
	ID string `json:"id"`
}

func (Comment) IsNode() {}

// A globally-unique ID.
func (this Comment) GetID() string { return this.ID }

// The author of a comment.
type CommentAuthor struct {
	// The author's email.
	Email string `json:"email"`
	// The author’s name.
	Name string `json:"name"`
}

// An auto-generated type for paginating through multiple Comments.
type CommentConnection struct {
	// A list of edges.
	Edges []*CommentEdge `json:"edges"`
	// A list of the nodes contained in CommentEdge.
	Nodes []*Comment `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Comment and a cursor during pagination.
type CommentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CommentEdge.
	Node *Comment `json:"node"`
}

// Represents information about a company which is also a customer of the shop.
type Company struct {
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company was created in Shopify.
	CreatedAt string `json:"createdAt"`
	// A unique externally-supplied ID for the company.
	ExternalID *string `json:"externalId,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The name of the company.
	Name string `json:"name"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (Company) IsMetafieldParentResource() {}

func (Company) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Company) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Company) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Company) IsNode() {}

// A globally-unique ID.
func (this Company) GetID() string { return this.ID }

// A company's main point of contact.
type CompanyContact struct {
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company contact was created in Shopify.
	CreatedAt string `json:"createdAt"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The company contact's locale (language).
	Locale *string `json:"locale,omitempty"`
	// The company contact's job title.
	Title *string `json:"title,omitempty"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company contact was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (CompanyContact) IsNode() {}

// A globally-unique ID.
func (this CompanyContact) GetID() string { return this.ID }

// A company's location.
type CompanyLocation struct {
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company location was created in Shopify.
	CreatedAt string `json:"createdAt"`
	// A unique externally-supplied ID for the company.
	ExternalID *string `json:"externalId,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The preferred locale of the company location.
	Locale *string `json:"locale,omitempty"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The name of the company location.
	Name string `json:"name"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) at which the company location was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (CompanyLocation) IsMetafieldParentResource() {}

func (CompanyLocation) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this CompanyLocation) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this CompanyLocation) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (CompanyLocation) IsNode() {}

// A globally-unique ID.
func (this CompanyLocation) GetID() string { return this.ID }

// The action for the 3DS payment redirect.
type CompletePaymentChallenge struct {
	// The URL for the 3DS payment redirect.
	RedirectURL *string `json:"redirectUrl,omitempty"`
}

func (CompletePaymentChallenge) IsCartCompletionAction() {}

// An error that occurred during a cart completion attempt.
type CompletionError struct {
	// The error code.
	Code CompletionErrorCode `json:"code"`
	// The error message.
	Message *string `json:"message,omitempty"`
}

// Represents information about the grouped merchandise in the cart.
type ComponentizableCartLine struct {
	// An attribute associated with the cart line.
	Attribute *Attribute `json:"attribute,omitempty"`
	// The attributes associated with the cart line. Attributes are represented as key-value pairs.
	Attributes []*Attribute `json:"attributes"`
	// The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout.
	Cost *CartLineCost `json:"cost"`
	// The discounts that have been applied to the cart line.
	DiscountAllocations []CartDiscountAllocation `json:"discountAllocations"`
	// The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
	EstimatedCost *CartLineEstimatedCost `json:"estimatedCost"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The components of the line item.
	LineComponents []*CartLine `json:"lineComponents"`
	// The merchandise that the buyer intends to purchase.
	Merchandise Merchandise `json:"merchandise"`
	// The quantity of the merchandise that the customer intends to purchase.
	Quantity int32 `json:"quantity"`
	// The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased.
	SellingPlanAllocation *SellingPlanAllocation `json:"sellingPlanAllocation,omitempty"`
}

func (ComponentizableCartLine) IsBaseCartLine() {}

// An attribute associated with the cart line.
func (this ComponentizableCartLine) GetAttribute() *Attribute { return this.Attribute }

// The attributes associated with the cart line. Attributes are represented as key-value pairs.
func (this ComponentizableCartLine) GetAttributes() []*Attribute {
	if this.Attributes == nil {
		return nil
	}
	interfaceSlice := make([]*Attribute, 0, len(this.Attributes))
	for _, concrete := range this.Attributes {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout.
func (this ComponentizableCartLine) GetCost() *CartLineCost { return this.Cost }

// The discounts that have been applied to the cart line.
func (this ComponentizableCartLine) GetDiscountAllocations() []CartDiscountAllocation {
	if this.DiscountAllocations == nil {
		return nil
	}
	interfaceSlice := make([]CartDiscountAllocation, 0, len(this.DiscountAllocations))
	for _, concrete := range this.DiscountAllocations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout.
func (this ComponentizableCartLine) GetEstimatedCost() *CartLineEstimatedCost {
	return this.EstimatedCost
}

// A globally-unique ID.
func (this ComponentizableCartLine) GetID() string { return this.ID }

// The merchandise that the buyer intends to purchase.
func (this ComponentizableCartLine) GetMerchandise() Merchandise { return this.Merchandise }

// The quantity of the merchandise that the customer intends to purchase.
func (this ComponentizableCartLine) GetQuantity() int32 { return this.Quantity }

// The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased.
func (this ComponentizableCartLine) GetSellingPlanAllocation() *SellingPlanAllocation {
	return this.SellingPlanAllocation
}

func (ComponentizableCartLine) IsNode() {}

// A globally-unique ID.

// Details for count of elements.
type Count struct {
	// Count of elements.
	Count int32 `json:"count"`
	// Precision of count, how exact is the value.
	Precision CountPrecision `json:"precision"`
}

// A country.
type Country struct {
	// The languages available for the country.
	AvailableLanguages []*Language `json:"availableLanguages"`
	// The currency of the country.
	Currency *Currency `json:"currency"`
	// The default language for the country.
	DefaultLanguage *Language `json:"defaultLanguage"`
	// The ISO code of the country.
	IsoCode CountryCode `json:"isoCode"`
	// The market that includes this country.
	Market *Market `json:"market,omitempty"`
	// The name of the country.
	Name string `json:"name"`
	// The unit system used in the country.
	UnitSystem UnitSystem `json:"unitSystem"`
}

// Credit card information used for a payment.
type CreditCard struct {
	// The brand of the credit card.
	Brand *string `json:"brand,omitempty"`
	// The expiry month of the credit card.
	ExpiryMonth *int32 `json:"expiryMonth,omitempty"`
	// The expiry year of the credit card.
	ExpiryYear *int32 `json:"expiryYear,omitempty"`
	// The credit card's BIN number.
	FirstDigits *string `json:"firstDigits,omitempty"`
	// The first name of the card holder.
	FirstName *string `json:"firstName,omitempty"`
	// The last 4 digits of the credit card.
	LastDigits *string `json:"lastDigits,omitempty"`
	// The last name of the card holder.
	LastName *string `json:"lastName,omitempty"`
	// The masked credit card number with only the last 4 digits displayed.
	MaskedNumber *string `json:"maskedNumber,omitempty"`
}

// Specifies the fields required to complete a checkout with
// a Shopify vaulted credit card payment.
type CreditCardPaymentInputV2 struct {
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests).
	IdempotencyKey string `json:"idempotencyKey"`
	// The amount and currency of the payment.
	PaymentAmount *MoneyInput `json:"paymentAmount"`
	// Executes the payment in test mode if possible. Defaults to `false`.
	Test *bool `json:"test,omitempty"`
	// The ID returned by Shopify's Card Vault.
	VaultID string `json:"vaultId"`
}

// A currency.
type Currency struct {
	// The ISO code of the currency.
	IsoCode CurrencyCode `json:"isoCode"`
	// The name of the currency.
	Name string `json:"name"`
	// The symbol of the currency.
	Symbol string `json:"symbol"`
}

// A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout.
type Customer struct {
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing bool `json:"acceptsMarketing"`
	// A list of addresses for the customer.
	Addresses *MailingAddressConnection `json:"addresses"`
	// The date and time when the customer was created.
	CreatedAt string `json:"createdAt"`
	// The customer’s default address.
	DefaultAddress *MailingAddress `json:"defaultAddress,omitempty"`
	// The customer’s name, email or phone number.
	DisplayName string `json:"displayName"`
	// The customer’s email address.
	Email *string `json:"email,omitempty"`
	// The customer’s first name.
	FirstName *string `json:"firstName,omitempty"`
	// A unique ID for the customer.
	ID string `json:"id"`
	// The customer's most recently updated, incomplete checkout.
	LastIncompleteCheckout *Checkout `json:"lastIncompleteCheckout,omitempty"`
	// The customer’s last name.
	LastName *string `json:"lastName,omitempty"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The number of orders that the customer has made at the store in their lifetime.
	NumberOfOrders string `json:"numberOfOrders"`
	// The orders associated with the customer.
	Orders *OrderConnection `json:"orders"`
	// The customer’s phone number.
	Phone *string `json:"phone,omitempty"`
	// A comma separated list of tags that have been added to the customer.
	// Additional access scope required: unauthenticated_read_customer_tags.
	Tags []string `json:"tags"`
	// The date and time when the customer information was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (Customer) IsMetafieldParentResource() {}

func (Customer) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Customer) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Customer) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// A CustomerAccessToken represents the unique token required to make modifications to the customer object.
type CustomerAccessToken struct {
	// The customer’s access token.
	AccessToken string `json:"accessToken"`
	// The date and time when the customer access token expires.
	ExpiresAt string `json:"expiresAt"`
}

// The input fields required to create a customer access token.
type CustomerAccessTokenCreateInput struct {
	// The email associated to the customer.
	Email string `json:"email"`
	// The login password to be used by the customer.
	Password string `json:"password"`
}

// Return type for `customerAccessTokenCreate` mutation.
type CustomerAccessTokenCreatePayload struct {
	// The newly created customer access token object.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAccessTokenCreateWithMultipass` mutation.
type CustomerAccessTokenCreateWithMultipassPayload struct {
	// An access token object associated with the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAccessTokenDelete` mutation.
type CustomerAccessTokenDeletePayload struct {
	// The destroyed access token.
	DeletedAccessToken *string `json:"deletedAccessToken,omitempty"`
	// ID of the destroyed customer access token.
	DeletedCustomerAccessTokenID *string `json:"deletedCustomerAccessTokenId,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAccessTokenRenew` mutation.
type CustomerAccessTokenRenewPayload struct {
	// The renewed customer access token object.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerActivateByUrl` mutation.
type CustomerActivateByURLPayload struct {
	// The customer that was activated.
	Customer *Customer `json:"customer,omitempty"`
	// A new customer access token for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields to activate a customer.
type CustomerActivateInput struct {
	// The activation token required to activate the customer.
	ActivationToken string `json:"activationToken"`
	// New password that will be set during activation.
	Password string `json:"password"`
}

// Return type for `customerActivate` mutation.
type CustomerActivatePayload struct {
	// The customer object.
	Customer *Customer `json:"customer,omitempty"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressCreate` mutation.
type CustomerAddressCreatePayload struct {
	// The new customer address object.
	CustomerAddress *MailingAddress `json:"customerAddress,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressDelete` mutation.
type CustomerAddressDeletePayload struct {
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// ID of the deleted customer address.
	DeletedCustomerAddressID *string `json:"deletedCustomerAddressId,omitempty"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerAddressUpdate` mutation.
type CustomerAddressUpdatePayload struct {
	// The customer’s updated mailing address.
	CustomerAddress *MailingAddress `json:"customerAddress,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields to create a new customer.
type CustomerCreateInput struct {
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing *bool `json:"acceptsMarketing,omitempty"`
	// The customer’s email.
	Email string `json:"email"`
	// The customer’s first name.
	FirstName *string `json:"firstName,omitempty"`
	// The customer’s last name.
	LastName *string `json:"lastName,omitempty"`
	// The login password used by the customer.
	Password string `json:"password"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone,omitempty"`
}

// Return type for `customerCreate` mutation.
type CustomerCreatePayload struct {
	// The created customer object.
	Customer *Customer `json:"customer,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerDefaultAddressUpdate` mutation.
type CustomerDefaultAddressUpdatePayload struct {
	// The updated customer object.
	Customer *Customer `json:"customer,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerRecover` mutation.
type CustomerRecoverPayload struct {
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerResetByUrl` mutation.
type CustomerResetByURLPayload struct {
	// The customer object which was reset.
	Customer *Customer `json:"customer,omitempty"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields to reset a customer's password.
type CustomerResetInput struct {
	// New password that will be set as part of the reset password process.
	Password string `json:"password"`
	// The reset token required to reset the customer’s password.
	ResetToken string `json:"resetToken"`
}

// Return type for `customerReset` mutation.
type CustomerResetPayload struct {
	// The customer object which was reset.
	Customer *Customer `json:"customer,omitempty"`
	// A newly created customer access token object for the customer.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields to update the Customer information.
type CustomerUpdateInput struct {
	// Indicates whether the customer has consented to be sent marketing material via email.
	AcceptsMarketing *bool `json:"acceptsMarketing,omitempty"`
	// The customer’s email.
	Email *string `json:"email,omitempty"`
	// The customer’s first name.
	FirstName *string `json:"firstName,omitempty"`
	// The customer’s last name.
	LastName *string `json:"lastName,omitempty"`
	// The login password used by the customer.
	Password *string `json:"password,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_. To remove the phone number, specify `null`.
	Phone *string `json:"phone,omitempty"`
}

// Return type for `customerUpdate` mutation.
type CustomerUpdatePayload struct {
	// The updated customer object.
	Customer *Customer `json:"customer,omitempty"`
	// The newly created customer access token. If the customer's password is updated, all previous access tokens
	// (including the one used to perform this mutation) become invalid, and a new token is generated.
	CustomerAccessToken *CustomerAccessToken `json:"customerAccessToken,omitempty"`
	// The list of errors that occurred from executing the mutation.
	CustomerUserErrors []*CustomerUserError `json:"customerUserErrors"`
	// The list of errors that occurred from executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents an error that happens during execution of a customer mutation.
type CustomerUserError struct {
	// The error code.
	Code *CustomerErrorCode `json:"code,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (CustomerUserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this CustomerUserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this CustomerUserError) GetMessage() string { return this.Message }

// The input fields for delivery address preferences.
type DeliveryAddressInput struct {
	// The ID of a customer address that is associated with the buyer that is interacting with the cart.
	CustomerAddressID *string `json:"customerAddressId,omitempty"`
	// A delivery address preference of a buyer that is interacting with the cart.
	DeliveryAddress *MailingAddressInput `json:"deliveryAddress,omitempty"`
	// Defines what kind of address validation is requested.
	DeliveryAddressValidationStrategy *DeliveryAddressValidationStrategy `json:"deliveryAddressValidationStrategy,omitempty"`
	// Whether the given delivery address is considered to be a one-time use address. One-time use addresses do not
	// get persisted to the buyer's personal addresses when checking out.
	OneTimeUse *bool `json:"oneTimeUse,omitempty"`
}

// An amount discounting the line that has been allocated by a discount.
type DiscountAllocation struct {
	// Amount of discount allocated.
	AllocatedAmount *MoneyV2 `json:"allocatedAmount"`
	// The discount this allocated amount originated from.
	DiscountApplication DiscountApplication `json:"discountApplication"`
}

// An auto-generated type for paginating through multiple DiscountApplications.
type DiscountApplicationConnection struct {
	// A list of edges.
	Edges []*DiscountApplicationEdge `json:"edges"`
	// A list of the nodes contained in DiscountApplicationEdge.
	Nodes []DiscountApplication `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one DiscountApplication and a cursor during pagination.
type DiscountApplicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountApplicationEdge.
	Node DiscountApplication `json:"node"`
}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied.
type DiscountCodeApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Specifies whether the discount code was applied successfully.
	Applicable bool `json:"applicable"`
	// The string identifying the discount code that was used at the time of application.
	Code string `json:"code"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (DiscountCodeApplication) IsDiscountApplication() {}

// The method by which the discount's value is allocated to its entitled items.
func (this DiscountCodeApplication) GetAllocationMethod() DiscountApplicationAllocationMethod {
	return this.AllocationMethod
}

// Which lines of targetType that the discount is allocated over.
func (this DiscountCodeApplication) GetTargetSelection() DiscountApplicationTargetSelection {
	return this.TargetSelection
}

// The type of line that the discount is applicable towards.
func (this DiscountCodeApplication) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The value of the discount application.
func (this DiscountCodeApplication) GetValue() PricingValue { return this.Value }

// Represents a web address.
type Domain struct {
	// The host name of the domain (eg: `example.com`).
	Host string `json:"host"`
	// Whether SSL is enabled or not.
	SslEnabled bool `json:"sslEnabled"`
	// The URL of the domain (eg: `https://example.com`).
	URL string `json:"url"`
}

// Represents a video hosted outside of Shopify.
type ExternalVideo struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt,omitempty"`
	// The embed URL of the video for the respective host.
	EmbedURL string `json:"embedUrl"`
	// The URL.
	EmbeddedURL string `json:"embeddedUrl"`
	// The host of the external video.
	Host MediaHost `json:"host"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// The origin URL of the video on the respective host.
	OriginURL string `json:"originUrl"`
	// The presentation for a media.
	Presentation *MediaPresentation `json:"presentation,omitempty"`
	// The preview image for the media.
	PreviewImage *Image `json:"previewImage,omitempty"`
}

func (ExternalVideo) IsMedia() {}

// A word or phrase to share the nature or contents of a media.
func (this ExternalVideo) GetAlt() *string { return this.Alt }

// A globally-unique ID.
func (this ExternalVideo) GetID() string { return this.ID }

// The media content type.
func (this ExternalVideo) GetMediaContentType() MediaContentType { return this.MediaContentType }

// The presentation for a media.
func (this ExternalVideo) GetPresentation() *MediaPresentation { return this.Presentation }

// The preview image for the media.
func (this ExternalVideo) GetPreviewImage() *Image { return this.PreviewImage }

func (ExternalVideo) IsNode() {}

// A globally-unique ID.

// A filter that is supported on the parent field.
type Filter struct {
	// A unique identifier.
	ID string `json:"id"`
	// A human-friendly string for this filter.
	Label string `json:"label"`
	// Describes how to present the filter values.
	// Returns a value only for filters of type `LIST`. Returns null for other types.
	Presentation *FilterPresentation `json:"presentation,omitempty"`
	// An enumeration that denotes the type of data this filter represents.
	Type FilterType `json:"type"`
	// The list of values for this filter.
	Values []*FilterValue `json:"values"`
}

// A selectable value within a filter.
type FilterValue struct {
	// The number of results that match this filter value.
	Count int32 `json:"count"`
	// A unique identifier.
	ID string `json:"id"`
	// The visual representation when the filter's presentation is `IMAGE`.
	Image *MediaImage `json:"image,omitempty"`
	// An input object that can be used to filter by this value on the parent field.
	//
	// The value is provided as a helper for building dynamic filtering UI. For
	// example, if you have a list of selected `FilterValue` objects, you can combine
	// their respective `input` values to use in a subsequent query.
	Input string `json:"input"`
	// A human-friendly string for this filter value.
	Label string `json:"label"`
	// The visual representation when the filter's presentation is `SWATCH`.
	Swatch *Swatch `json:"swatch,omitempty"`
}

// Represents a single fulfillment in an order.
type Fulfillment struct {
	// List of the fulfillment's line items.
	FulfillmentLineItems *FulfillmentLineItemConnection `json:"fulfillmentLineItems"`
	// The name of the tracking company.
	TrackingCompany *string `json:"trackingCompany,omitempty"`
	// Tracking information associated with the fulfillment,
	// such as the tracking number and tracking URL.
	TrackingInfo []*FulfillmentTrackingInfo `json:"trackingInfo"`
}

// Represents a single line item in a fulfillment. There is at most one fulfillment line item for each order line item.
type FulfillmentLineItem struct {
	// The associated order's line item.
	LineItem *OrderLineItem `json:"lineItem"`
	// The amount fulfilled in this fulfillment.
	Quantity int32 `json:"quantity"`
}

// An auto-generated type for paginating through multiple FulfillmentLineItems.
type FulfillmentLineItemConnection struct {
	// A list of edges.
	Edges []*FulfillmentLineItemEdge `json:"edges"`
	// A list of the nodes contained in FulfillmentLineItemEdge.
	Nodes []*FulfillmentLineItem `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one FulfillmentLineItem and a cursor during pagination.
type FulfillmentLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentLineItemEdge.
	Node *FulfillmentLineItem `json:"node"`
}

// Tracking information associated with the fulfillment.
type FulfillmentTrackingInfo struct {
	// The tracking number of the fulfillment.
	Number *string `json:"number,omitempty"`
	// The URL to track the fulfillment.
	URL *string `json:"url,omitempty"`
}

// The generic file resource lets you manage files in a merchant’s store. Generic files include any file that doesn’t fit into a designated type such as image or video. Example: PDF, JSON.
type GenericFile struct {
	// A word or phrase to indicate the contents of a file.
	Alt *string `json:"alt,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The MIME type of the file.
	MimeType *string `json:"mimeType,omitempty"`
	// The size of the original file in bytes.
	OriginalFileSize *int32 `json:"originalFileSize,omitempty"`
	// The preview image for the file.
	PreviewImage *Image `json:"previewImage,omitempty"`
	// The URL of the file.
	URL *string `json:"url,omitempty"`
}

func (GenericFile) IsMetafieldReference() {}

func (GenericFile) IsNode() {}

// A globally-unique ID.
func (this GenericFile) GetID() string { return this.ID }

// The input fields used to specify a geographical location.
type GeoCoordinateInput struct {
	// The coordinate's latitude value.
	Latitude float64 `json:"latitude"`
	// The coordinate's longitude value.
	Longitude float64 `json:"longitude"`
}

// The input fields to identify a metafield on an owner resource by namespace and key.
type HasMetafieldsIdentifier struct {
	// The identifier for the metafield.
	Key string `json:"key"`
	// The container the metafield belongs to. If omitted, the app-reserved namespace will be used.
	Namespace *string `json:"namespace,omitempty"`
}

// Represents an image resource.
type Image struct {
	// A word or phrase to share the nature or contents of an image.
	AltText *string `json:"altText,omitempty"`
	// The original height of the image in pixels. Returns `null` if the image isn't hosted by Shopify.
	Height *int32 `json:"height,omitempty"`
	// A unique ID for the image.
	ID *string `json:"id,omitempty"`
	// The location of the original image as a URL.
	//
	// If there are any existing transformations in the original source URL, they will remain and not be stripped.
	OriginalSrc string `json:"originalSrc"`
	// The location of the image as a URL.
	Src string `json:"src"`
	// The ThumbHash of the image.
	//
	// Useful to display placeholder images while the original image is loading.
	//
	// See https://evanw.github.io/thumbhash/ for details on how to use it.
	Thumbhash *string `json:"thumbhash,omitempty"`
	// The location of the transformed image as a URL.
	//
	// All transformation arguments are considered "best-effort". If they can be applied to an image, they will be.
	// Otherwise any transformations which an image type doesn't support will be ignored.
	TransformedSrc string `json:"transformedSrc"`
	// The location of the image as a URL.
	//
	// If no transform options are specified, then the original image will be preserved including any pre-applied transforms.
	//
	// All transformation options are considered "best-effort". Any transformation that the original image type doesn't support will be ignored.
	//
	// If you need multiple variations of the same image, then you can use [GraphQL aliases](https://graphql.org/learn/queries/#aliases).
	URL string `json:"url"`
	// The original width of the image in pixels. Returns `null` if the image isn't hosted by Shopify.
	Width *int32 `json:"width,omitempty"`
}

// An auto-generated type for paginating through multiple Images.
type ImageConnection struct {
	// A list of edges.
	Edges []*ImageEdge `json:"edges"`
	// A list of the nodes contained in ImageEdge.
	Nodes []*Image `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Image and a cursor during pagination.
type ImageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ImageEdge.
	Node *Image `json:"node"`
}

// The available options for transforming an image.
//
// All transformation options are considered best effort. Any transformation that
// the original image type doesn't support will be ignored.
type ImageTransformInput struct {
	// The region of the image to remain after cropping.
	// Must be used in conjunction with the `maxWidth` and/or `maxHeight` fields,
	// where the `maxWidth` and `maxHeight` aren't equal.
	// The `crop` argument should coincide with the smaller value. A smaller `maxWidth` indicates a `LEFT` or `RIGHT` crop, while
	// a smaller `maxHeight` indicates a `TOP` or `BOTTOM` crop. For example, `{
	// maxWidth: 5, maxHeight: 10, crop: LEFT }` will result
	// in an image with a width of 5 and height of 10, where the right side of the image is removed.
	Crop *CropRegion `json:"crop,omitempty"`
	// Image height in pixels between 1 and 5760.
	MaxHeight *int32 `json:"maxHeight,omitempty"`
	// Image width in pixels between 1 and 5760.
	MaxWidth *int32 `json:"maxWidth,omitempty"`
	// Convert the source image into the preferred content type.
	// Supported conversions: `.svg` to `.png`, any file type to `.jpg`, and any file type to `.webp`.
	PreferredContentType *ImageContentType `json:"preferredContentType,omitempty"`
	// Image size multiplier for high-resolution retina displays. Must be within 1..3.
	Scale *int32 `json:"scale,omitempty"`
}

// Provide details about the contexts influenced by the @inContext directive on a field.
type InContextAnnotation struct {
	Description string                   `json:"description"`
	Type        *InContextAnnotationType `json:"type"`
}

// This gives information about the type of context that impacts a field. For example, for a query with @inContext(language: "EN"), the type would point to the name: LanguageCode and kind: ENUM.
type InContextAnnotationType struct {
	Kind string `json:"kind"`
	Name string `json:"name"`
}

// A language.
type Language struct {
	// The name of the language in the language itself. If the language uses capitalization, it is capitalized for a mid-sentence position.
	EndonymName string `json:"endonymName"`
	// The ISO code.
	IsoCode LanguageCode `json:"isoCode"`
	// The name of the language in the current language.
	Name string `json:"name"`
}

// Information about the localized experiences configured for the shop.
type Localization struct {
	// The list of countries with enabled localized experiences.
	AvailableCountries []*Country `json:"availableCountries"`
	// The list of languages available for the active country.
	AvailableLanguages []*Language `json:"availableLanguages"`
	// The country of the active localized experience. Use the `@inContext` directive to change this value.
	Country *Country `json:"country"`
	// The language of the active localized experience. Use the `@inContext` directive to change this value.
	Language *Language `json:"language"`
	// The market including the country of the active localized experience. Use the `@inContext` directive to change this value.
	Market *Market `json:"market"`
}

// Represents a location where product inventory is held.
type Location struct {
	// The address of the location.
	Address *LocationAddress `json:"address"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The name of the location.
	Name string `json:"name"`
}

func (Location) IsMetafieldParentResource() {}

func (Location) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Location) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Location) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Location) IsNode() {}

// A globally-unique ID.
func (this Location) GetID() string { return this.ID }

// Represents the address of a location.
type LocationAddress struct {
	// The first line of the address for the location.
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address for the location.
	Address2 *string `json:"address2,omitempty"`
	// The city of the location.
	City *string `json:"city,omitempty"`
	// The country of the location.
	Country *string `json:"country,omitempty"`
	// The country code of the location.
	CountryCode *string `json:"countryCode,omitempty"`
	// A formatted version of the address for the location.
	Formatted []string `json:"formatted"`
	// The latitude coordinates of the location.
	Latitude *float64 `json:"latitude,omitempty"`
	// The longitude coordinates of the location.
	Longitude *float64 `json:"longitude,omitempty"`
	// The phone number of the location.
	Phone *string `json:"phone,omitempty"`
	// The province of the location.
	Province *string `json:"province,omitempty"`
	// The code for the province, state, or district of the address of the location.
	ProvinceCode *string `json:"provinceCode,omitempty"`
	// The ZIP code of the location.
	Zip *string `json:"zip,omitempty"`
}

// An auto-generated type for paginating through multiple Locations.
type LocationConnection struct {
	// A list of edges.
	Edges []*LocationEdge `json:"edges"`
	// A list of the nodes contained in LocationEdge.
	Nodes []*Location `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Location and a cursor during pagination.
type LocationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of LocationEdge.
	Node *Location `json:"node"`
}

// Represents a mailing address for customers and shipping.
type MailingAddress struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2,omitempty"`
	// The name of the city, district, village, or town.
	City *string `json:"city,omitempty"`
	// The name of the customer's company or organization.
	Company *string `json:"company,omitempty"`
	// The name of the country.
	Country *string `json:"country,omitempty"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	CountryCode *string `json:"countryCode,omitempty"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	CountryCodeV2 *CountryCode `json:"countryCodeV2,omitempty"`
	// The first name of the customer.
	FirstName *string `json:"firstName,omitempty"`
	// A formatted version of the address, customized by the provided arguments.
	Formatted []string `json:"formatted"`
	// A comma-separated list of the values for city, province, and country.
	FormattedArea *string `json:"formattedArea,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The last name of the customer.
	LastName *string `json:"lastName,omitempty"`
	// The latitude coordinate of the customer address.
	Latitude *float64 `json:"latitude,omitempty"`
	// The longitude coordinate of the customer address.
	Longitude *float64 `json:"longitude,omitempty"`
	// The full name of the customer, based on firstName and lastName.
	Name *string `json:"name,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone,omitempty"`
	// The region of the address, such as the province, state, or district.
	Province *string `json:"province,omitempty"`
	// The alphanumeric code for the region.
	//
	// For example, ON.
	ProvinceCode *string `json:"provinceCode,omitempty"`
	// The zip or postal code of the address.
	Zip *string `json:"zip,omitempty"`
}

func (MailingAddress) IsDeliveryAddress() {}

func (MailingAddress) IsNode() {}

// A globally-unique ID.
func (this MailingAddress) GetID() string { return this.ID }

// An auto-generated type for paginating through multiple MailingAddresses.
type MailingAddressConnection struct {
	// A list of edges.
	Edges []*MailingAddressEdge `json:"edges"`
	// A list of the nodes contained in MailingAddressEdge.
	Nodes []*MailingAddress `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one MailingAddress and a cursor during pagination.
type MailingAddressEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MailingAddressEdge.
	Node *MailingAddress `json:"node"`
}

// The input fields to create or update a mailing address.
type MailingAddressInput struct {
	// The first line of the address. Typically the street address or PO Box number.
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	Address2 *string `json:"address2,omitempty"`
	// The name of the city, district, village, or town.
	City *string `json:"city,omitempty"`
	// The name of the customer's company or organization.
	Company *string `json:"company,omitempty"`
	// The name of the country.
	Country *string `json:"country,omitempty"`
	// The first name of the customer.
	FirstName *string `json:"firstName,omitempty"`
	// The last name of the customer.
	LastName *string `json:"lastName,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	Phone *string `json:"phone,omitempty"`
	// The region of the address, such as the province, state, or district.
	Province *string `json:"province,omitempty"`
	// The zip or postal code of the address.
	Zip *string `json:"zip,omitempty"`
}

// Manual discount applications capture the intentions of a discount that was manually created.
type ManualDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The description of the application.
	Description *string `json:"description,omitempty"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ManualDiscountApplication) IsDiscountApplication() {}

// The method by which the discount's value is allocated to its entitled items.
func (this ManualDiscountApplication) GetAllocationMethod() DiscountApplicationAllocationMethod {
	return this.AllocationMethod
}

// Which lines of targetType that the discount is allocated over.
func (this ManualDiscountApplication) GetTargetSelection() DiscountApplicationTargetSelection {
	return this.TargetSelection
}

// The type of line that the discount is applicable towards.
func (this ManualDiscountApplication) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The value of the discount application.
func (this ManualDiscountApplication) GetValue() PricingValue { return this.Value }

// A group of one or more regions of the world that a merchant is targeting for sales. To learn more about markets, refer to [the Shopify Markets conceptual overview](/docs/apps/markets).
type Market struct {
	// A human-readable unique string for the market automatically generated from its title.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
}

func (Market) IsMetafieldParentResource() {}

func (Market) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Market) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Market) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Market) IsNode() {}

// A globally-unique ID.
func (this Market) GetID() string { return this.ID }

// An auto-generated type for paginating through multiple Media.
type MediaConnection struct {
	// A list of edges.
	Edges []*MediaEdge `json:"edges"`
	// A list of the nodes contained in MediaEdge.
	Nodes []Media `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Media and a cursor during pagination.
type MediaEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MediaEdge.
	Node Media `json:"node"`
}

// Represents a Shopify hosted image.
type MediaImage struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The image for the media.
	Image *Image `json:"image,omitempty"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// The presentation for a media.
	Presentation *MediaPresentation `json:"presentation,omitempty"`
	// The preview image for the media.
	PreviewImage *Image `json:"previewImage,omitempty"`
}

func (MediaImage) IsMetafieldReference() {}

func (MediaImage) IsMedia() {}

// A word or phrase to share the nature or contents of a media.
func (this MediaImage) GetAlt() *string { return this.Alt }

// A globally-unique ID.
func (this MediaImage) GetID() string { return this.ID }

// The media content type.
func (this MediaImage) GetMediaContentType() MediaContentType { return this.MediaContentType }

// The presentation for a media.
func (this MediaImage) GetPresentation() *MediaPresentation { return this.Presentation }

// The preview image for the media.
func (this MediaImage) GetPreviewImage() *Image { return this.PreviewImage }

func (MediaImage) IsNode() {}

// A globally-unique ID.

// A media presentation.
type MediaPresentation struct {
	// A JSON object representing a presentation view.
	AsJSON *string `json:"asJson,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
}

func (MediaPresentation) IsNode() {}

// A globally-unique ID.
func (this MediaPresentation) GetID() string { return this.ID }

// A [navigation menu](https://help.shopify.com/manual/online-store/menus-and-links) representing a hierarchy
// of hyperlinks (items).
type Menu struct {
	// The menu's handle.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The menu's child items.
	Items []*MenuItem `json:"items"`
	// The count of items on the menu.
	ItemsCount int32 `json:"itemsCount"`
	// The menu's title.
	Title string `json:"title"`
}

func (Menu) IsNode() {}

// A globally-unique ID.
func (this Menu) GetID() string { return this.ID }

// A menu item within a parent menu.
type MenuItem struct {
	// A globally-unique ID.
	ID string `json:"id"`
	// The menu item's child items.
	Items []*MenuItem `json:"items"`
	// The linked resource.
	Resource MenuItemResource `json:"resource,omitempty"`
	// The ID of the linked resource.
	ResourceID *string `json:"resourceId,omitempty"`
	// The menu item's tags to filter a collection.
	Tags []string `json:"tags"`
	// The menu item's title.
	Title string `json:"title"`
	// The menu item's type.
	Type MenuItemType `json:"type"`
	// The menu item's URL.
	URL *string `json:"url,omitempty"`
}

func (MenuItem) IsNode() {}

// A globally-unique ID.
func (this MenuItem) GetID() string { return this.ID }

// Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
// comprised of keys, values, and value types.
type Metafield struct {
	// The date and time when the storefront metafield was created.
	CreatedAt string `json:"createdAt"`
	// The description of a metafield.
	Description *string `json:"description,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The unique identifier for the metafield within its namespace.
	Key string `json:"key"`
	// The container for a group of metafields that the metafield is associated with.
	Namespace string `json:"namespace"`
	// The type of resource that the metafield is attached to.
	ParentResource MetafieldParentResource `json:"parentResource"`
	// Returns a reference object if the metafield's type is a resource reference.
	Reference MetafieldReference `json:"reference,omitempty"`
	// A list of reference objects if the metafield's type is a resource reference list.
	References *MetafieldReferenceConnection `json:"references,omitempty"`
	// The type name of the metafield.
	// Refer to the list of [supported types](https://shopify.dev/apps/metafields/definitions/types).
	Type string `json:"type"`
	// The date and time when the metafield was last updated.
	UpdatedAt string `json:"updatedAt"`
	// The data stored in the metafield. Always stored as a string, regardless of the metafield's type.
	Value string `json:"value"`
}

func (Metafield) IsNode() {}

// A globally-unique ID.
func (this Metafield) GetID() string { return this.ID }

// An error that occurs during the execution of cart metafield deletion.
type MetafieldDeleteUserError struct {
	// The error code.
	Code *MetafieldDeleteErrorCode `json:"code,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (MetafieldDeleteUserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this MetafieldDeleteUserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this MetafieldDeleteUserError) GetMessage() string { return this.Message }

// A filter used to view a subset of products in a collection matching a specific metafield value.
//
// Only the following metafield types are currently supported:
// - `number_integer`
// - `number_decimal`
// - `single_line_text_field`
// - `boolean` as of 2022-04.
type MetafieldFilter struct {
	// The key of the metafield to filter on.
	Key string `json:"key"`
	// The namespace of the metafield to filter on.
	Namespace string `json:"namespace"`
	// The value of the metafield.
	Value string `json:"value"`
}

// An auto-generated type for paginating through multiple MetafieldReferences.
type MetafieldReferenceConnection struct {
	// A list of edges.
	Edges []*MetafieldReferenceEdge `json:"edges"`
	// A list of the nodes contained in MetafieldReferenceEdge.
	Nodes []MetafieldReference `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one MetafieldReference and a cursor during pagination.
type MetafieldReferenceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MetafieldReferenceEdge.
	Node MetafieldReference `json:"node"`
}

// An error that occurs during the execution of `MetafieldsSet`.
type MetafieldsSetUserError struct {
	// The error code.
	Code *MetafieldsSetUserErrorCode `json:"code,omitempty"`
	// The index of the array element that's causing the error.
	ElementIndex *int32 `json:"elementIndex,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (MetafieldsSetUserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this MetafieldsSetUserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this MetafieldsSetUserError) GetMessage() string { return this.Message }

// An instance of a user-defined model based on a MetaobjectDefinition.
type Metaobject struct {
	// Accesses a field of the object by key.
	Field *MetaobjectField `json:"field,omitempty"`
	// All object fields with defined values.
	// Omitted object keys can be assumed null, and no guarantees are made about field order.
	Fields []*MetaobjectField `json:"fields"`
	// The unique handle of the metaobject. Useful as a custom ID.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The URL used for viewing the metaobject on the shop's Online Store. Returns `null` if the metaobject definition doesn't have the `online_store` capability.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// The metaobject's SEO information. Returns `null` if the metaobject definition
	// doesn't have the `renderable` capability.
	Seo *MetaobjectSeo `json:"seo,omitempty"`
	// The type of the metaobject. Defines the namespace of its associated metafields.
	Type string `json:"type"`
	// The date and time when the metaobject was last updated.
	UpdatedAt string `json:"updatedAt"`
}

func (Metaobject) IsMenuItemResource() {}

func (Metaobject) IsMetafieldReference() {}

func (Metaobject) IsNode() {}

// A globally-unique ID.
func (this Metaobject) GetID() string { return this.ID }

func (Metaobject) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Metaobject) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

// An auto-generated type for paginating through multiple Metaobjects.
type MetaobjectConnection struct {
	// A list of edges.
	Edges []*MetaobjectEdge `json:"edges"`
	// A list of the nodes contained in MetaobjectEdge.
	Nodes []*Metaobject `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Metaobject and a cursor during pagination.
type MetaobjectEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MetaobjectEdge.
	Node *Metaobject `json:"node"`
}

// Provides the value of a Metaobject field.
type MetaobjectField struct {
	// The field key.
	Key string `json:"key"`
	// A referenced object if the field type is a resource reference.
	Reference MetafieldReference `json:"reference,omitempty"`
	// A list of referenced objects if the field type is a resource reference list.
	References *MetafieldReferenceConnection `json:"references,omitempty"`
	// The type name of the field.
	// See the list of [supported types](https://shopify.dev/apps/metafields/definitions/types).
	Type string `json:"type"`
	// The field value.
	Value *string `json:"value,omitempty"`
}

// The input fields used to retrieve a metaobject by handle.
type MetaobjectHandleInput struct {
	// The handle of the metaobject.
	Handle string `json:"handle"`
	// The type of the metaobject.
	Type string `json:"type"`
}

// SEO information for a metaobject.
type MetaobjectSeo struct {
	// The meta description.
	Description *MetaobjectField `json:"description,omitempty"`
	// The SEO title.
	Title *MetaobjectField `json:"title,omitempty"`
}

// Represents a Shopify hosted 3D model.
type Model3d struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// The presentation for a media.
	Presentation *MediaPresentation `json:"presentation,omitempty"`
	// The preview image for the media.
	PreviewImage *Image `json:"previewImage,omitempty"`
	// The sources for a 3d model.
	Sources []*Model3dSource `json:"sources"`
}

func (Model3d) IsMetafieldReference() {}

func (Model3d) IsMedia() {}

// A word or phrase to share the nature or contents of a media.
func (this Model3d) GetAlt() *string { return this.Alt }

// A globally-unique ID.
func (this Model3d) GetID() string { return this.ID }

// The media content type.
func (this Model3d) GetMediaContentType() MediaContentType { return this.MediaContentType }

// The presentation for a media.
func (this Model3d) GetPresentation() *MediaPresentation { return this.Presentation }

// The preview image for the media.
func (this Model3d) GetPreviewImage() *Image { return this.PreviewImage }

func (Model3d) IsNode() {}

// A globally-unique ID.

// Represents a source for a Shopify hosted 3d model.
type Model3dSource struct {
	// The filesize of the 3d model.
	Filesize int32 `json:"filesize"`
	// The format of the 3d model.
	Format string `json:"format"`
	// The MIME type of the 3d model.
	MimeType string `json:"mimeType"`
	// The URL of the 3d model.
	URL string `json:"url"`
}

// The input fields for a monetary value with currency.
type MoneyInput struct {
	// Decimal money amount.
	Amount string `json:"amount"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode"`
}

// A monetary value with currency.
type MoneyV2 struct {
	// Decimal money amount.
	Amount string `json:"amount"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode"`
}

func (MoneyV2) IsPricingValue() {}

func (MoneyV2) IsSellingPlanCheckoutChargeValue() {}

// The schema’s entry-point for mutations. This acts as the public, top-level API from which all mutation queries must start.
type Mutation struct {
}

// An order is a customer’s completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information.
type Order struct {
	// The address associated with the payment method.
	BillingAddress *MailingAddress `json:"billingAddress,omitempty"`
	// The reason for the order's cancellation. Returns `null` if the order wasn't canceled.
	CancelReason *OrderCancelReason `json:"cancelReason,omitempty"`
	// The date and time when the order was canceled. Returns null if the order wasn't canceled.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The code of the currency used for the payment.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// The subtotal of line items and their discounts, excluding line items that have been removed. Does not contain order-level discounts, duties, shipping costs, or shipping discounts. Taxes aren't included unless the order is a taxes-included order.
	CurrentSubtotalPrice *MoneyV2 `json:"currentSubtotalPrice"`
	// The total cost of duties for the order, including refunds.
	CurrentTotalDuties *MoneyV2 `json:"currentTotalDuties,omitempty"`
	// The total amount of the order, including duties, taxes and discounts, minus amounts for line items that have been removed.
	CurrentTotalPrice *MoneyV2 `json:"currentTotalPrice"`
	// The total cost of shipping, excluding shipping lines that have been refunded or removed. Taxes aren't included unless the order is a taxes-included order.
	CurrentTotalShippingPrice *MoneyV2 `json:"currentTotalShippingPrice"`
	// The total of all taxes applied to the order, excluding taxes for returned line items.
	CurrentTotalTax *MoneyV2 `json:"currentTotalTax"`
	// A list of the custom attributes added to the order. For example, whether an order is a customer's first.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The locale code in which this specific order happened.
	CustomerLocale *string `json:"customerLocale,omitempty"`
	// The unique URL that the customer can use to access the order.
	CustomerURL *string `json:"customerUrl,omitempty"`
	// Discounts that have been applied on the order.
	DiscountApplications *DiscountApplicationConnection `json:"discountApplications"`
	// Whether the order has had any edits applied or not.
	Edited bool `json:"edited"`
	// The customer's email address.
	Email *string `json:"email,omitempty"`
	// The financial status of the order.
	FinancialStatus *OrderFinancialStatus `json:"financialStatus,omitempty"`
	// The fulfillment status for the order.
	FulfillmentStatus OrderFulfillmentStatus `json:"fulfillmentStatus"`
	// A globally-unique ID.
	ID string `json:"id"`
	// List of the order’s line items.
	LineItems *OrderLineItemConnection `json:"lineItems"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// Unique identifier for the order that appears on the order.
	// For example, _#1000_ or _Store1001.
	Name string `json:"name"`
	// A unique numeric identifier for the order for use by shop owner and customer.
	OrderNumber int32 `json:"orderNumber"`
	// The total cost of duties charged at checkout.
	OriginalTotalDuties *MoneyV2 `json:"originalTotalDuties,omitempty"`
	// The total price of the order before any applied edits.
	OriginalTotalPrice *MoneyV2 `json:"originalTotalPrice"`
	// The customer's phone number for receiving SMS notifications.
	Phone *string `json:"phone,omitempty"`
	// The date and time when the order was imported.
	// This value can be set to dates in the past when importing from other systems.
	// If no value is provided, it will be auto-generated based on current date and time.
	ProcessedAt string `json:"processedAt"`
	// The address to where the order will be shipped.
	ShippingAddress *MailingAddress `json:"shippingAddress,omitempty"`
	// The discounts that have been allocated onto the shipping line by discount applications.
	ShippingDiscountAllocations []*DiscountAllocation `json:"shippingDiscountAllocations"`
	// The unique URL for the order's status page.
	StatusURL string `json:"statusUrl"`
	// Price of the order before shipping and taxes.
	SubtotalPrice *MoneyV2 `json:"subtotalPrice,omitempty"`
	// Price of the order before duties, shipping and taxes.
	SubtotalPriceV2 *MoneyV2 `json:"subtotalPriceV2,omitempty"`
	// List of the order’s successful fulfillments.
	SuccessfulFulfillments []*Fulfillment `json:"successfulFulfillments,omitempty"`
	// The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive).
	TotalPrice *MoneyV2 `json:"totalPrice"`
	// The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive).
	TotalPriceV2 *MoneyV2 `json:"totalPriceV2"`
	// The total amount that has been refunded.
	TotalRefunded *MoneyV2 `json:"totalRefunded"`
	// The total amount that has been refunded.
	TotalRefundedV2 *MoneyV2 `json:"totalRefundedV2"`
	// The total cost of shipping.
	TotalShippingPrice *MoneyV2 `json:"totalShippingPrice"`
	// The total cost of shipping.
	TotalShippingPriceV2 *MoneyV2 `json:"totalShippingPriceV2"`
	// The total cost of taxes.
	TotalTax *MoneyV2 `json:"totalTax,omitempty"`
	// The total cost of taxes.
	TotalTaxV2 *MoneyV2 `json:"totalTaxV2,omitempty"`
}

func (Order) IsMetafieldParentResource() {}

func (Order) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Order) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Order) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Order) IsNode() {}

// A globally-unique ID.
func (this Order) GetID() string { return this.ID }

// An auto-generated type for paginating through multiple Orders.
type OrderConnection struct {
	// A list of edges.
	Edges []*OrderEdge `json:"edges"`
	// A list of the nodes contained in OrderEdge.
	Nodes []*Order `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total count of Orders.
	TotalCount string `json:"totalCount"`
}

// An auto-generated type which holds one Order and a cursor during pagination.
type OrderEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderEdge.
	Node *Order `json:"node"`
}

// Represents a single line in an order. There is one line item for each distinct product variant.
type OrderLineItem struct {
	// The number of entries associated to the line item minus the items that have been removed.
	CurrentQuantity int32 `json:"currentQuantity"`
	// List of custom attributes associated to the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the order line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The total price of the line item, including discounts, and displayed in the presentment currency.
	DiscountedTotalPrice *MoneyV2 `json:"discountedTotalPrice"`
	// The total price of the line item, not including any discounts. The total price is calculated using the original unit price multiplied by the quantity, and it's displayed in the presentment currency.
	OriginalTotalPrice *MoneyV2 `json:"originalTotalPrice"`
	// The number of products variants associated to the line item.
	Quantity int32 `json:"quantity"`
	// The title of the product combined with title of the variant.
	Title string `json:"title"`
	// The product variant object associated to the line item.
	Variant *ProductVariant `json:"variant,omitempty"`
}

// An auto-generated type for paginating through multiple OrderLineItems.
type OrderLineItemConnection struct {
	// A list of edges.
	Edges []*OrderLineItemEdge `json:"edges"`
	// A list of the nodes contained in OrderLineItemEdge.
	Nodes []*OrderLineItem `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one OrderLineItem and a cursor during pagination.
type OrderLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderLineItemEdge.
	Node *OrderLineItem `json:"node"`
}

// Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store.
type Page struct {
	// The description of the page, complete with HTML formatting.
	Body string `json:"body"`
	// Summary of the page body.
	BodySummary string `json:"bodySummary"`
	// The timestamp of the page creation.
	CreatedAt string `json:"createdAt"`
	// A human-friendly unique string for the page automatically generated from its title.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// The page's SEO information.
	Seo *Seo `json:"seo,omitempty"`
	// The title of the page.
	Title string `json:"title"`
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	TrackingParameters *string `json:"trackingParameters,omitempty"`
	// The timestamp of the latest page update.
	UpdatedAt string `json:"updatedAt"`
}

func (Page) IsMenuItemResource() {}

func (Page) IsMetafieldParentResource() {}

func (Page) IsMetafieldReference() {}

func (Page) IsSearchResultItem() {}

func (Page) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Page) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Page) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Page) IsNode() {}

// A globally-unique ID.
func (this Page) GetID() string { return this.ID }

func (Page) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Page) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

func (Page) IsTrackable() {}

// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
func (this Page) GetTrackingParameters() *string { return this.TrackingParameters }

// An auto-generated type for paginating through multiple Pages.
type PageConnection struct {
	// A list of edges.
	Edges []*PageEdge `json:"edges"`
	// A list of the nodes contained in PageEdge.
	Nodes []*Page `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Page and a cursor during pagination.
type PageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PageEdge.
	Node *Page `json:"node"`
}

// Returns information about pagination in a connection, in accordance with the
// [Relay specification](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo).
// For more information, please read our [GraphQL Pagination Usage Guide](https://shopify.dev/api/usage/pagination-graphql).
type PageInfo struct {
	// The cursor corresponding to the last node in edges.
	EndCursor *string `json:"endCursor,omitempty"`
	// Whether there are more pages to fetch following the current page.
	HasNextPage bool `json:"hasNextPage"`
	// Whether there are any pages prior to the current page.
	HasPreviousPage bool `json:"hasPreviousPage"`
	// The cursor corresponding to the first node in edges.
	StartCursor *string `json:"startCursor,omitempty"`
}

// Type for paginating through multiple sitemap's resources.
type PaginatedSitemapResources struct {
	// Whether there are more pages to fetch following the current page.
	HasNextPage bool `json:"hasNextPage"`
	// List of sitemap resources for the current page.
	// Note: The number of items varies between 0 and 250 per page.
	Items []SitemapResourceInterface `json:"items"`
}

// A payment applied to a checkout.
type Payment struct {
	// The amount of the payment.
	Amount *MoneyV2 `json:"amount"`
	// The amount of the payment.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// The billing address for the payment.
	BillingAddress *MailingAddress `json:"billingAddress,omitempty"`
	// The checkout to which the payment belongs.
	Checkout *Checkout `json:"checkout"`
	// The credit card used for the payment in the case of direct payments.
	CreditCard *CreditCard `json:"creditCard,omitempty"`
	// A message describing a processing error during asynchronous processing.
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A client-side generated token to identify a payment and perform idempotent operations.
	// For more information, refer to
	// [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests).
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`
	// The URL where the customer needs to be redirected so they can complete the 3D Secure payment flow.
	NextActionURL *string `json:"nextActionUrl,omitempty"`
	// Whether the payment is still processing asynchronously.
	Ready bool `json:"ready"`
	// A flag to indicate if the payment is to be done in test mode for gateways that support it.
	Test bool `json:"test"`
	// The actual transaction recorded by Shopify after having processed the payment with the gateway.
	Transaction *Transaction `json:"transaction,omitempty"`
}

func (Payment) IsNode() {}

// A globally-unique ID.
func (this Payment) GetID() string { return this.ID }

// Settings related to payments.
type PaymentSettings struct {
	// List of the card brands which the business entity accepts.
	AcceptedCardBrands []CardBrand `json:"acceptedCardBrands"`
	// The url pointing to the endpoint to vault credit cards.
	CardVaultURL string `json:"cardVaultUrl"`
	// The country where the shop is located. When multiple business entities operate within the shop, then this will represent the country of the business entity that's serving the specified buyer context.
	CountryCode CountryCode `json:"countryCode"`
	// The three-letter code for the shop's primary currency.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// A list of enabled currencies (ISO 4217 format) that the shop accepts.
	// Merchants can enable currencies from their Shopify Payments settings in the Shopify admin.
	EnabledPresentmentCurrencies []CurrencyCode `json:"enabledPresentmentCurrencies"`
	// The shop’s Shopify Payments account ID.
	ShopifyPaymentsAccountID *string `json:"shopifyPaymentsAccountId,omitempty"`
	// List of the digital wallets which the business entity supports.
	SupportedDigitalWallets []DigitalWallet `json:"supportedDigitalWallets"`
}

// A predictive search result represents a list of products, collections, pages, articles, and query suggestions
// that matches the predictive search query.
type PredictiveSearchResult struct {
	// The articles that match the search query.
	Articles []*Article `json:"articles"`
	// The articles that match the search query.
	Collections []*Collection `json:"collections"`
	// The pages that match the search query.
	Pages []*Page `json:"pages"`
	// The products that match the search query.
	Products []*Product `json:"products"`
	// The query suggestions that are relevant to the search query.
	Queries []*SearchQuerySuggestion `json:"queries"`
}

// The input fields for a filter used to view a subset of products in a collection matching a specific price range.
type PriceRangeFilter struct {
	// The maximum price in the range. Empty indicates no max price.
	Max *float64 `json:"max,omitempty"`
	// The minimum price in the range. Defaults to zero.
	Min *float64 `json:"min,omitempty"`
}

// The value of the percentage pricing object.
type PricingPercentageValue struct {
	// The percentage value of the object.
	Percentage float64 `json:"percentage"`
}

func (PricingPercentageValue) IsPricingValue() {}

// The `Product` object lets you manage products in a merchant’s store.
//
// Products are the goods and services that merchants offer to customers.
// They can include various details such as title, description, price, images, and options such as size or color.
// You can use [product variants](/docs/api/storefront/latest/objects/ProductVariant)
// to create or update different versions of the same product.
// You can also add or update product [media](/docs/api/storefront/latest/interfaces/Media).
// Products can be organized by grouping them into a [collection](/docs/api/storefront/latest/objects/Collection).
//
// Learn more about working with [products and collections](/docs/storefronts/headless/building-with-the-storefront-api/products-collections).
type Product struct {
	// A list of variants whose selected options differ with the provided selected options by one, ordered by variant id.
	// If selected options are not provided, adjacent variants to the first available variant is returned.
	//
	// Note that this field returns an array of variants. In most cases, the number of variants in this array will be low.
	// However, with a low number of options and a high number of values per option, the number of variants returned
	// here can be high. In such cases, it recommended to avoid using this field.
	//
	// This list of variants can be used in combination with the `options` field to build a rich variant picker that
	// includes variant availability or other variant information.
	AdjacentVariants []*ProductVariant `json:"adjacentVariants"`
	// Indicates if at least one product variant is available for sale.
	AvailableForSale bool `json:"availableForSale"`
	// The category of a product from [Shopify's Standard Product Taxonomy](https://shopify.github.io/product-taxonomy/releases/unstable/?categoryId=sg-4-17-2-17).
	Category *TaxonomyCategory `json:"category,omitempty"`
	// A list of [collections](/docs/api/storefront/latest/objects/Collection) that include the product.
	Collections *CollectionConnection `json:"collections"`
	// The [compare-at price range](https://help.shopify.com/manual/products/details/product-pricing/sale-pricing) of the product in the shop's default currency.
	CompareAtPriceRange *ProductPriceRange `json:"compareAtPriceRange"`
	// The date and time when the product was created.
	CreatedAt string `json:"createdAt"`
	// A single-line description of the product, with [HTML tags](https://developer.mozilla.org/en-US/docs/Web/HTML) removed.
	Description string `json:"description"`
	// The description of the product, with
	// HTML tags. For example, the description might include
	// bold `<strong></strong>` and italic `<i></i>` text.
	DescriptionHTML string `json:"descriptionHtml"`
	// An encoded string containing all option value combinations
	// with a corresponding variant that is currently available for sale.
	//
	// Integers represent option and values:
	// [0,1] represents option_value at array index 0 for the option at array index 0
	//
	// `:`, `,`, ` ` and `-` are control characters.
	// `:` indicates a new option. ex: 0:1 indicates value 0 for the option in position 1, value 1 for the option in position 2.
	// `,` indicates the end of a repeated prefix, mulitple consecutive commas indicate the end of multiple repeated prefixes.
	// ` ` indicates a gap in the sequence of option values. ex: 0 4 indicates option values in position 0 and 4 are present.
	// `-` indicates a continuous range of option values. ex: 0 1-3 4
	//
	// Decoding process:
	//
	// Example options: [Size, Color, Material]
	// Example values: [[Small, Medium, Large], [Red, Blue], [Cotton, Wool]]
	// Example encoded string: "0:0:0,1:0-1,,1:0:0-1,1:1,,2:0:1,1:0,,"
	//
	// Step 1: Expand ranges into the numbers they represent: "0:0:0,1:0 1,,1:0:0 1,1:1,,2:0:1,1:0,,"
	// Step 2: Expand repeated prefixes: "0:0:0,0:1:0 1,1:0:0 1,1:1:1,2:0:1,2:1:0,"
	// Step 3: Expand shared prefixes so data is encoded as a string: "0:0:0,0:1:0,0:1:1,1:0:0,1:0:1,1:1:1,2:0:1,2:1:0,"
	// Step 4: Map to options + option values to determine existing variants:
	//
	// [Small, Red, Cotton] (0:0:0), [Small, Blue, Cotton] (0:1:0), [Small, Blue, Wool] (0:1:1),
	// [Medium, Red, Cotton] (1:0:0), [Medium, Red, Wool] (1:0:1), [Medium, Blue, Wool] (1:1:1),
	// [Large, Red, Wool] (2:0:1), [Large, Blue, Cotton] (2:1:0).
	EncodedVariantAvailability *string `json:"encodedVariantAvailability,omitempty"`
	// An encoded string containing all option value combinations with a corresponding variant.
	//
	// Integers represent option and values:
	// [0,1] represents option_value at array index 0 for the option at array index 0
	//
	// `:`, `,`, ` ` and `-` are control characters.
	// `:` indicates a new option. ex: 0:1 indicates value 0 for the option in position 1, value 1 for the option in position 2.
	// `,` indicates the end of a repeated prefix, mulitple consecutive commas indicate the end of multiple repeated prefixes.
	// ` ` indicates a gap in the sequence of option values. ex: 0 4 indicates option values in position 0 and 4 are present.
	// `-` indicates a continuous range of option values. ex: 0 1-3 4
	//
	// Decoding process:
	//
	// Example options: [Size, Color, Material]
	// Example values: [[Small, Medium, Large], [Red, Blue], [Cotton, Wool]]
	// Example encoded string: "0:0:0,1:0-1,,1:0:0-1,1:1,,2:0:1,1:0,,"
	//
	// Step 1: Expand ranges into the numbers they represent: "0:0:0,1:0 1,,1:0:0 1,1:1,,2:0:1,1:0,,"
	// Step 2: Expand repeated prefixes: "0:0:0,0:1:0 1,1:0:0 1,1:1:1,2:0:1,2:1:0,"
	// Step 3: Expand shared prefixes so data is encoded as a string: "0:0:0,0:1:0,0:1:1,1:0:0,1:0:1,1:1:1,2:0:1,2:1:0,"
	// Step 4: Map to options + option values to determine existing variants:
	//
	// [Small, Red, Cotton] (0:0:0), [Small, Blue, Cotton] (0:1:0), [Small, Blue, Wool] (0:1:1),
	// [Medium, Red, Cotton] (1:0:0), [Medium, Red, Wool] (1:0:1), [Medium, Blue, Wool] (1:1:1),
	// [Large, Red, Wool] (2:0:1), [Large, Blue, Cotton] (2:1:0).
	EncodedVariantExistence *string `json:"encodedVariantExistence,omitempty"`
	// The featured image for the product.
	//
	// This field is functionally equivalent to `images(first: 1)`.
	FeaturedImage *Image `json:"featuredImage,omitempty"`
	// A unique, human-readable string of the product's title.
	// A handle can contain letters, hyphens (`-`), and numbers, but no spaces.
	// The handle is used in the online store URL for the product.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// List of images associated with the product.
	Images *ImageConnection `json:"images"`
	// Whether the product is a gift card.
	IsGiftCard bool `json:"isGiftCard"`
	// The [media](/docs/apps/build/online-store/product-media) that are associated with the product. Valid media are images, 3D models, videos.
	Media *MediaConnection `json:"media"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The product's URL on the online store.
	// If `null`, then the product isn't published to the online store sales channel.
	OnlineStoreURL *string `json:"onlineStoreUrl,omitempty"`
	// A list of product options. The limit is defined by the [shop's resource limits for product options](/docs/api/admin-graphql/latest/objects/Shop#field-resourcelimits) (`Shop.resourceLimits.maxProductOptions`).
	Options []*ProductOption `json:"options"`
	// The minimum and maximum prices of a product, expressed in decimal numbers.
	// For example, if the product is priced between $10.00 and $50.00,
	// then the price range is $10.00 - $50.00.
	PriceRange *ProductPriceRange `json:"priceRange"`
	// The [product type](https://help.shopify.com/manual/products/details/product-type)
	// that merchants define.
	ProductType string `json:"productType"`
	// The date and time when the product was published to the channel.
	PublishedAt string `json:"publishedAt"`
	// Whether the product can only be purchased with a [selling plan](/docs/apps/build/purchase-options/subscriptions/selling-plans). Products that are sold on subscription (`requiresSellingPlan: true`) can be updated only for online stores. If you update a product to be subscription-only (`requiresSellingPlan:false`), then the product is unpublished from all channels, except the online store.
	RequiresSellingPlan bool `json:"requiresSellingPlan"`
	// Find an active product variant based on selected options, availability or the first variant.
	//
	// All arguments are optional. If no selected options are provided, the first available variant is returned.
	// If no variants are available, the first variant is returned.
	SelectedOrFirstAvailableVariant *ProductVariant `json:"selectedOrFirstAvailableVariant,omitempty"`
	// A list of all [selling plan groups](/docs/apps/build/purchase-options/subscriptions/selling-plans/build-a-selling-plan) that are associated with the product either directly, or through the product's variants.
	SellingPlanGroups *SellingPlanGroupConnection `json:"sellingPlanGroups"`
	// The [SEO title and description](https://help.shopify.com/manual/promoting-marketing/seo/adding-keywords)
	// that are associated with a product.
	Seo *Seo `json:"seo"`
	// A comma-separated list of searchable keywords that are
	// associated with the product. For example, a merchant might apply the `sports`
	// and `summer` tags to products that are associated with sportwear for summer.
	// Updating `tags` overwrites any existing tags that were previously added to the product.
	// To add new tags without overwriting existing tags,
	// use the GraphQL Admin API's [`tagsAdd`](/docs/api/admin-graphql/latest/mutations/tagsadd)
	// mutation.
	Tags []string `json:"tags"`
	// The name for the product that displays to customers. The title is used to construct the product's handle.
	// For example, if a product is titled "Black Sunglasses", then the handle is `black-sunglasses`.
	Title string `json:"title"`
	// The quantity of inventory that's in stock.
	TotalInventory *int32 `json:"totalInventory,omitempty"`
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	TrackingParameters *string `json:"trackingParameters,omitempty"`
	// The date and time when the product was last modified.
	// A product's `updatedAt` value can change for different reasons. For example, if an order
	// is placed for a product that has inventory tracking set up, then the inventory adjustment
	// is counted as an update.
	UpdatedAt string `json:"updatedAt"`
	// Find a product’s variant based on its selected options.
	// This is useful for converting a user’s selection of product options into a single matching variant.
	// If there is not a variant for the selected options, `null` will be returned.
	VariantBySelectedOptions *ProductVariant `json:"variantBySelectedOptions,omitempty"`
	// A list of [variants](/docs/api/storefront/latest/objects/ProductVariant) that are associated with the product.
	Variants *ProductVariantConnection `json:"variants"`
	// The number of [variants](/docs/api/storefront/latest/objects/ProductVariant) that are associated with the product.
	VariantsCount *Count `json:"variantsCount,omitempty"`
	// The name of the product's vendor.
	Vendor string `json:"vendor"`
}

func (Product) IsMenuItemResource() {}

func (Product) IsMetafieldParentResource() {}

func (Product) IsMetafieldReference() {}

func (Product) IsSearchResultItem() {}

func (Product) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Product) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Product) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Product) IsNode() {}

// A globally-unique ID.
func (this Product) GetID() string { return this.ID }

func (Product) IsOnlineStorePublishable() {}

// The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel.
func (this Product) GetOnlineStoreURL() *string { return this.OnlineStoreURL }

func (Product) IsTrackable() {}

// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
func (this Product) GetTrackingParameters() *string { return this.TrackingParameters }

// An auto-generated type for paginating through multiple Products.
type ProductConnection struct {
	// A list of edges.
	Edges []*ProductEdge `json:"edges"`
	// A list of available filters.
	Filters []*Filter `json:"filters"`
	// A list of the nodes contained in ProductEdge.
	Nodes []*Product `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one Product and a cursor during pagination.
type ProductEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductEdge.
	Node *Product `json:"node"`
}

// The input fields for a filter used to view a subset of products in a collection.
// By default, the `available` and `price` filters are enabled. Filters are customized with the Shopify Search & Discovery app.
// Learn more about [customizing storefront filtering](https://help.shopify.com/manual/online-store/themes/customizing-themes/storefront-filters).
type ProductFilter struct {
	// Filter on if the product is available for sale.
	Available *bool `json:"available,omitempty"`
	// A product category to filter on.
	Category *CategoryFilter `json:"category,omitempty"`
	// A range of prices to filter with-in.
	Price *PriceRangeFilter `json:"price,omitempty"`
	// A product metafield to filter on.
	ProductMetafield *MetafieldFilter `json:"productMetafield,omitempty"`
	// The product type to filter on.
	ProductType *string `json:"productType,omitempty"`
	// The product vendor to filter on.
	ProductVendor *string `json:"productVendor,omitempty"`
	// A product tag to filter on.
	Tag *string `json:"tag,omitempty"`
	// A standard product attribute metafield to filter on.
	TaxonomyMetafield *TaxonomyMetafieldFilter `json:"taxonomyMetafield,omitempty"`
	// A variant metafield to filter on.
	VariantMetafield *MetafieldFilter `json:"variantMetafield,omitempty"`
	// A variant option to filter on.
	VariantOption *VariantOptionFilter `json:"variantOption,omitempty"`
}

// Product property names like "Size", "Color", and "Material" that the customers can select.
// Variants are selected based on permutations of these options.
// 255 characters limit each.
type ProductOption struct {
	// A globally-unique ID.
	ID string `json:"id"`
	// The product option’s name.
	Name string `json:"name"`
	// The corresponding option value to the product option.
	OptionValues []*ProductOptionValue `json:"optionValues"`
	// The corresponding value to the product option name.
	Values []string `json:"values"`
}

func (ProductOption) IsNode() {}

// A globally-unique ID.
func (this ProductOption) GetID() string { return this.ID }

// The product option value names. For example, "Red", "Blue", and "Green" for a "Color" option.
type ProductOptionValue struct {
	// The product variant that combines this option value with the
	// lowest-position option values for all other options.
	//
	// This field will always return a variant, provided a variant including this option value exists.
	FirstSelectableVariant *ProductVariant `json:"firstSelectableVariant,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The name of the product option value.
	Name string `json:"name"`
	// The swatch of the product option value.
	Swatch *ProductOptionValueSwatch `json:"swatch,omitempty"`
}

func (ProductOptionValue) IsNode() {}

// A globally-unique ID.
func (this ProductOptionValue) GetID() string { return this.ID }

// The product option value swatch.
type ProductOptionValueSwatch struct {
	// The swatch color.
	Color *string `json:"color,omitempty"`
	// The swatch image.
	Image Media `json:"image,omitempty"`
}

// The price range of the product.
type ProductPriceRange struct {
	// The highest variant's price.
	MaxVariantPrice *MoneyV2 `json:"maxVariantPrice"`
	// The lowest variant's price.
	MinVariantPrice *MoneyV2 `json:"minVariantPrice"`
}

// A product variant represents a different version of a product, such as differing sizes or differing colors.
type ProductVariant struct {
	// Indicates if the product variant is available for sale.
	AvailableForSale bool `json:"availableForSale"`
	// The barcode (for example, ISBN, UPC, or GTIN) associated with the variant.
	Barcode *string `json:"barcode,omitempty"`
	// The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPrice` is higher than `price`.
	CompareAtPrice *MoneyV2 `json:"compareAtPrice,omitempty"`
	// The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPriceV2` is higher than `priceV2`.
	CompareAtPriceV2 *MoneyV2 `json:"compareAtPriceV2,omitempty"`
	// List of bundles components included in the variant considering only fixed bundles.
	Components *ProductVariantComponentConnection `json:"components"`
	// Whether a product is out of stock but still available for purchase (used for backorders).
	CurrentlyNotInStock bool `json:"currentlyNotInStock"`
	// List of bundles that include this variant considering only fixed bundles.
	GroupedBy *ProductVariantConnection `json:"groupedBy"`
	// A globally-unique ID.
	ID string `json:"id"`
	// Image associated with the product variant. This field falls back to the product image if no image is available.
	Image *Image `json:"image,omitempty"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The product variant’s price.
	Price *MoneyV2 `json:"price"`
	// The product variant’s price.
	PriceV2 *MoneyV2 `json:"priceV2"`
	// The product object that the product variant belongs to.
	Product *Product `json:"product"`
	// The total sellable quantity of the variant for online sales channels.
	QuantityAvailable *int32 `json:"quantityAvailable,omitempty"`
	// A list of quantity breaks for the product variant.
	QuantityPriceBreaks *QuantityPriceBreakConnection `json:"quantityPriceBreaks"`
	// The quantity rule for the product variant in a given context.
	QuantityRule *QuantityRule `json:"quantityRule"`
	// Whether a product variant requires components. The default value is `false`.
	// If `true`, then the product variant can only be purchased as a parent bundle with components.
	RequiresComponents bool `json:"requiresComponents"`
	// Whether a customer needs to provide a shipping address when placing an order for the product variant.
	RequiresShipping bool `json:"requiresShipping"`
	// List of product options applied to the variant.
	SelectedOptions []*SelectedOption `json:"selectedOptions"`
	// Represents an association between a variant and a selling plan. Selling plan allocations describe which selling plans are available for each variant, and what their impact is on pricing.
	SellingPlanAllocations *SellingPlanAllocationConnection `json:"sellingPlanAllocations"`
	// The Shop Pay Installments pricing information for the product variant.
	ShopPayInstallmentsPricing *ShopPayInstallmentsProductVariantPricing `json:"shopPayInstallmentsPricing,omitempty"`
	// The SKU (stock keeping unit) associated with the variant.
	Sku *string `json:"sku,omitempty"`
	// The in-store pickup availability of this variant by location.
	StoreAvailability *StoreAvailabilityConnection `json:"storeAvailability"`
	// Whether tax is charged when the product variant is sold.
	Taxable bool `json:"taxable"`
	// The product variant’s title.
	Title string `json:"title"`
	// The unit price value for the variant based on the variant's measurement.
	UnitPrice *MoneyV2 `json:"unitPrice,omitempty"`
	// The unit price measurement for the variant.
	UnitPriceMeasurement *UnitPriceMeasurement `json:"unitPriceMeasurement,omitempty"`
	// The weight of the product variant in the unit system specified with `weight_unit`.
	Weight *float64 `json:"weight,omitempty"`
	// Unit of measurement for weight.
	WeightUnit WeightUnit `json:"weightUnit"`
}

func (ProductVariant) IsMerchandise() {}

func (ProductVariant) IsMetafieldParentResource() {}

func (ProductVariant) IsMetafieldReference() {}

func (ProductVariant) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this ProductVariant) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this ProductVariant) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (ProductVariant) IsNode() {}

// A globally-unique ID.
func (this ProductVariant) GetID() string { return this.ID }

// Represents a component of a bundle variant.
type ProductVariantComponent struct {
	// The product variant object that the component belongs to.
	ProductVariant *ProductVariant `json:"productVariant"`
	// The quantity of component present in the bundle.
	Quantity int32 `json:"quantity"`
}

// An auto-generated type for paginating through multiple ProductVariantComponents.
type ProductVariantComponentConnection struct {
	// A list of edges.
	Edges []*ProductVariantComponentEdge `json:"edges"`
	// A list of the nodes contained in ProductVariantComponentEdge.
	Nodes []*ProductVariantComponent `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one ProductVariantComponent and a cursor during pagination.
type ProductVariantComponentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantComponentEdge.
	Node *ProductVariantComponent `json:"node"`
}

// An auto-generated type for paginating through multiple ProductVariants.
type ProductVariantConnection struct {
	// A list of edges.
	Edges []*ProductVariantEdge `json:"edges"`
	// A list of the nodes contained in ProductVariantEdge.
	Nodes []*ProductVariant `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one ProductVariant and a cursor during pagination.
type ProductVariantEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantEdge.
	Node *ProductVariant `json:"node"`
}

// Represents information about the buyer that is interacting with the cart.
type PurchasingCompany struct {
	// The company associated to the order or draft order.
	Company *Company `json:"company"`
	// The company contact associated to the order or draft order.
	Contact *CompanyContact `json:"contact,omitempty"`
	// The company location associated to the order or draft order.
	Location *CompanyLocation `json:"location"`
}

// Quantity price breaks lets you offer different rates that are based on the
// amount of a specific variant being ordered.
type QuantityPriceBreak struct {
	// Minimum quantity required to reach new quantity break price.
	MinimumQuantity int32 `json:"minimumQuantity"`
	// The price of variant after reaching the minimum quanity.
	Price *MoneyV2 `json:"price"`
}

// An auto-generated type for paginating through multiple QuantityPriceBreaks.
type QuantityPriceBreakConnection struct {
	// A list of edges.
	Edges []*QuantityPriceBreakEdge `json:"edges"`
	// A list of the nodes contained in QuantityPriceBreakEdge.
	Nodes []*QuantityPriceBreak `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one QuantityPriceBreak and a cursor during pagination.
type QuantityPriceBreakEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of QuantityPriceBreakEdge.
	Node *QuantityPriceBreak `json:"node"`
}

// The quantity rule for the product variant in a given context.
type QuantityRule struct {
	// The value that specifies the quantity increment between minimum and maximum of the rule.
	// Only quantities divisible by this value will be considered valid.
	//
	// The increment must be lower than or equal to the minimum and the maximum, and both minimum and maximum
	// must be divisible by this value.
	Increment int32 `json:"increment"`
	// An optional value that defines the highest allowed quantity purchased by the customer.
	// If defined, maximum must be lower than or equal to the minimum and must be a multiple of the increment.
	Maximum *int32 `json:"maximum,omitempty"`
	// The value that defines the lowest allowed quantity purchased by the customer.
	// The minimum must be a multiple of the quantity rule's increment.
	Minimum int32 `json:"minimum"`
}

type Query struct {
}

// The schema’s entry-point for queries. This acts as the public, top-level API from which all queries must start.
type QueryRoot struct {
	// Fetch a specific Article by its ID.
	Article *Article `json:"article,omitempty"`
	// List of the shop's articles.
	Articles *ArticleConnection `json:"articles"`
	// Fetch a specific `Blog` by one of its unique attributes.
	Blog *Blog `json:"blog,omitempty"`
	// Find a blog by its handle.
	BlogByHandle *Blog `json:"blogByHandle,omitempty"`
	// List of the shop's blogs.
	Blogs *BlogConnection `json:"blogs"`
	// Retrieve a cart by its ID. For more information, refer to
	// [Manage a cart with the Storefront API](https://shopify.dev/custom-storefronts/cart/manage).
	Cart *Cart `json:"cart,omitempty"`
	// A poll for the status of the cart checkout completion and order creation.
	CartCompletionAttempt CartCompletionAttemptResult `json:"cartCompletionAttempt,omitempty"`
	// Fetch a specific `Collection` by one of its unique attributes.
	Collection *Collection `json:"collection,omitempty"`
	// Find a collection by its handle.
	CollectionByHandle *Collection `json:"collectionByHandle,omitempty"`
	// List of the shop’s collections.
	Collections *CollectionConnection `json:"collections"`
	// The customer associated with the given access token. Tokens are obtained by using the
	// [`customerAccessTokenCreate` mutation](https://shopify.dev/docs/api/storefront/latest/mutations/customerAccessTokenCreate).
	Customer *Customer `json:"customer,omitempty"`
	// Returns the localized experiences configured for the shop.
	Localization *Localization `json:"localization"`
	// List of the shop's locations that support in-store pickup.
	//
	// When sorting by distance, you must specify a location via the `near` argument.
	Locations *LocationConnection `json:"locations"`
	// Retrieve a [navigation menu](https://help.shopify.com/manual/online-store/menus-and-links) by its handle.
	Menu *Menu `json:"menu,omitempty"`
	// Fetch a specific Metaobject by one of its unique identifiers.
	Metaobject *Metaobject `json:"metaobject,omitempty"`
	// All active metaobjects for the shop.
	Metaobjects *MetaobjectConnection `json:"metaobjects"`
	// Returns a specific node by ID.
	Node Node `json:"node,omitempty"`
	// Returns the list of nodes with the given IDs.
	Nodes []Node `json:"nodes"`
	// Fetch a specific `Page` by one of its unique attributes.
	Page *Page `json:"page,omitempty"`
	// Find a page by its handle.
	PageByHandle *Page `json:"pageByHandle,omitempty"`
	// List of the shop's pages.
	Pages *PageConnection `json:"pages"`
	// Settings related to payments.
	PaymentSettings *PaymentSettings `json:"paymentSettings"`
	// List of the predictive search results.
	PredictiveSearch *PredictiveSearchResult `json:"predictiveSearch,omitempty"`
	// Fetch a specific `Product` by one of its unique attributes.
	Product *Product `json:"product,omitempty"`
	// Find a product by its handle.
	ProductByHandle *Product `json:"productByHandle,omitempty"`
	// Find recommended products related to a given `product_id`.
	// To learn more about how recommendations are generated, see
	// [*Showing product recommendations on product pages*](https://help.shopify.com/themes/development/recommended-products).
	ProductRecommendations []*Product `json:"productRecommendations,omitempty"`
	// Tags added to products.
	// Additional access scope required: unauthenticated_read_product_tags.
	ProductTags *StringConnection `json:"productTags"`
	// List of product types for the shop's products that are published to your app.
	ProductTypes *StringConnection `json:"productTypes"`
	// Returns a list of the shop's products. For storefront search, use the [`search`](https://shopify.dev/docs/api/storefront/latest/queries/search) query.
	Products *ProductConnection `json:"products"`
	// The list of public Storefront API versions, including supported, release candidate and unstable versions.
	PublicAPIVersions []*APIVersion `json:"publicApiVersions"`
	// List of the search results.
	Search *SearchResultItemConnection `json:"search"`
	// The shop associated with the storefront access token.
	Shop *Shop `json:"shop"`
	// Returns the shop's Shop Pay Installments pricing information.
	ShopPayInstallmentsPricing *ShopPayInstallmentsPricing `json:"shopPayInstallmentsPricing,omitempty"`
	// Contains all fields required to generate sitemaps.
	Sitemap *Sitemap `json:"sitemap"`
	// A list of redirects for a shop.
	URLRedirects *URLRedirectConnection `json:"urlRedirects"`
}

// SEO information.
type Seo struct {
	// The meta description.
	Description *string `json:"description,omitempty"`
	// The SEO title.
	Title *string `json:"title,omitempty"`
}

// Script discount applications capture the intentions of a discount that
// was created by a Shopify Script.
type ScriptDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// Which lines of targetType that the discount is allocated over.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// The type of line that the discount is applicable towards.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application as defined by the Script.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ScriptDiscountApplication) IsDiscountApplication() {}

// The method by which the discount's value is allocated to its entitled items.
func (this ScriptDiscountApplication) GetAllocationMethod() DiscountApplicationAllocationMethod {
	return this.AllocationMethod
}

// Which lines of targetType that the discount is allocated over.
func (this ScriptDiscountApplication) GetTargetSelection() DiscountApplicationTargetSelection {
	return this.TargetSelection
}

// The type of line that the discount is applicable towards.
func (this ScriptDiscountApplication) GetTargetType() DiscountApplicationTargetType {
	return this.TargetType
}

// The value of the discount application.
func (this ScriptDiscountApplication) GetValue() PricingValue { return this.Value }

// A search query suggestion.
type SearchQuerySuggestion struct {
	// The text of the search query suggestion with highlighted HTML tags.
	StyledText string `json:"styledText"`
	// The text of the search query suggestion.
	Text string `json:"text"`
	// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
	TrackingParameters *string `json:"trackingParameters,omitempty"`
}

func (SearchQuerySuggestion) IsTrackable() {}

// URL parameters to be added to a page URL to track the origin of on-site search traffic for [analytics reporting](https://help.shopify.com/manual/reports-and-analytics/shopify-reports/report-types/default-reports/behaviour-reports). Returns a result when accessed through the [search](https://shopify.dev/docs/api/storefront/current/queries/search) or [predictiveSearch](https://shopify.dev/docs/api/storefront/current/queries/predictiveSearch) queries, otherwise returns null.
func (this SearchQuerySuggestion) GetTrackingParameters() *string { return this.TrackingParameters }

// An auto-generated type for paginating through multiple SearchResultItems.
type SearchResultItemConnection struct {
	// A list of edges.
	Edges []*SearchResultItemEdge `json:"edges"`
	// A list of the nodes contained in SearchResultItemEdge.
	Nodes []SearchResultItem `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A list of available filters.
	ProductFilters []*Filter `json:"productFilters"`
	// The total number of results.
	TotalCount int32 `json:"totalCount"`
}

// An auto-generated type which holds one SearchResultItem and a cursor during pagination.
type SearchResultItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SearchResultItemEdge.
	Node SearchResultItem `json:"node"`
}

// Properties used by customers to select a product variant.
// Products can have multiple options, like different sizes or colors.
type SelectedOption struct {
	// The product option’s name.
	Name string `json:"name"`
	// The product option’s value.
	Value string `json:"value"`
}

// The input fields required for a selected option.
type SelectedOptionInput struct {
	// The product option’s name.
	Name string `json:"name"`
	// The product option’s value.
	Value string `json:"value"`
}

// Represents how products and variants can be sold and purchased.
type SellingPlan struct {
	// The billing policy for the selling plan.
	BillingPolicy SellingPlanBillingPolicy `json:"billingPolicy,omitempty"`
	// The initial payment due for the purchase.
	CheckoutCharge *SellingPlanCheckoutCharge `json:"checkoutCharge"`
	// The delivery policy for the selling plan.
	DeliveryPolicy SellingPlanDeliveryPolicy `json:"deliveryPolicy,omitempty"`
	// The description of the selling plan.
	Description *string `json:"description,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// The name of the selling plan. For example, '6 weeks of prepaid granola, delivered weekly'.
	Name string `json:"name"`
	// The selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product. Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing.
	Options []*SellingPlanOption `json:"options"`
	// The price adjustments that a selling plan makes when a variant is purchased with a selling plan.
	PriceAdjustments []*SellingPlanPriceAdjustment `json:"priceAdjustments"`
	// Whether purchasing the selling plan will result in multiple deliveries.
	RecurringDeliveries bool `json:"recurringDeliveries"`
}

func (SellingPlan) IsMetafieldParentResource() {}

func (SellingPlan) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this SellingPlan) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this SellingPlan) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// Represents an association between a variant and a selling plan. Selling plan allocations describe the options offered for each variant, and the price of the variant when purchased with a selling plan.
type SellingPlanAllocation struct {
	// The checkout charge amount due for the purchase.
	CheckoutChargeAmount *MoneyV2 `json:"checkoutChargeAmount"`
	// A list of price adjustments, with a maximum of two. When there are two, the first price adjustment goes into effect at the time of purchase, while the second one starts after a certain number of orders. A price adjustment represents how a selling plan affects pricing when a variant is purchased with a selling plan. Prices display in the customer's currency if the shop is configured for it.
	PriceAdjustments []*SellingPlanAllocationPriceAdjustment `json:"priceAdjustments"`
	// The remaining balance charge amount due for the purchase.
	RemainingBalanceChargeAmount *MoneyV2 `json:"remainingBalanceChargeAmount"`
	// A representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'.
	SellingPlan *SellingPlan `json:"sellingPlan"`
}

// An auto-generated type for paginating through multiple SellingPlanAllocations.
type SellingPlanAllocationConnection struct {
	// A list of edges.
	Edges []*SellingPlanAllocationEdge `json:"edges"`
	// A list of the nodes contained in SellingPlanAllocationEdge.
	Nodes []*SellingPlanAllocation `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one SellingPlanAllocation and a cursor during pagination.
type SellingPlanAllocationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SellingPlanAllocationEdge.
	Node *SellingPlanAllocation `json:"node"`
}

// The resulting prices for variants when they're purchased with a specific selling plan.
type SellingPlanAllocationPriceAdjustment struct {
	// The price of the variant when it's purchased without a selling plan for the same number of deliveries. For example, if a customer purchases 6 deliveries of $10.00 granola separately, then the price is 6 x $10.00 = $60.00.
	CompareAtPrice *MoneyV2 `json:"compareAtPrice"`
	// The effective price for a single delivery. For example, for a prepaid subscription plan that includes 6 deliveries at the price of $48.00, the per delivery price is $8.00.
	PerDeliveryPrice *MoneyV2 `json:"perDeliveryPrice"`
	// The price of the variant when it's purchased with a selling plan For example, for a prepaid subscription plan that includes 6 deliveries of $10.00 granola, where the customer gets 20% off, the price is 6 x $10.00 x 0.80 = $48.00.
	Price *MoneyV2 `json:"price"`
	// The resulting price per unit for the variant associated with the selling plan. If the variant isn't sold by quantity or measurement, then this field returns `null`.
	UnitPrice *MoneyV2 `json:"unitPrice,omitempty"`
}

// The initial payment due for the purchase.
type SellingPlanCheckoutCharge struct {
	// The charge type for the checkout charge.
	Type SellingPlanCheckoutChargeType `json:"type"`
	// The charge value for the checkout charge.
	Value SellingPlanCheckoutChargeValue `json:"value"`
}

// The percentage value of the price used for checkout charge.
type SellingPlanCheckoutChargePercentageValue struct {
	// The percentage value of the price used for checkout charge.
	Percentage float64 `json:"percentage"`
}

func (SellingPlanCheckoutChargePercentageValue) IsSellingPlanCheckoutChargeValue() {}

// An auto-generated type for paginating through multiple SellingPlans.
type SellingPlanConnection struct {
	// A list of edges.
	Edges []*SellingPlanEdge `json:"edges"`
	// A list of the nodes contained in SellingPlanEdge.
	Nodes []*SellingPlan `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one SellingPlan and a cursor during pagination.
type SellingPlanEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SellingPlanEdge.
	Node *SellingPlan `json:"node"`
}

// A fixed amount that's deducted from the original variant price. For example, $10.00 off.
type SellingPlanFixedAmountPriceAdjustment struct {
	// The money value of the price adjustment.
	AdjustmentAmount *MoneyV2 `json:"adjustmentAmount"`
}

func (SellingPlanFixedAmountPriceAdjustment) IsSellingPlanPriceAdjustmentValue() {}

// A fixed price adjustment for a variant that's purchased with a selling plan.
type SellingPlanFixedPriceAdjustment struct {
	// A new price of the variant when it's purchased with the selling plan.
	Price *MoneyV2 `json:"price"`
}

func (SellingPlanFixedPriceAdjustment) IsSellingPlanPriceAdjustmentValue() {}

// Represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans.
type SellingPlanGroup struct {
	// A display friendly name for the app that created the selling plan group.
	AppName *string `json:"appName,omitempty"`
	// The name of the selling plan group.
	Name string `json:"name"`
	// Represents the selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product.
	Options []*SellingPlanGroupOption `json:"options"`
	// A list of selling plans in a selling plan group. A selling plan is a representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'.
	SellingPlans *SellingPlanConnection `json:"sellingPlans"`
}

// An auto-generated type for paginating through multiple SellingPlanGroups.
type SellingPlanGroupConnection struct {
	// A list of edges.
	Edges []*SellingPlanGroupEdge `json:"edges"`
	// A list of the nodes contained in SellingPlanGroupEdge.
	Nodes []*SellingPlanGroup `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one SellingPlanGroup and a cursor during pagination.
type SellingPlanGroupEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SellingPlanGroupEdge.
	Node *SellingPlanGroup `json:"node"`
}

// Represents an option on a selling plan group that's available in the drop-down list in the storefront.
//
// Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing.
type SellingPlanGroupOption struct {
	// The name of the option. For example, 'Delivery every'.
	Name string `json:"name"`
	// The values for the options specified by the selling plans in the selling plan group. For example, '1 week', '2 weeks', '3 weeks'.
	Values []string `json:"values"`
}

// An option provided by a Selling Plan.
type SellingPlanOption struct {
	// The name of the option (ie "Delivery every").
	Name *string `json:"name,omitempty"`
	// The value of the option (ie "Month").
	Value *string `json:"value,omitempty"`
}

// A percentage amount that's deducted from the original variant price. For example, 10% off.
type SellingPlanPercentagePriceAdjustment struct {
	// The percentage value of the price adjustment.
	AdjustmentPercentage float64 `json:"adjustmentPercentage"`
}

func (SellingPlanPercentagePriceAdjustment) IsSellingPlanPriceAdjustmentValue() {}

// Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments. If a variant has multiple price adjustments, then the first price adjustment applies when the variant is initially purchased. The second price adjustment applies after a certain number of orders (specified by the `orderCount` field) are made. If a selling plan doesn't have any price adjustments, then the unadjusted price of the variant is the effective price.
type SellingPlanPriceAdjustment struct {
	// The type of price adjustment. An adjustment value can have one of three types: percentage, amount off, or a new price.
	AdjustmentValue SellingPlanPriceAdjustmentValue `json:"adjustmentValue"`
	// The number of orders that the price adjustment applies to. If the price adjustment always applies, then this field is `null`.
	OrderCount *int32 `json:"orderCount,omitempty"`
}

// The recurring billing policy for the selling plan.
type SellingPlanRecurringBillingPolicy struct {
	// The billing frequency, it can be either: day, week, month or year.
	Interval SellingPlanInterval `json:"interval"`
	// The number of intervals between billings.
	IntervalCount int32 `json:"intervalCount"`
}

func (SellingPlanRecurringBillingPolicy) IsSellingPlanBillingPolicy() {}

// The recurring delivery policy for the selling plan.
type SellingPlanRecurringDeliveryPolicy struct {
	// The delivery frequency, it can be either: day, week, month or year.
	Interval SellingPlanInterval `json:"interval"`
	// The number of intervals between deliveries.
	IntervalCount int32 `json:"intervalCount"`
}

func (SellingPlanRecurringDeliveryPolicy) IsSellingPlanDeliveryPolicy() {}

// A shipping rate to be applied to a checkout.
type ShippingRate struct {
	// Human-readable unique identifier for this shipping rate.
	Handle string `json:"handle"`
	// Price of this shipping rate.
	Price *MoneyV2 `json:"price"`
	// Price of this shipping rate.
	PriceV2 *MoneyV2 `json:"priceV2"`
	// Title of this shipping rate.
	Title string `json:"title"`
}

// Shop represents a collection of the general settings and information about the shop.
type Shop struct {
	// The shop's branding configuration.
	Brand *Brand `json:"brand,omitempty"`
	// The URL for the customer account (only present if shop has a customer account vanity domain).
	CustomerAccountURL *string `json:"customerAccountUrl,omitempty"`
	// A description of the shop.
	Description *string `json:"description,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
	Metafield *Metafield `json:"metafield,omitempty"`
	// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
	Metafields []*Metafield `json:"metafields"`
	// A string representing the way currency is formatted when the currency isn’t specified.
	MoneyFormat string `json:"moneyFormat"`
	// The shop’s name.
	Name string `json:"name"`
	// Settings related to payments.
	PaymentSettings *PaymentSettings `json:"paymentSettings"`
	// The primary domain of the shop’s Online Store.
	PrimaryDomain *Domain `json:"primaryDomain"`
	// The shop’s privacy policy.
	PrivacyPolicy *ShopPolicy `json:"privacyPolicy,omitempty"`
	// The shop’s refund policy.
	RefundPolicy *ShopPolicy `json:"refundPolicy,omitempty"`
	// The shop’s shipping policy.
	ShippingPolicy *ShopPolicy `json:"shippingPolicy,omitempty"`
	// Countries that the shop ships to.
	ShipsToCountries []CountryCode `json:"shipsToCountries"`
	// The Shop Pay Installments pricing information for the shop.
	ShopPayInstallmentsPricing *ShopPayInstallmentsPricing `json:"shopPayInstallmentsPricing,omitempty"`
	// The shop’s subscription policy.
	SubscriptionPolicy *ShopPolicyWithDefault `json:"subscriptionPolicy,omitempty"`
	// The shop’s terms of service.
	TermsOfService *ShopPolicy `json:"termsOfService,omitempty"`
}

func (Shop) IsMetafieldParentResource() {}

func (Shop) IsHasMetafields() {}

// A [custom field](https://shopify.dev/docs/apps/build/custom-data), including its `namespace` and `key`, that's associated with a Shopify resource for the purposes of adding and storing additional information.
func (this Shop) GetMetafield() *Metafield { return this.Metafield }

// A list of [custom fields](/docs/apps/build/custom-data) that a merchant associates with a Shopify resource.
func (this Shop) GetMetafields() []*Metafield {
	if this.Metafields == nil {
		return nil
	}
	interfaceSlice := make([]*Metafield, 0, len(this.Metafields))
	for _, concrete := range this.Metafields {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Shop) IsNode() {}

// A globally-unique ID.
func (this Shop) GetID() string { return this.ID }

// The financing plan in Shop Pay Installments.
type ShopPayInstallmentsFinancingPlan struct {
	// A globally-unique ID.
	ID string `json:"id"`
	// The maximum price to qualify for the financing plan.
	MaxPrice *MoneyV2 `json:"maxPrice"`
	// The minimum price to qualify for the financing plan.
	MinPrice *MoneyV2 `json:"minPrice"`
	// The terms of the financing plan.
	Terms []*ShopPayInstallmentsFinancingPlanTerm `json:"terms"`
}

func (ShopPayInstallmentsFinancingPlan) IsNode() {}

// A globally-unique ID.
func (this ShopPayInstallmentsFinancingPlan) GetID() string { return this.ID }

// The terms of the financing plan in Shop Pay Installments.
type ShopPayInstallmentsFinancingPlanTerm struct {
	// The annual percentage rate (APR) of the financing plan.
	Apr int32 `json:"apr"`
	// The payment frequency for the financing plan.
	Frequency ShopPayInstallmentsFinancingPlanFrequency `json:"frequency"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The number of installments for the financing plan.
	InstallmentsCount *Count `json:"installmentsCount,omitempty"`
	// The type of loan for the financing plan.
	LoanType ShopPayInstallmentsLoan `json:"loanType"`
}

func (ShopPayInstallmentsFinancingPlanTerm) IsNode() {}

// A globally-unique ID.
func (this ShopPayInstallmentsFinancingPlanTerm) GetID() string { return this.ID }

// The result for a Shop Pay Installments pricing request.
type ShopPayInstallmentsPricing struct {
	// The financing plans available for the given price range.
	FinancingPlans []*ShopPayInstallmentsFinancingPlan `json:"financingPlans"`
	// The maximum price to qualify for financing.
	MaxPrice *MoneyV2 `json:"maxPrice"`
	// The minimum price to qualify for financing.
	MinPrice *MoneyV2 `json:"minPrice"`
	// The pricing information for a product variant.
	ProductVariantPricing *ShopPayInstallmentsProductVariantPricing `json:"productVariantPricing,omitempty"`
}

// The shop pay installments pricing information for a product variant.
type ShopPayInstallmentsProductVariantPricing struct {
	// Whether the product variant is available.
	Available bool `json:"available"`
	// Whether the product variant is eligible for Shop Pay Installments.
	Eligible bool `json:"eligible"`
	// The full price of the product variant.
	FullPrice *MoneyV2 `json:"fullPrice"`
	// The ID of the product variant.
	ID string `json:"id"`
	// The number of payment terms available for the product variant.
	InstallmentsCount *Count `json:"installmentsCount,omitempty"`
	// The price per term for the product variant.
	PricePerTerm *MoneyV2 `json:"pricePerTerm"`
}

func (ShopPayInstallmentsProductVariantPricing) IsNode() {}

// A globally-unique ID.
func (this ShopPayInstallmentsProductVariantPricing) GetID() string { return this.ID }

// Represents a Shop Pay payment request.
type ShopPayPaymentRequest struct {
	// The delivery methods for the payment request.
	DeliveryMethods []*ShopPayPaymentRequestDeliveryMethod `json:"deliveryMethods"`
	// The discount codes for the payment request.
	DiscountCodes []string `json:"discountCodes"`
	// The discounts for the payment request order.
	Discounts []*ShopPayPaymentRequestDiscount `json:"discounts,omitempty"`
	// The line items for the payment request.
	LineItems []*ShopPayPaymentRequestLineItem `json:"lineItems"`
	// The locale for the payment request.
	Locale string `json:"locale"`
	// The presentment currency for the payment request.
	PresentmentCurrency CurrencyCode `json:"presentmentCurrency"`
	// The delivery method type for the payment request.
	SelectedDeliveryMethodType ShopPayPaymentRequestDeliveryMethodType `json:"selectedDeliveryMethodType"`
	// The shipping address for the payment request.
	ShippingAddress *ShopPayPaymentRequestContactField `json:"shippingAddress,omitempty"`
	// The shipping lines for the payment request.
	ShippingLines []*ShopPayPaymentRequestShippingLine `json:"shippingLines"`
	// The subtotal amount for the payment request.
	Subtotal *MoneyV2 `json:"subtotal"`
	// The total amount for the payment request.
	Total *MoneyV2 `json:"total"`
	// The total shipping price for the payment request.
	TotalShippingPrice *ShopPayPaymentRequestTotalShippingPrice `json:"totalShippingPrice,omitempty"`
	// The total tax for the payment request.
	TotalTax *MoneyV2 `json:"totalTax,omitempty"`
}

// Represents a contact field for a Shop Pay payment request.
type ShopPayPaymentRequestContactField struct {
	// The first address line of the contact field.
	Address1 string `json:"address1"`
	// The second address line of the contact field.
	Address2 *string `json:"address2,omitempty"`
	// The city of the contact field.
	City string `json:"city"`
	// The company name of the contact field.
	CompanyName *string `json:"companyName,omitempty"`
	// The country of the contact field.
	CountryCode string `json:"countryCode"`
	// The email of the contact field.
	Email *string `json:"email,omitempty"`
	// The first name of the contact field.
	FirstName string `json:"firstName"`
	// The first name of the contact field.
	LastName string `json:"lastName"`
	// The phone number of the contact field.
	Phone *string `json:"phone,omitempty"`
	// The postal code of the contact field.
	PostalCode *string `json:"postalCode,omitempty"`
	// The province of the contact field.
	ProvinceCode *string `json:"provinceCode,omitempty"`
}

// Represents a delivery method for a Shop Pay payment request.
type ShopPayPaymentRequestDeliveryMethod struct {
	// The amount for the delivery method.
	Amount *MoneyV2 `json:"amount"`
	// The code of the delivery method.
	Code string `json:"code"`
	// The detail about when the delivery may be expected.
	DeliveryExpectationLabel *string `json:"deliveryExpectationLabel,omitempty"`
	// The detail of the delivery method.
	Detail *string `json:"detail,omitempty"`
	// The label of the delivery method.
	Label string `json:"label"`
	// The maximum delivery date for the delivery method.
	MaxDeliveryDate *string `json:"maxDeliveryDate,omitempty"`
	// The minimum delivery date for the delivery method.
	MinDeliveryDate *string `json:"minDeliveryDate,omitempty"`
}

// The input fields to create a delivery method for a Shop Pay payment request.
type ShopPayPaymentRequestDeliveryMethodInput struct {
	// The amount for the delivery method.
	Amount *MoneyInput `json:"amount,omitempty"`
	// The code of the delivery method.
	Code *string `json:"code,omitempty"`
	// The detail about when the delivery may be expected.
	DeliveryExpectationLabel *string `json:"deliveryExpectationLabel,omitempty"`
	// The detail of the delivery method.
	Detail *string `json:"detail,omitempty"`
	// The label of the delivery method.
	Label *string `json:"label,omitempty"`
	// The maximum delivery date for the delivery method.
	MaxDeliveryDate *string `json:"maxDeliveryDate,omitempty"`
	// The minimum delivery date for the delivery method.
	MinDeliveryDate *string `json:"minDeliveryDate,omitempty"`
}

// Represents a discount for a Shop Pay payment request.
type ShopPayPaymentRequestDiscount struct {
	// The amount of the discount.
	Amount *MoneyV2 `json:"amount"`
	// The label of the discount.
	Label string `json:"label"`
}

// The input fields to create a discount for a Shop Pay payment request.
type ShopPayPaymentRequestDiscountInput struct {
	// The amount of the discount.
	Amount *MoneyInput `json:"amount,omitempty"`
	// The label of the discount.
	Label *string `json:"label,omitempty"`
}

// Represents an image for a Shop Pay payment request line item.
type ShopPayPaymentRequestImage struct {
	// The alt text of the image.
	Alt *string `json:"alt,omitempty"`
	// The source URL of the image.
	URL string `json:"url"`
}

// The input fields to create an image for a Shop Pay payment request.
type ShopPayPaymentRequestImageInput struct {
	// The alt text of the image.
	Alt *string `json:"alt,omitempty"`
	// The source URL of the image.
	URL string `json:"url"`
}

// The input fields represent a Shop Pay payment request.
type ShopPayPaymentRequestInput struct {
	// The delivery methods for the payment request.
	//
	// The input must not contain more than `250` values.
	DeliveryMethods []*ShopPayPaymentRequestDeliveryMethodInput `json:"deliveryMethods,omitempty"`
	// The discount codes for the payment request.
	//
	// The input must not contain more than `250` values.
	DiscountCodes []string `json:"discountCodes,omitempty"`
	// The discounts for the payment request order.
	//
	// The input must not contain more than `250` values.
	Discounts []*ShopPayPaymentRequestDiscountInput `json:"discounts,omitempty"`
	// The line items for the payment request.
	//
	// The input must not contain more than `250` values.
	LineItems []*ShopPayPaymentRequestLineItemInput `json:"lineItems,omitempty"`
	// The locale for the payment request.
	Locale string `json:"locale"`
	// The encrypted payment method for the payment request.
	PaymentMethod *string `json:"paymentMethod,omitempty"`
	// The presentment currency for the payment request.
	PresentmentCurrency CurrencyCode `json:"presentmentCurrency"`
	// The delivery method type for the payment request.
	SelectedDeliveryMethodType *ShopPayPaymentRequestDeliveryMethodType `json:"selectedDeliveryMethodType,omitempty"`
	// The shipping lines for the payment request.
	//
	// The input must not contain more than `250` values.
	ShippingLines []*ShopPayPaymentRequestShippingLineInput `json:"shippingLines,omitempty"`
	// The subtotal amount for the payment request.
	Subtotal *MoneyInput `json:"subtotal"`
	// The total amount for the payment request.
	Total *MoneyInput `json:"total"`
	// The total shipping price for the payment request.
	TotalShippingPrice *ShopPayPaymentRequestTotalShippingPriceInput `json:"totalShippingPrice,omitempty"`
	// The total tax for the payment request.
	TotalTax *MoneyInput `json:"totalTax,omitempty"`
}

// Represents a line item for a Shop Pay payment request.
type ShopPayPaymentRequestLineItem struct {
	// The final item price for the line item.
	FinalItemPrice *MoneyV2 `json:"finalItemPrice"`
	// The final line price for the line item.
	FinalLinePrice *MoneyV2 `json:"finalLinePrice"`
	// The image of the line item.
	Image *ShopPayPaymentRequestImage `json:"image,omitempty"`
	// The item discounts for the line item.
	ItemDiscounts []*ShopPayPaymentRequestDiscount `json:"itemDiscounts,omitempty"`
	// The label of the line item.
	Label string `json:"label"`
	// The line discounts for the line item.
	LineDiscounts []*ShopPayPaymentRequestDiscount `json:"lineDiscounts,omitempty"`
	// The original item price for the line item.
	OriginalItemPrice *MoneyV2 `json:"originalItemPrice,omitempty"`
	// The original line price for the line item.
	OriginalLinePrice *MoneyV2 `json:"originalLinePrice,omitempty"`
	// The quantity of the line item.
	Quantity int32 `json:"quantity"`
	// Whether the line item requires shipping.
	RequiresShipping *bool `json:"requiresShipping,omitempty"`
	// The SKU of the line item.
	Sku *string `json:"sku,omitempty"`
}

// The input fields to create a line item for a Shop Pay payment request.
type ShopPayPaymentRequestLineItemInput struct {
	// The final item price for the line item.
	FinalItemPrice *MoneyInput `json:"finalItemPrice,omitempty"`
	// The final line price for the line item.
	FinalLinePrice *MoneyInput `json:"finalLinePrice,omitempty"`
	// The image of the line item.
	Image *ShopPayPaymentRequestImageInput `json:"image,omitempty"`
	// The item discounts for the line item.
	//
	// The input must not contain more than `250` values.
	ItemDiscounts []*ShopPayPaymentRequestDiscountInput `json:"itemDiscounts,omitempty"`
	// The label of the line item.
	Label *string `json:"label,omitempty"`
	// The line discounts for the line item.
	//
	// The input must not contain more than `250` values.
	LineDiscounts []*ShopPayPaymentRequestDiscountInput `json:"lineDiscounts,omitempty"`
	// The original item price for the line item.
	OriginalItemPrice *MoneyInput `json:"originalItemPrice,omitempty"`
	// The original line price for the line item.
	OriginalLinePrice *MoneyInput `json:"originalLinePrice,omitempty"`
	// The quantity of the line item.
	Quantity int32 `json:"quantity"`
	// Whether the line item requires shipping.
	RequiresShipping *bool `json:"requiresShipping,omitempty"`
	// The SKU of the line item.
	Sku *string `json:"sku,omitempty"`
}

// Represents a receipt for a Shop Pay payment request.
type ShopPayPaymentRequestReceipt struct {
	// The payment request object.
	PaymentRequest *ShopPayPaymentRequest `json:"paymentRequest"`
	// The processing status.
	ProcessingStatusType string `json:"processingStatusType"`
	// The token of the receipt.
	Token string `json:"token"`
}

// Represents a Shop Pay payment request session.
type ShopPayPaymentRequestSession struct {
	// The checkout URL of the Shop Pay payment request session.
	CheckoutURL string `json:"checkoutUrl"`
	// The payment request associated with the Shop Pay payment request session.
	PaymentRequest *ShopPayPaymentRequest `json:"paymentRequest"`
	// The source identifier of the Shop Pay payment request session.
	SourceIdentifier string `json:"sourceIdentifier"`
	// The token of the Shop Pay payment request session.
	Token string `json:"token"`
}

// Return type for `shopPayPaymentRequestSessionCreate` mutation.
type ShopPayPaymentRequestSessionCreatePayload struct {
	// The new Shop Pay payment request session object.
	ShopPayPaymentRequestSession *ShopPayPaymentRequestSession `json:"shopPayPaymentRequestSession,omitempty"`
	// Error codes for failed Shop Pay payment request session mutations.
	UserErrors []*UserErrorsShopPayPaymentRequestSessionUserErrors `json:"userErrors"`
}

// Return type for `shopPayPaymentRequestSessionSubmit` mutation.
type ShopPayPaymentRequestSessionSubmitPayload struct {
	// The checkout on which the payment was applied.
	PaymentRequestReceipt *ShopPayPaymentRequestReceipt `json:"paymentRequestReceipt,omitempty"`
	// Error codes for failed Shop Pay payment request session mutations.
	UserErrors []*UserErrorsShopPayPaymentRequestSessionUserErrors `json:"userErrors"`
}

// Represents a shipping line for a Shop Pay payment request.
type ShopPayPaymentRequestShippingLine struct {
	// The amount for the shipping line.
	Amount *MoneyV2 `json:"amount"`
	// The code of the shipping line.
	Code string `json:"code"`
	// The label of the shipping line.
	Label string `json:"label"`
}

// The input fields to create a shipping line for a Shop Pay payment request.
type ShopPayPaymentRequestShippingLineInput struct {
	// The amount for the shipping line.
	Amount *MoneyInput `json:"amount,omitempty"`
	// The code of the shipping line.
	Code *string `json:"code,omitempty"`
	// The label of the shipping line.
	Label *string `json:"label,omitempty"`
}

// Represents a shipping total for a Shop Pay payment request.
type ShopPayPaymentRequestTotalShippingPrice struct {
	// The discounts for the shipping total.
	Discounts []*ShopPayPaymentRequestDiscount `json:"discounts"`
	// The final total for the shipping total.
	FinalTotal *MoneyV2 `json:"finalTotal"`
	// The original total for the shipping total.
	OriginalTotal *MoneyV2 `json:"originalTotal,omitempty"`
}

// The input fields to create a shipping total for a Shop Pay payment request.
type ShopPayPaymentRequestTotalShippingPriceInput struct {
	// The discounts for the shipping total.
	//
	// The input must not contain more than `250` values.
	Discounts []*ShopPayPaymentRequestDiscountInput `json:"discounts,omitempty"`
	// The final total for the shipping total.
	FinalTotal *MoneyInput `json:"finalTotal,omitempty"`
	// The original total for the shipping total.
	OriginalTotal *MoneyInput `json:"originalTotal,omitempty"`
}

// The input fields for submitting Shop Pay payment method information for checkout.
type ShopPayWalletContentInput struct {
	// The customer's billing address.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// Session token for transaction.
	SessionToken string `json:"sessionToken"`
}

// Policy that a merchant has configured for their store, such as their refund or privacy policy.
type ShopPolicy struct {
	// Policy text, maximum size of 64kb.
	Body string `json:"body"`
	// Policy’s handle.
	Handle string `json:"handle"`
	// A globally-unique ID.
	ID string `json:"id"`
	// Policy’s title.
	Title string `json:"title"`
	// Public URL to the policy.
	URL string `json:"url"`
}

func (ShopPolicy) IsMenuItemResource() {}

func (ShopPolicy) IsNode() {}

// A globally-unique ID.
func (this ShopPolicy) GetID() string { return this.ID }

// A policy for the store that comes with a default value, such as a subscription policy.
// If the merchant hasn't configured a policy for their store, then the policy will return the default value.
// Otherwise, the policy will return the merchant-configured value.
type ShopPolicyWithDefault struct {
	// The text of the policy. Maximum size: 64KB.
	Body string `json:"body"`
	// The handle of the policy.
	Handle string `json:"handle"`
	// The unique ID of the policy. A default policy doesn't have an ID.
	ID *string `json:"id,omitempty"`
	// The title of the policy.
	Title string `json:"title"`
	// Public URL to the policy.
	URL string `json:"url"`
}

// Contains all fields required to generate sitemaps.
type Sitemap struct {
	// The number of sitemap's pages for a given type.
	PagesCount *Count `json:"pagesCount,omitempty"`
	// A list of sitemap's resources for a given type.
	//
	// Important Notes:
	// - The number of items per page varies from 0 to 250.
	// - Empty pages (0 items) may occur and do not necessarily indicate the end of results.
	// - Always check `hasNextPage` to determine if more pages are available.
	Resources *PaginatedSitemapResources `json:"resources,omitempty"`
}

// Represents a sitemap's image.
type SitemapImage struct {
	// Image's alt text.
	Alt *string `json:"alt,omitempty"`
	// Path to the image.
	Filepath *string `json:"filepath,omitempty"`
	// The date and time when the image was updated.
	UpdatedAt string `json:"updatedAt"`
}

// Represents a sitemap resource that is not a metaobject.
type SitemapResource struct {
	// Resource's handle.
	Handle string `json:"handle"`
	// Resource's image.
	Image *SitemapImage `json:"image,omitempty"`
	// Resource's title.
	Title *string `json:"title,omitempty"`
	// The date and time when the resource was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (SitemapResource) IsSitemapResourceInterface() {}

// Resource's handle.
func (this SitemapResource) GetHandle() string { return this.Handle }

// The date and time when the resource was updated.
func (this SitemapResource) GetUpdatedAt() string { return this.UpdatedAt }

// A SitemapResourceMetaobject represents a metaobject with
// [the `renderable` capability](https://shopify.dev/docs/apps/build/custom-data/metaobjects/use-metaobject-capabilities#render-metaobjects-as-web-pages).
type SitemapResourceMetaobject struct {
	// Resource's handle.
	Handle string `json:"handle"`
	// The URL handle for accessing pages of this metaobject type in the Online Store.
	OnlineStoreURLHandle *string `json:"onlineStoreUrlHandle,omitempty"`
	// The type of the metaobject. Defines the namespace of its associated metafields.
	Type string `json:"type"`
	// The date and time when the resource was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (SitemapResourceMetaobject) IsSitemapResourceInterface() {}

// Resource's handle.
func (this SitemapResourceMetaobject) GetHandle() string { return this.Handle }

// The date and time when the resource was updated.
func (this SitemapResourceMetaobject) GetUpdatedAt() string { return this.UpdatedAt }

// The availability of a product variant at a particular location.
// Local pick-up must be enabled in the  store's shipping settings, otherwise this will return an empty result.
type StoreAvailability struct {
	// Whether the product variant is in-stock at this location.
	Available bool `json:"available"`
	// The location where this product variant is stocked at.
	Location *Location `json:"location"`
	// Returns the estimated amount of time it takes for pickup to be ready (Example: Usually ready in 24 hours).
	PickUpTime string `json:"pickUpTime"`
	// The quantity of the product variant in-stock at this location.
	QuantityAvailable int32 `json:"quantityAvailable"`
}

// An auto-generated type for paginating through multiple StoreAvailabilities.
type StoreAvailabilityConnection struct {
	// A list of edges.
	Edges []*StoreAvailabilityEdge `json:"edges"`
	// A list of the nodes contained in StoreAvailabilityEdge.
	Nodes []*StoreAvailability `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one StoreAvailability and a cursor during pagination.
type StoreAvailabilityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of StoreAvailabilityEdge.
	Node *StoreAvailability `json:"node"`
}

// An auto-generated type for paginating through multiple Strings.
type StringConnection struct {
	// A list of edges.
	Edges []*StringEdge `json:"edges"`
	// A list of the nodes contained in StringEdge.
	Nodes []string `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one String and a cursor during pagination.
type StringEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of StringEdge.
	Node string `json:"node"`
}

// An error that occurred during cart submit for completion.
type SubmissionError struct {
	// The error code.
	Code SubmissionErrorCode `json:"code"`
	// The error message.
	Message *string `json:"message,omitempty"`
}

// Cart submit for checkout completion is successful.
type SubmitAlreadyAccepted struct {
	// The ID of the cart completion attempt that will be used for polling for the result.
	AttemptID string `json:"attemptId"`
}

func (SubmitAlreadyAccepted) IsCartSubmitForCompletionResult() {}

// Cart submit for checkout completion failed.
type SubmitFailed struct {
	// The URL of the checkout for the cart.
	CheckoutURL *string `json:"checkoutUrl,omitempty"`
	// The list of errors that occurred from executing the mutation.
	Errors []*SubmissionError `json:"errors"`
}

func (SubmitFailed) IsCartSubmitForCompletionResult() {}

// Cart submit for checkout completion is already accepted.
type SubmitSuccess struct {
	// The ID of the cart completion attempt that will be used for polling for the result.
	AttemptID string `json:"attemptId"`
	// The url to which the buyer should be redirected after the cart is successfully submitted.
	RedirectURL string `json:"redirectUrl"`
}

func (SubmitSuccess) IsCartSubmitForCompletionResult() {}

// Cart submit for checkout completion is throttled.
type SubmitThrottled struct {
	// UTC date time string that indicates the time after which clients should make their next
	// poll request. Any poll requests sent before this time will be ignored. Use this value to schedule the
	// next poll request.
	PollAfter string `json:"pollAfter"`
}

func (SubmitThrottled) IsCartSubmitForCompletionResult() {}

// Color and image for visual representation.
type Swatch struct {
	// The swatch color.
	Color *string `json:"color,omitempty"`
	// The swatch image.
	Image *MediaImage `json:"image,omitempty"`
}

// The taxonomy category for the product.
type TaxonomyCategory struct {
	// All parent nodes of the current taxonomy category.
	Ancestors []*TaxonomyCategory `json:"ancestors"`
	// A static identifier for the taxonomy category.
	ID string `json:"id"`
	// The localized name of the taxonomy category.
	Name string `json:"name"`
}

func (TaxonomyCategory) IsNode() {}

// A globally-unique ID.
func (this TaxonomyCategory) GetID() string { return this.ID }

// A filter used to view a subset of products in a collection matching a specific taxonomy metafield value.
type TaxonomyMetafieldFilter struct {
	// The key of the metafield to filter on.
	Key string `json:"key"`
	// The namespace of the metafield to filter on.
	Namespace string `json:"namespace"`
	// The value of the metafield.
	Value string `json:"value"`
}

// Specifies the fields required to complete a checkout with
// a tokenized payment.
type TokenizedPaymentInputV3 struct {
	// The billing address for the payment.
	BillingAddress *MailingAddressInput `json:"billingAddress"`
	// A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests).
	IdempotencyKey string `json:"idempotencyKey"`
	// Public Hash Key used for AndroidPay payments only.
	Identifier *string `json:"identifier,omitempty"`
	// The amount and currency of the payment.
	PaymentAmount *MoneyInput `json:"paymentAmount"`
	// A simple string or JSON containing the required payment data for the tokenized payment.
	PaymentData string `json:"paymentData"`
	// Whether to execute the payment in test mode, if possible. Test mode isn't supported in production stores. Defaults to `false`.
	Test *bool `json:"test,omitempty"`
	// The type of payment token.
	Type PaymentTokenType `json:"type"`
}

// An object representing exchange of money for a product or service.
type Transaction struct {
	// The amount of money that the transaction was for.
	Amount *MoneyV2 `json:"amount"`
	// The amount of money that the transaction was for.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// The kind of the transaction.
	Kind TransactionKind `json:"kind"`
	// The status of the transaction.
	Status TransactionStatus `json:"status"`
	// The status of the transaction.
	StatusV2 *TransactionStatus `json:"statusV2,omitempty"`
	// Whether the transaction was done in test mode or not.
	Test bool `json:"test"`
}

// The measurement used to calculate a unit price for a product variant (e.g. $9.99 / 100ml).
type UnitPriceMeasurement struct {
	// The type of unit of measurement for the unit price measurement.
	MeasuredType *UnitPriceMeasurementMeasuredType `json:"measuredType,omitempty"`
	// The quantity unit for the unit price measurement.
	QuantityUnit *UnitPriceMeasurementMeasuredUnit `json:"quantityUnit,omitempty"`
	// The quantity value for the unit price measurement.
	QuantityValue float64 `json:"quantityValue"`
	// The reference unit for the unit price measurement.
	ReferenceUnit *UnitPriceMeasurementMeasuredUnit `json:"referenceUnit,omitempty"`
	// The reference value for the unit price measurement.
	ReferenceValue int32 `json:"referenceValue"`
}

// A redirect on the online store.
type URLRedirect struct {
	// The ID of the URL redirect.
	ID string `json:"id"`
	// The old path to be redirected from. When the user visits this path, they'll be redirected to the target location.
	Path string `json:"path"`
	// The target location where the user will be redirected to.
	Target string `json:"target"`
}

func (URLRedirect) IsNode() {}

// A globally-unique ID.
func (this URLRedirect) GetID() string { return this.ID }

// An auto-generated type for paginating through multiple UrlRedirects.
type URLRedirectConnection struct {
	// A list of edges.
	Edges []*URLRedirectEdge `json:"edges"`
	// A list of the nodes contained in UrlRedirectEdge.
	Nodes []*URLRedirect `json:"nodes"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An auto-generated type which holds one UrlRedirect and a cursor during pagination.
type URLRedirectEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of UrlRedirectEdge.
	Node *URLRedirect `json:"node"`
}

// Represents an error in the input of a mutation.
type UserError struct {
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (UserError) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this UserError) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this UserError) GetMessage() string { return this.Message }

// Error codes for failed Shop Pay payment request session mutations.
type UserErrorsShopPayPaymentRequestSessionUserErrors struct {
	// The error code.
	Code *UserErrorsShopPayPaymentRequestSessionUserErrorsCode `json:"code,omitempty"`
	// The path to the input field that caused the error.
	Field []string `json:"field,omitempty"`
	// The error message.
	Message string `json:"message"`
}

func (UserErrorsShopPayPaymentRequestSessionUserErrors) IsDisplayableError() {}

// The path to the input field that caused the error.
func (this UserErrorsShopPayPaymentRequestSessionUserErrors) GetField() []string {
	if this.Field == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Field))
	for _, concrete := range this.Field {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The error message.
func (this UserErrorsShopPayPaymentRequestSessionUserErrors) GetMessage() string { return this.Message }

// The input fields for a filter used to view a subset of products in a collection matching a specific variant option.
type VariantOptionFilter struct {
	// The name of the variant option to filter on.
	Name string `json:"name"`
	// The value of the variant option to filter on.
	Value string `json:"value"`
}

// Represents a Shopify hosted video.
type Video struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt,omitempty"`
	// A globally-unique ID.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// The presentation for a media.
	Presentation *MediaPresentation `json:"presentation,omitempty"`
	// The preview image for the media.
	PreviewImage *Image `json:"previewImage,omitempty"`
	// The sources for a video.
	Sources []*VideoSource `json:"sources"`
}

func (Video) IsMetafieldReference() {}

func (Video) IsMedia() {}

// A word or phrase to share the nature or contents of a media.
func (this Video) GetAlt() *string { return this.Alt }

// A globally-unique ID.
func (this Video) GetID() string { return this.ID }

// The media content type.
func (this Video) GetMediaContentType() MediaContentType { return this.MediaContentType }

// The presentation for a media.
func (this Video) GetPresentation() *MediaPresentation { return this.Presentation }

// The preview image for the media.
func (this Video) GetPreviewImage() *Image { return this.PreviewImage }

func (Video) IsNode() {}

// A globally-unique ID.

// Represents a source for a Shopify hosted video.
type VideoSource struct {
	// The format of the video source.
	Format string `json:"format"`
	// The height of the video.
	Height int32 `json:"height"`
	// The video MIME type.
	MimeType string `json:"mimeType"`
	// The URL of the video.
	URL string `json:"url"`
	// The width of the video.
	Width int32 `json:"width"`
}

// The set of valid sort keys for the Article query.
type ArticleSortKeys string

const (
	// Sort by the `author` value.
	ArticleSortKeysAuthor ArticleSortKeys = "AUTHOR"
	// Sort by the `blog_title` value.
	ArticleSortKeysBlogTitle ArticleSortKeys = "BLOG_TITLE"
	// Sort by the `id` value.
	ArticleSortKeysID ArticleSortKeys = "ID"
	// Sort by the `published_at` value.
	ArticleSortKeysPublishedAt ArticleSortKeys = "PUBLISHED_AT"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ArticleSortKeysRelevance ArticleSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	ArticleSortKeysTitle ArticleSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	ArticleSortKeysUpdatedAt ArticleSortKeys = "UPDATED_AT"
)

var AllArticleSortKeys = []ArticleSortKeys{
	ArticleSortKeysAuthor,
	ArticleSortKeysBlogTitle,
	ArticleSortKeysID,
	ArticleSortKeysPublishedAt,
	ArticleSortKeysRelevance,
	ArticleSortKeysTitle,
	ArticleSortKeysUpdatedAt,
}

func (e ArticleSortKeys) IsValid() bool {
	switch e {
	case ArticleSortKeysAuthor, ArticleSortKeysBlogTitle, ArticleSortKeysID, ArticleSortKeysPublishedAt, ArticleSortKeysRelevance, ArticleSortKeysTitle, ArticleSortKeysUpdatedAt:
		return true
	}
	return false
}

func (e ArticleSortKeys) String() string {
	return string(e)
}

func (e *ArticleSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArticleSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArticleSortKeys", str)
	}
	return nil
}

func (e ArticleSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ArticleSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ArticleSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Blog query.
type BlogSortKeys string

const (
	// Sort by the `handle` value.
	BlogSortKeysHandle BlogSortKeys = "HANDLE"
	// Sort by the `id` value.
	BlogSortKeysID BlogSortKeys = "ID"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	BlogSortKeysRelevance BlogSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	BlogSortKeysTitle BlogSortKeys = "TITLE"
)

var AllBlogSortKeys = []BlogSortKeys{
	BlogSortKeysHandle,
	BlogSortKeysID,
	BlogSortKeysRelevance,
	BlogSortKeysTitle,
}

func (e BlogSortKeys) IsValid() bool {
	switch e {
	case BlogSortKeysHandle, BlogSortKeysID, BlogSortKeysRelevance, BlogSortKeysTitle:
		return true
	}
	return false
}

func (e BlogSortKeys) String() string {
	return string(e)
}

func (e *BlogSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlogSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlogSortKeys", str)
	}
	return nil
}

func (e BlogSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BlogSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BlogSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Card brand, such as Visa or Mastercard, which can be used for payments.
type CardBrand string

const (
	// American Express.
	CardBrandAmericanExpress CardBrand = "AMERICAN_EXPRESS"
	// Diners Club.
	CardBrandDinersClub CardBrand = "DINERS_CLUB"
	// Discover.
	CardBrandDiscover CardBrand = "DISCOVER"
	// JCB.
	CardBrandJcb CardBrand = "JCB"
	// Mastercard.
	CardBrandMastercard CardBrand = "MASTERCARD"
	// Visa.
	CardBrandVisa CardBrand = "VISA"
)

var AllCardBrand = []CardBrand{
	CardBrandAmericanExpress,
	CardBrandDinersClub,
	CardBrandDiscover,
	CardBrandJcb,
	CardBrandMastercard,
	CardBrandVisa,
}

func (e CardBrand) IsValid() bool {
	switch e {
	case CardBrandAmericanExpress, CardBrandDinersClub, CardBrandDiscover, CardBrandJcb, CardBrandMastercard, CardBrandVisa:
		return true
	}
	return false
}

func (e CardBrand) String() string {
	return string(e)
}

func (e *CardBrand) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardBrand(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardBrand", str)
	}
	return nil
}

func (e CardBrand) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CardBrand) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CardBrand) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents how credit card details are provided for a direct payment.
type CartCardSource string

const (
	// The credit card was provided by a third party and vaulted on their system.
	// Using this value requires a separate permission from Shopify.
	CartCardSourceSavedCreditCard CartCardSource = "SAVED_CREDIT_CARD"
)

var AllCartCardSource = []CartCardSource{
	CartCardSourceSavedCreditCard,
}

func (e CartCardSource) IsValid() bool {
	switch e {
	case CartCardSourceSavedCreditCard:
		return true
	}
	return false
}

func (e CartCardSource) String() string {
	return string(e)
}

func (e *CartCardSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CartCardSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CartCardSource", str)
	}
	return nil
}

func (e CartCardSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CartCardSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CartCardSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Defines what type of merchandise is in the delivery group.
type CartDeliveryGroupType string

const (
	// The delivery group only contains merchandise that is either a one time purchase or a first delivery of
	// subscription merchandise.
	CartDeliveryGroupTypeOneTimePurchase CartDeliveryGroupType = "ONE_TIME_PURCHASE"
	// The delivery group only contains subscription merchandise.
	CartDeliveryGroupTypeSubscription CartDeliveryGroupType = "SUBSCRIPTION"
)

var AllCartDeliveryGroupType = []CartDeliveryGroupType{
	CartDeliveryGroupTypeOneTimePurchase,
	CartDeliveryGroupTypeSubscription,
}

func (e CartDeliveryGroupType) IsValid() bool {
	switch e {
	case CartDeliveryGroupTypeOneTimePurchase, CartDeliveryGroupTypeSubscription:
		return true
	}
	return false
}

func (e CartDeliveryGroupType) String() string {
	return string(e)
}

func (e *CartDeliveryGroupType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CartDeliveryGroupType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CartDeliveryGroupType", str)
	}
	return nil
}

func (e CartDeliveryGroupType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CartDeliveryGroupType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CartDeliveryGroupType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `CartUserError`.
type CartErrorCode string

const (
	// The specified address field contains emojis.
	CartErrorCodeAddressFieldContainsEmojis CartErrorCode = "ADDRESS_FIELD_CONTAINS_EMOJIS"
	// The specified address field contains HTML tags.
	CartErrorCodeAddressFieldContainsHTMLTags CartErrorCode = "ADDRESS_FIELD_CONTAINS_HTML_TAGS"
	// The specified address field contains a URL.
	CartErrorCodeAddressFieldContainsURL CartErrorCode = "ADDRESS_FIELD_CONTAINS_URL"
	// The specified address field does not match the expected pattern.
	CartErrorCodeAddressFieldDoesNotMatchExpectedPattern CartErrorCode = "ADDRESS_FIELD_DOES_NOT_MATCH_EXPECTED_PATTERN"
	// The specified address field is required.
	CartErrorCodeAddressFieldIsRequired CartErrorCode = "ADDRESS_FIELD_IS_REQUIRED"
	// The specified address field is too long.
	CartErrorCodeAddressFieldIsTooLong CartErrorCode = "ADDRESS_FIELD_IS_TOO_LONG"
	// The cart is too large to save.
	CartErrorCodeCartTooLarge CartErrorCode = "CART_TOO_LARGE"
	// The input value is invalid.
	CartErrorCodeInvalid CartErrorCode = "INVALID"
	// Company location not found or not allowed.
	CartErrorCodeInvalidCompanyLocation CartErrorCode = "INVALID_COMPANY_LOCATION"
	// The delivery address was not found.
	CartErrorCodeInvalidDeliveryAddressID CartErrorCode = "INVALID_DELIVERY_ADDRESS_ID"
	// Delivery group was not found in cart.
	CartErrorCodeInvalidDeliveryGroup CartErrorCode = "INVALID_DELIVERY_GROUP"
	// Delivery option was not valid.
	CartErrorCodeInvalidDeliveryOption CartErrorCode = "INVALID_DELIVERY_OPTION"
	// The quantity must be a multiple of the specified increment.
	CartErrorCodeInvalidIncrement CartErrorCode = "INVALID_INCREMENT"
	// Merchandise line was not found in cart.
	CartErrorCodeInvalidMerchandiseLine CartErrorCode = "INVALID_MERCHANDISE_LINE"
	// The metafields were not valid.
	CartErrorCodeInvalidMetafields CartErrorCode = "INVALID_METAFIELDS"
	// The payment wasn't valid.
	CartErrorCodeInvalidPayment CartErrorCode = "INVALID_PAYMENT"
	// The payment is invalid. Deferred payment is required.
	CartErrorCodeInvalidPaymentDeferredPaymentRequired CartErrorCode = "INVALID_PAYMENT_DEFERRED_PAYMENT_REQUIRED"
	// Cannot update payment on an empty cart
	CartErrorCodeInvalidPaymentEmptyCart CartErrorCode = "INVALID_PAYMENT_EMPTY_CART"
	// The given zip code is invalid for the provided country.
	CartErrorCodeInvalidZipCodeForCountry CartErrorCode = "INVALID_ZIP_CODE_FOR_COUNTRY"
	// The given zip code is invalid for the provided province.
	CartErrorCodeInvalidZipCodeForProvince CartErrorCode = "INVALID_ZIP_CODE_FOR_PROVINCE"
	// The input value should be less than the maximum value allowed.
	CartErrorCodeLessThan CartErrorCode = "LESS_THAN"
	// The quantity must be below the specified maximum for the item.
	CartErrorCodeMaximumExceeded CartErrorCode = "MAXIMUM_EXCEEDED"
	// The quantity must be above the specified minimum for the item.
	CartErrorCodeMinimumNotMet CartErrorCode = "MINIMUM_NOT_MET"
	// The customer access token is required when setting a company location.
	CartErrorCodeMissingCustomerAccessToken CartErrorCode = "MISSING_CUSTOMER_ACCESS_TOKEN"
	// Missing discount code.
	CartErrorCodeMissingDiscountCode CartErrorCode = "MISSING_DISCOUNT_CODE"
	// Missing note.
	CartErrorCodeMissingNote CartErrorCode = "MISSING_NOTE"
	// The note length must be below the specified maximum.
	CartErrorCodeNoteTooLong CartErrorCode = "NOTE_TOO_LONG"
	// Only one delivery address can be selected.
	CartErrorCodeOnlyOneDeliveryAddressCanBeSelected CartErrorCode = "ONLY_ONE_DELIVERY_ADDRESS_CAN_BE_SELECTED"
	// Credit card has expired.
	CartErrorCodePaymentsCreditCardBaseExpired CartErrorCode = "PAYMENTS_CREDIT_CARD_BASE_EXPIRED"
	// Credit card gateway is not supported.
	CartErrorCodePaymentsCreditCardBaseGatewayNotSupported CartErrorCode = "PAYMENTS_CREDIT_CARD_BASE_GATEWAY_NOT_SUPPORTED"
	// Credit card error.
	CartErrorCodePaymentsCreditCardGeneric CartErrorCode = "PAYMENTS_CREDIT_CARD_GENERIC"
	// Credit card month is invalid.
	CartErrorCodePaymentsCreditCardMonthInclusion CartErrorCode = "PAYMENTS_CREDIT_CARD_MONTH_INCLUSION"
	// Credit card number is invalid.
	CartErrorCodePaymentsCreditCardNumberInvalid CartErrorCode = "PAYMENTS_CREDIT_CARD_NUMBER_INVALID"
	// Credit card number format is invalid.
	CartErrorCodePaymentsCreditCardNumberInvalidFormat CartErrorCode = "PAYMENTS_CREDIT_CARD_NUMBER_INVALID_FORMAT"
	// Credit card verification value is blank.
	CartErrorCodePaymentsCreditCardVerificationValueBlank CartErrorCode = "PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_BLANK"
	// Credit card verification value is invalid for card type.
	CartErrorCodePaymentsCreditCardVerificationValueInvalidForCardType CartErrorCode = "PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_INVALID_FOR_CARD_TYPE"
	// Credit card has expired.
	CartErrorCodePaymentsCreditCardYearExpired CartErrorCode = "PAYMENTS_CREDIT_CARD_YEAR_EXPIRED"
	// Credit card expiry year is invalid.
	CartErrorCodePaymentsCreditCardYearInvalidExpiryYear CartErrorCode = "PAYMENTS_CREDIT_CARD_YEAR_INVALID_EXPIRY_YEAR"
	// The payment method is not applicable.
	CartErrorCodePaymentMethodNotApplicable CartErrorCode = "PAYMENT_METHOD_NOT_APPLICABLE"
	// The payment method is not supported.
	CartErrorCodePaymentMethodNotSupported CartErrorCode = "PAYMENT_METHOD_NOT_SUPPORTED"
	// The delivery group is in a pending state.
	CartErrorCodePendingDeliveryGroups CartErrorCode = "PENDING_DELIVERY_GROUPS"
	// The given province cannot be found.
	CartErrorCodeProvinceNotFound CartErrorCode = "PROVINCE_NOT_FOUND"
	// Selling plan is not applicable.
	CartErrorCodeSellingPlanNotApplicable CartErrorCode = "SELLING_PLAN_NOT_APPLICABLE"
	// An error occurred while saving the cart.
	CartErrorCodeServiceUnavailable CartErrorCode = "SERVICE_UNAVAILABLE"
	// Too many delivery addresses on Cart.
	CartErrorCodeTooManyDeliveryAddresses CartErrorCode = "TOO_MANY_DELIVERY_ADDRESSES"
	// A general error occurred during address validation.
	CartErrorCodeUnspecifiedAddressError CartErrorCode = "UNSPECIFIED_ADDRESS_ERROR"
	// Validation failed.
	CartErrorCodeValidationCustom CartErrorCode = "VALIDATION_CUSTOM"
	// Variant can only be purchased with a selling plan.
	CartErrorCodeVariantRequiresSellingPlan CartErrorCode = "VARIANT_REQUIRES_SELLING_PLAN"
	// The given zip code is unsupported.
	CartErrorCodeZipCodeNotSupported CartErrorCode = "ZIP_CODE_NOT_SUPPORTED"
)

var AllCartErrorCode = []CartErrorCode{
	CartErrorCodeAddressFieldContainsEmojis,
	CartErrorCodeAddressFieldContainsHTMLTags,
	CartErrorCodeAddressFieldContainsURL,
	CartErrorCodeAddressFieldDoesNotMatchExpectedPattern,
	CartErrorCodeAddressFieldIsRequired,
	CartErrorCodeAddressFieldIsTooLong,
	CartErrorCodeCartTooLarge,
	CartErrorCodeInvalid,
	CartErrorCodeInvalidCompanyLocation,
	CartErrorCodeInvalidDeliveryAddressID,
	CartErrorCodeInvalidDeliveryGroup,
	CartErrorCodeInvalidDeliveryOption,
	CartErrorCodeInvalidIncrement,
	CartErrorCodeInvalidMerchandiseLine,
	CartErrorCodeInvalidMetafields,
	CartErrorCodeInvalidPayment,
	CartErrorCodeInvalidPaymentDeferredPaymentRequired,
	CartErrorCodeInvalidPaymentEmptyCart,
	CartErrorCodeInvalidZipCodeForCountry,
	CartErrorCodeInvalidZipCodeForProvince,
	CartErrorCodeLessThan,
	CartErrorCodeMaximumExceeded,
	CartErrorCodeMinimumNotMet,
	CartErrorCodeMissingCustomerAccessToken,
	CartErrorCodeMissingDiscountCode,
	CartErrorCodeMissingNote,
	CartErrorCodeNoteTooLong,
	CartErrorCodeOnlyOneDeliveryAddressCanBeSelected,
	CartErrorCodePaymentsCreditCardBaseExpired,
	CartErrorCodePaymentsCreditCardBaseGatewayNotSupported,
	CartErrorCodePaymentsCreditCardGeneric,
	CartErrorCodePaymentsCreditCardMonthInclusion,
	CartErrorCodePaymentsCreditCardNumberInvalid,
	CartErrorCodePaymentsCreditCardNumberInvalidFormat,
	CartErrorCodePaymentsCreditCardVerificationValueBlank,
	CartErrorCodePaymentsCreditCardVerificationValueInvalidForCardType,
	CartErrorCodePaymentsCreditCardYearExpired,
	CartErrorCodePaymentsCreditCardYearInvalidExpiryYear,
	CartErrorCodePaymentMethodNotApplicable,
	CartErrorCodePaymentMethodNotSupported,
	CartErrorCodePendingDeliveryGroups,
	CartErrorCodeProvinceNotFound,
	CartErrorCodeSellingPlanNotApplicable,
	CartErrorCodeServiceUnavailable,
	CartErrorCodeTooManyDeliveryAddresses,
	CartErrorCodeUnspecifiedAddressError,
	CartErrorCodeValidationCustom,
	CartErrorCodeVariantRequiresSellingPlan,
	CartErrorCodeZipCodeNotSupported,
}

func (e CartErrorCode) IsValid() bool {
	switch e {
	case CartErrorCodeAddressFieldContainsEmojis, CartErrorCodeAddressFieldContainsHTMLTags, CartErrorCodeAddressFieldContainsURL, CartErrorCodeAddressFieldDoesNotMatchExpectedPattern, CartErrorCodeAddressFieldIsRequired, CartErrorCodeAddressFieldIsTooLong, CartErrorCodeCartTooLarge, CartErrorCodeInvalid, CartErrorCodeInvalidCompanyLocation, CartErrorCodeInvalidDeliveryAddressID, CartErrorCodeInvalidDeliveryGroup, CartErrorCodeInvalidDeliveryOption, CartErrorCodeInvalidIncrement, CartErrorCodeInvalidMerchandiseLine, CartErrorCodeInvalidMetafields, CartErrorCodeInvalidPayment, CartErrorCodeInvalidPaymentDeferredPaymentRequired, CartErrorCodeInvalidPaymentEmptyCart, CartErrorCodeInvalidZipCodeForCountry, CartErrorCodeInvalidZipCodeForProvince, CartErrorCodeLessThan, CartErrorCodeMaximumExceeded, CartErrorCodeMinimumNotMet, CartErrorCodeMissingCustomerAccessToken, CartErrorCodeMissingDiscountCode, CartErrorCodeMissingNote, CartErrorCodeNoteTooLong, CartErrorCodeOnlyOneDeliveryAddressCanBeSelected, CartErrorCodePaymentsCreditCardBaseExpired, CartErrorCodePaymentsCreditCardBaseGatewayNotSupported, CartErrorCodePaymentsCreditCardGeneric, CartErrorCodePaymentsCreditCardMonthInclusion, CartErrorCodePaymentsCreditCardNumberInvalid, CartErrorCodePaymentsCreditCardNumberInvalidFormat, CartErrorCodePaymentsCreditCardVerificationValueBlank, CartErrorCodePaymentsCreditCardVerificationValueInvalidForCardType, CartErrorCodePaymentsCreditCardYearExpired, CartErrorCodePaymentsCreditCardYearInvalidExpiryYear, CartErrorCodePaymentMethodNotApplicable, CartErrorCodePaymentMethodNotSupported, CartErrorCodePendingDeliveryGroups, CartErrorCodeProvinceNotFound, CartErrorCodeSellingPlanNotApplicable, CartErrorCodeServiceUnavailable, CartErrorCodeTooManyDeliveryAddresses, CartErrorCodeUnspecifiedAddressError, CartErrorCodeValidationCustom, CartErrorCodeVariantRequiresSellingPlan, CartErrorCodeZipCodeNotSupported:
		return true
	}
	return false
}

func (e CartErrorCode) String() string {
	return string(e)
}

func (e *CartErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CartErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CartErrorCode", str)
	}
	return nil
}

func (e CartErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CartErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CartErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The code for the cart warning.
type CartWarningCode string

const (
	// The discount code cannot be honored.
	CartWarningCodeDiscountCodeNotHonoured CartWarningCode = "DISCOUNT_CODE_NOT_HONOURED"
	// The discount is currently inactive.
	CartWarningCodeDiscountCurrentlyInactive CartWarningCode = "DISCOUNT_CURRENTLY_INACTIVE"
	// The customer is not eligible for this discount.
	CartWarningCodeDiscountCustomerNotEligible CartWarningCode = "DISCOUNT_CUSTOMER_NOT_ELIGIBLE"
	// The customer's discount usage limit has been reached.
	CartWarningCodeDiscountCustomerUsageLimitReached CartWarningCode = "DISCOUNT_CUSTOMER_USAGE_LIMIT_REACHED"
	// An eligible customer is missing for this discount.
	CartWarningCodeDiscountEligibleCustomerMissing CartWarningCode = "DISCOUNT_ELIGIBLE_CUSTOMER_MISSING"
	// The purchase type is incompatible with this discount.
	CartWarningCodeDiscountIncompatiblePurchaseType CartWarningCode = "DISCOUNT_INCOMPATIBLE_PURCHASE_TYPE"
	// The discount was not found.
	CartWarningCodeDiscountNotFound CartWarningCode = "DISCOUNT_NOT_FOUND"
	// There are no entitled line items for this discount.
	CartWarningCodeDiscountNoEntitledLineItems CartWarningCode = "DISCOUNT_NO_ENTITLED_LINE_ITEMS"
	// There are no entitled shipping lines for this discount.
	CartWarningCodeDiscountNoEntitledShippingLines CartWarningCode = "DISCOUNT_NO_ENTITLED_SHIPPING_LINES"
	// The purchase is not in range for this discount.
	CartWarningCodeDiscountPurchaseNotInRange CartWarningCode = "DISCOUNT_PURCHASE_NOT_IN_RANGE"
	// The quantity is not in range for this discount.
	CartWarningCodeDiscountQuantityNotInRange CartWarningCode = "DISCOUNT_QUANTITY_NOT_IN_RANGE"
	// The discount usage limit has been reached.
	CartWarningCodeDiscountUsageLimitReached CartWarningCode = "DISCOUNT_USAGE_LIMIT_REACHED"
	// A delivery address with the same details already exists on this cart.
	CartWarningCodeDuplicateDeliveryAddress CartWarningCode = "DUPLICATE_DELIVERY_ADDRESS"
	// The merchandise does not have enough stock.
	CartWarningCodeMerchandiseNotEnoughStock CartWarningCode = "MERCHANDISE_NOT_ENOUGH_STOCK"
	// The merchandise is out of stock.
	CartWarningCodeMerchandiseOutOfStock CartWarningCode = "MERCHANDISE_OUT_OF_STOCK"
	// Only one-time purchase is available for B2B orders.
	CartWarningCodeMerchandiseSellingPlanNotApplicableOnCompanyLocation CartWarningCode = "MERCHANDISE_SELLING_PLAN_NOT_APPLICABLE_ON_COMPANY_LOCATION"
	// Gift cards are not available as a payment method.
	CartWarningCodePaymentsGiftCardsUnavailable CartWarningCode = "PAYMENTS_GIFT_CARDS_UNAVAILABLE"
)

var AllCartWarningCode = []CartWarningCode{
	CartWarningCodeDiscountCodeNotHonoured,
	CartWarningCodeDiscountCurrentlyInactive,
	CartWarningCodeDiscountCustomerNotEligible,
	CartWarningCodeDiscountCustomerUsageLimitReached,
	CartWarningCodeDiscountEligibleCustomerMissing,
	CartWarningCodeDiscountIncompatiblePurchaseType,
	CartWarningCodeDiscountNotFound,
	CartWarningCodeDiscountNoEntitledLineItems,
	CartWarningCodeDiscountNoEntitledShippingLines,
	CartWarningCodeDiscountPurchaseNotInRange,
	CartWarningCodeDiscountQuantityNotInRange,
	CartWarningCodeDiscountUsageLimitReached,
	CartWarningCodeDuplicateDeliveryAddress,
	CartWarningCodeMerchandiseNotEnoughStock,
	CartWarningCodeMerchandiseOutOfStock,
	CartWarningCodeMerchandiseSellingPlanNotApplicableOnCompanyLocation,
	CartWarningCodePaymentsGiftCardsUnavailable,
}

func (e CartWarningCode) IsValid() bool {
	switch e {
	case CartWarningCodeDiscountCodeNotHonoured, CartWarningCodeDiscountCurrentlyInactive, CartWarningCodeDiscountCustomerNotEligible, CartWarningCodeDiscountCustomerUsageLimitReached, CartWarningCodeDiscountEligibleCustomerMissing, CartWarningCodeDiscountIncompatiblePurchaseType, CartWarningCodeDiscountNotFound, CartWarningCodeDiscountNoEntitledLineItems, CartWarningCodeDiscountNoEntitledShippingLines, CartWarningCodeDiscountPurchaseNotInRange, CartWarningCodeDiscountQuantityNotInRange, CartWarningCodeDiscountUsageLimitReached, CartWarningCodeDuplicateDeliveryAddress, CartWarningCodeMerchandiseNotEnoughStock, CartWarningCodeMerchandiseOutOfStock, CartWarningCodeMerchandiseSellingPlanNotApplicableOnCompanyLocation, CartWarningCodePaymentsGiftCardsUnavailable:
		return true
	}
	return false
}

func (e CartWarningCode) String() string {
	return string(e)
}

func (e *CartWarningCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CartWarningCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CartWarningCode", str)
	}
	return nil
}

func (e CartWarningCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CartWarningCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CartWarningCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `CheckoutUserError`.
type CheckoutErrorCode string

const (
	// Checkout is already completed.
	CheckoutErrorCodeAlreadyCompleted CheckoutErrorCode = "ALREADY_COMPLETED"
	// Input email contains an invalid domain name.
	CheckoutErrorCodeBadDomain CheckoutErrorCode = "BAD_DOMAIN"
	// The input value is blank.
	CheckoutErrorCodeBlank CheckoutErrorCode = "BLANK"
	// Cart does not meet discount requirements notice.
	CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice CheckoutErrorCode = "CART_DOES_NOT_MEET_DISCOUNT_REQUIREMENTS_NOTICE"
	// Customer already used once per customer discount notice.
	CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice CheckoutErrorCode = "CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE"
	// Discount already applied.
	CheckoutErrorCodeDiscountAlreadyApplied CheckoutErrorCode = "DISCOUNT_ALREADY_APPLIED"
	// Discount code isn't working right now. Please contact us for help.
	CheckoutErrorCodeDiscountCodeApplicationFailed CheckoutErrorCode = "DISCOUNT_CODE_APPLICATION_FAILED"
	// Discount disabled.
	CheckoutErrorCodeDiscountDisabled CheckoutErrorCode = "DISCOUNT_DISABLED"
	// Discount expired.
	CheckoutErrorCodeDiscountExpired CheckoutErrorCode = "DISCOUNT_EXPIRED"
	// Discount limit reached.
	CheckoutErrorCodeDiscountLimitReached CheckoutErrorCode = "DISCOUNT_LIMIT_REACHED"
	// Discount not found.
	CheckoutErrorCodeDiscountNotFound CheckoutErrorCode = "DISCOUNT_NOT_FOUND"
	// Checkout is already completed.
	CheckoutErrorCodeEmpty CheckoutErrorCode = "EMPTY"
	// Queue token has expired.
	CheckoutErrorCodeExpiredQueueToken CheckoutErrorCode = "EXPIRED_QUEUE_TOKEN"
	// Gift card has already been applied.
	CheckoutErrorCodeGiftCardAlreadyApplied CheckoutErrorCode = "GIFT_CARD_ALREADY_APPLIED"
	// Gift card code is invalid.
	CheckoutErrorCodeGiftCardCodeInvalid CheckoutErrorCode = "GIFT_CARD_CODE_INVALID"
	// Gift card currency does not match checkout currency.
	CheckoutErrorCodeGiftCardCurrencyMismatch CheckoutErrorCode = "GIFT_CARD_CURRENCY_MISMATCH"
	// Gift card has no funds left.
	CheckoutErrorCodeGiftCardDepleted CheckoutErrorCode = "GIFT_CARD_DEPLETED"
	// Gift card is disabled.
	CheckoutErrorCodeGiftCardDisabled CheckoutErrorCode = "GIFT_CARD_DISABLED"
	// Gift card is expired.
	CheckoutErrorCodeGiftCardExpired CheckoutErrorCode = "GIFT_CARD_EXPIRED"
	// Gift card was not found.
	CheckoutErrorCodeGiftCardNotFound CheckoutErrorCode = "GIFT_CARD_NOT_FOUND"
	// Gift card cannot be applied to a checkout that contains a gift card.
	CheckoutErrorCodeGiftCardUnusable CheckoutErrorCode = "GIFT_CARD_UNUSABLE"
	// The input value should be greater than or equal to the minimum value allowed.
	CheckoutErrorCodeGreaterThanOrEqualTo CheckoutErrorCode = "GREATER_THAN_OR_EQUAL_TO"
	// Higher value discount applied.
	CheckoutErrorCodeHigherValueDiscountApplied CheckoutErrorCode = "HIGHER_VALUE_DISCOUNT_APPLIED"
	// The input value is invalid.
	CheckoutErrorCodeInvalid CheckoutErrorCode = "INVALID"
	// Cannot specify country and presentment currency code.
	CheckoutErrorCodeInvalidCountryAndCurrency CheckoutErrorCode = "INVALID_COUNTRY_AND_CURRENCY"
	// Input Zip is invalid for country provided.
	CheckoutErrorCodeInvalidForCountry CheckoutErrorCode = "INVALID_FOR_COUNTRY"
	// Input Zip is invalid for country and province provided.
	CheckoutErrorCodeInvalidForCountryAndProvince CheckoutErrorCode = "INVALID_FOR_COUNTRY_AND_PROVINCE"
	// Invalid province in country.
	CheckoutErrorCodeInvalidProvinceInCountry CheckoutErrorCode = "INVALID_PROVINCE_IN_COUNTRY"
	// Queue token is invalid.
	CheckoutErrorCodeInvalidQueueToken CheckoutErrorCode = "INVALID_QUEUE_TOKEN"
	// Invalid region in country.
	CheckoutErrorCodeInvalidRegionInCountry CheckoutErrorCode = "INVALID_REGION_IN_COUNTRY"
	// Invalid state in country.
	CheckoutErrorCodeInvalidStateInCountry CheckoutErrorCode = "INVALID_STATE_IN_COUNTRY"
	// The input value should be less than the maximum value allowed.
	CheckoutErrorCodeLessThan CheckoutErrorCode = "LESS_THAN"
	// The input value should be less than or equal to the maximum value allowed.
	CheckoutErrorCodeLessThanOrEqualTo CheckoutErrorCode = "LESS_THAN_OR_EQUAL_TO"
	// Line item was not found in checkout.
	CheckoutErrorCodeLineItemNotFound CheckoutErrorCode = "LINE_ITEM_NOT_FOUND"
	// Checkout is locked.
	CheckoutErrorCodeLocked CheckoutErrorCode = "LOCKED"
	// Maximum number of discount codes limit reached.
	CheckoutErrorCodeMaximumDiscountCodeLimitReached CheckoutErrorCode = "MAXIMUM_DISCOUNT_CODE_LIMIT_REACHED"
	// Missing payment input.
	CheckoutErrorCodeMissingPaymentInput CheckoutErrorCode = "MISSING_PAYMENT_INPUT"
	// Not enough in stock.
	CheckoutErrorCodeNotEnoughInStock CheckoutErrorCode = "NOT_ENOUGH_IN_STOCK"
	// Input value is not supported.
	CheckoutErrorCodeNotSupported CheckoutErrorCode = "NOT_SUPPORTED"
	// The input value needs to be blank.
	CheckoutErrorCodePresent CheckoutErrorCode = "PRESENT"
	// Product is not published for this customer.
	CheckoutErrorCodeProductNotAvailable CheckoutErrorCode = "PRODUCT_NOT_AVAILABLE"
	// Shipping rate expired.
	CheckoutErrorCodeShippingRateExpired CheckoutErrorCode = "SHIPPING_RATE_EXPIRED"
	// Throttled during checkout.
	CheckoutErrorCodeThrottledDuringCheckout CheckoutErrorCode = "THROTTLED_DURING_CHECKOUT"
	// The input value is too long.
	CheckoutErrorCodeTooLong CheckoutErrorCode = "TOO_LONG"
	// The amount of the payment does not match the value to be paid.
	CheckoutErrorCodeTotalPriceMismatch CheckoutErrorCode = "TOTAL_PRICE_MISMATCH"
	// Unable to apply discount.
	CheckoutErrorCodeUnableToApply CheckoutErrorCode = "UNABLE_TO_APPLY"
)

var AllCheckoutErrorCode = []CheckoutErrorCode{
	CheckoutErrorCodeAlreadyCompleted,
	CheckoutErrorCodeBadDomain,
	CheckoutErrorCodeBlank,
	CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice,
	CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice,
	CheckoutErrorCodeDiscountAlreadyApplied,
	CheckoutErrorCodeDiscountCodeApplicationFailed,
	CheckoutErrorCodeDiscountDisabled,
	CheckoutErrorCodeDiscountExpired,
	CheckoutErrorCodeDiscountLimitReached,
	CheckoutErrorCodeDiscountNotFound,
	CheckoutErrorCodeEmpty,
	CheckoutErrorCodeExpiredQueueToken,
	CheckoutErrorCodeGiftCardAlreadyApplied,
	CheckoutErrorCodeGiftCardCodeInvalid,
	CheckoutErrorCodeGiftCardCurrencyMismatch,
	CheckoutErrorCodeGiftCardDepleted,
	CheckoutErrorCodeGiftCardDisabled,
	CheckoutErrorCodeGiftCardExpired,
	CheckoutErrorCodeGiftCardNotFound,
	CheckoutErrorCodeGiftCardUnusable,
	CheckoutErrorCodeGreaterThanOrEqualTo,
	CheckoutErrorCodeHigherValueDiscountApplied,
	CheckoutErrorCodeInvalid,
	CheckoutErrorCodeInvalidCountryAndCurrency,
	CheckoutErrorCodeInvalidForCountry,
	CheckoutErrorCodeInvalidForCountryAndProvince,
	CheckoutErrorCodeInvalidProvinceInCountry,
	CheckoutErrorCodeInvalidQueueToken,
	CheckoutErrorCodeInvalidRegionInCountry,
	CheckoutErrorCodeInvalidStateInCountry,
	CheckoutErrorCodeLessThan,
	CheckoutErrorCodeLessThanOrEqualTo,
	CheckoutErrorCodeLineItemNotFound,
	CheckoutErrorCodeLocked,
	CheckoutErrorCodeMaximumDiscountCodeLimitReached,
	CheckoutErrorCodeMissingPaymentInput,
	CheckoutErrorCodeNotEnoughInStock,
	CheckoutErrorCodeNotSupported,
	CheckoutErrorCodePresent,
	CheckoutErrorCodeProductNotAvailable,
	CheckoutErrorCodeShippingRateExpired,
	CheckoutErrorCodeThrottledDuringCheckout,
	CheckoutErrorCodeTooLong,
	CheckoutErrorCodeTotalPriceMismatch,
	CheckoutErrorCodeUnableToApply,
}

func (e CheckoutErrorCode) IsValid() bool {
	switch e {
	case CheckoutErrorCodeAlreadyCompleted, CheckoutErrorCodeBadDomain, CheckoutErrorCodeBlank, CheckoutErrorCodeCartDoesNotMeetDiscountRequirementsNotice, CheckoutErrorCodeCustomerAlreadyUsedOncePerCustomerDiscountNotice, CheckoutErrorCodeDiscountAlreadyApplied, CheckoutErrorCodeDiscountCodeApplicationFailed, CheckoutErrorCodeDiscountDisabled, CheckoutErrorCodeDiscountExpired, CheckoutErrorCodeDiscountLimitReached, CheckoutErrorCodeDiscountNotFound, CheckoutErrorCodeEmpty, CheckoutErrorCodeExpiredQueueToken, CheckoutErrorCodeGiftCardAlreadyApplied, CheckoutErrorCodeGiftCardCodeInvalid, CheckoutErrorCodeGiftCardCurrencyMismatch, CheckoutErrorCodeGiftCardDepleted, CheckoutErrorCodeGiftCardDisabled, CheckoutErrorCodeGiftCardExpired, CheckoutErrorCodeGiftCardNotFound, CheckoutErrorCodeGiftCardUnusable, CheckoutErrorCodeGreaterThanOrEqualTo, CheckoutErrorCodeHigherValueDiscountApplied, CheckoutErrorCodeInvalid, CheckoutErrorCodeInvalidCountryAndCurrency, CheckoutErrorCodeInvalidForCountry, CheckoutErrorCodeInvalidForCountryAndProvince, CheckoutErrorCodeInvalidProvinceInCountry, CheckoutErrorCodeInvalidQueueToken, CheckoutErrorCodeInvalidRegionInCountry, CheckoutErrorCodeInvalidStateInCountry, CheckoutErrorCodeLessThan, CheckoutErrorCodeLessThanOrEqualTo, CheckoutErrorCodeLineItemNotFound, CheckoutErrorCodeLocked, CheckoutErrorCodeMaximumDiscountCodeLimitReached, CheckoutErrorCodeMissingPaymentInput, CheckoutErrorCodeNotEnoughInStock, CheckoutErrorCodeNotSupported, CheckoutErrorCodePresent, CheckoutErrorCodeProductNotAvailable, CheckoutErrorCodeShippingRateExpired, CheckoutErrorCodeThrottledDuringCheckout, CheckoutErrorCodeTooLong, CheckoutErrorCodeTotalPriceMismatch, CheckoutErrorCodeUnableToApply:
		return true
	}
	return false
}

func (e CheckoutErrorCode) String() string {
	return string(e)
}

func (e *CheckoutErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckoutErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckoutErrorCode", str)
	}
	return nil
}

func (e CheckoutErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CheckoutErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CheckoutErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Collection query.
type CollectionSortKeys string

const (
	// Sort by the `id` value.
	CollectionSortKeysID CollectionSortKeys = "ID"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	CollectionSortKeysRelevance CollectionSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	CollectionSortKeysTitle CollectionSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	CollectionSortKeysUpdatedAt CollectionSortKeys = "UPDATED_AT"
)

var AllCollectionSortKeys = []CollectionSortKeys{
	CollectionSortKeysID,
	CollectionSortKeysRelevance,
	CollectionSortKeysTitle,
	CollectionSortKeysUpdatedAt,
}

func (e CollectionSortKeys) IsValid() bool {
	switch e {
	case CollectionSortKeysID, CollectionSortKeysRelevance, CollectionSortKeysTitle, CollectionSortKeysUpdatedAt:
		return true
	}
	return false
}

func (e CollectionSortKeys) String() string {
	return string(e)
}

func (e *CollectionSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionSortKeys", str)
	}
	return nil
}

func (e CollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CollectionSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CollectionSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The code of the error that occurred during a cart completion attempt.
type CompletionErrorCode string

const (
	CompletionErrorCodeError                         CompletionErrorCode = "ERROR"
	CompletionErrorCodeInventoryReservationError     CompletionErrorCode = "INVENTORY_RESERVATION_ERROR"
	CompletionErrorCodePaymentAmountTooSmall         CompletionErrorCode = "PAYMENT_AMOUNT_TOO_SMALL"
	CompletionErrorCodePaymentCallIssuer             CompletionErrorCode = "PAYMENT_CALL_ISSUER"
	CompletionErrorCodePaymentCardDeclined           CompletionErrorCode = "PAYMENT_CARD_DECLINED"
	CompletionErrorCodePaymentError                  CompletionErrorCode = "PAYMENT_ERROR"
	CompletionErrorCodePaymentGatewayNotEnabledError CompletionErrorCode = "PAYMENT_GATEWAY_NOT_ENABLED_ERROR"
	CompletionErrorCodePaymentInsufficientFunds      CompletionErrorCode = "PAYMENT_INSUFFICIENT_FUNDS"
	CompletionErrorCodePaymentInvalidBillingAddress  CompletionErrorCode = "PAYMENT_INVALID_BILLING_ADDRESS"
	CompletionErrorCodePaymentInvalidCreditCard      CompletionErrorCode = "PAYMENT_INVALID_CREDIT_CARD"
	CompletionErrorCodePaymentInvalidCurrency        CompletionErrorCode = "PAYMENT_INVALID_CURRENCY"
	CompletionErrorCodePaymentInvalidPaymentMethod   CompletionErrorCode = "PAYMENT_INVALID_PAYMENT_METHOD"
	CompletionErrorCodePaymentTransientError         CompletionErrorCode = "PAYMENT_TRANSIENT_ERROR"
)

var AllCompletionErrorCode = []CompletionErrorCode{
	CompletionErrorCodeError,
	CompletionErrorCodeInventoryReservationError,
	CompletionErrorCodePaymentAmountTooSmall,
	CompletionErrorCodePaymentCallIssuer,
	CompletionErrorCodePaymentCardDeclined,
	CompletionErrorCodePaymentError,
	CompletionErrorCodePaymentGatewayNotEnabledError,
	CompletionErrorCodePaymentInsufficientFunds,
	CompletionErrorCodePaymentInvalidBillingAddress,
	CompletionErrorCodePaymentInvalidCreditCard,
	CompletionErrorCodePaymentInvalidCurrency,
	CompletionErrorCodePaymentInvalidPaymentMethod,
	CompletionErrorCodePaymentTransientError,
}

func (e CompletionErrorCode) IsValid() bool {
	switch e {
	case CompletionErrorCodeError, CompletionErrorCodeInventoryReservationError, CompletionErrorCodePaymentAmountTooSmall, CompletionErrorCodePaymentCallIssuer, CompletionErrorCodePaymentCardDeclined, CompletionErrorCodePaymentError, CompletionErrorCodePaymentGatewayNotEnabledError, CompletionErrorCodePaymentInsufficientFunds, CompletionErrorCodePaymentInvalidBillingAddress, CompletionErrorCodePaymentInvalidCreditCard, CompletionErrorCodePaymentInvalidCurrency, CompletionErrorCodePaymentInvalidPaymentMethod, CompletionErrorCodePaymentTransientError:
		return true
	}
	return false
}

func (e CompletionErrorCode) String() string {
	return string(e)
}

func (e *CompletionErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompletionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompletionErrorCode", str)
	}
	return nil
}

func (e CompletionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CompletionErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CompletionErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The precision of the value returned by a count field.
type CountPrecision string

const (
	// The count is at least the value. A limit was reached.
	CountPrecisionAtLeast CountPrecision = "AT_LEAST"
	// The count is exactly the value.
	CountPrecisionExact CountPrecision = "EXACT"
)

var AllCountPrecision = []CountPrecision{
	CountPrecisionAtLeast,
	CountPrecisionExact,
}

func (e CountPrecision) IsValid() bool {
	switch e {
	case CountPrecisionAtLeast, CountPrecisionExact:
		return true
	}
	return false
}

func (e CountPrecision) String() string {
	return string(e)
}

func (e *CountPrecision) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountPrecision(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountPrecision", str)
	}
	return nil
}

func (e CountPrecision) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CountPrecision) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CountPrecision) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The code designating a country/region, which generally follows ISO 3166-1 alpha-2 guidelines.
// If a territory doesn't have a country code value in the `CountryCode` enum, then it might be considered a subdivision
// of another country. For example, the territories associated with Spain are represented by the country code `ES`,
// and the territories associated with the United States of America are represented by the country code `US`.
type CountryCode string

const (
	// Ascension Island.
	CountryCodeAc CountryCode = "AC"
	// Andorra.
	CountryCodeAd CountryCode = "AD"
	// United Arab Emirates.
	CountryCodeAe CountryCode = "AE"
	// Afghanistan.
	CountryCodeAf CountryCode = "AF"
	// Antigua & Barbuda.
	CountryCodeAg CountryCode = "AG"
	// Anguilla.
	CountryCodeAi CountryCode = "AI"
	// Albania.
	CountryCodeAl CountryCode = "AL"
	// Armenia.
	CountryCodeAm CountryCode = "AM"
	// Netherlands Antilles.
	CountryCodeAn CountryCode = "AN"
	// Angola.
	CountryCodeAo CountryCode = "AO"
	// Argentina.
	CountryCodeAr CountryCode = "AR"
	// Austria.
	CountryCodeAt CountryCode = "AT"
	// Australia.
	CountryCodeAu CountryCode = "AU"
	// Aruba.
	CountryCodeAw CountryCode = "AW"
	// Åland Islands.
	CountryCodeAx CountryCode = "AX"
	// Azerbaijan.
	CountryCodeAz CountryCode = "AZ"
	// Bosnia & Herzegovina.
	CountryCodeBa CountryCode = "BA"
	// Barbados.
	CountryCodeBb CountryCode = "BB"
	// Bangladesh.
	CountryCodeBd CountryCode = "BD"
	// Belgium.
	CountryCodeBe CountryCode = "BE"
	// Burkina Faso.
	CountryCodeBf CountryCode = "BF"
	// Bulgaria.
	CountryCodeBg CountryCode = "BG"
	// Bahrain.
	CountryCodeBh CountryCode = "BH"
	// Burundi.
	CountryCodeBi CountryCode = "BI"
	// Benin.
	CountryCodeBj CountryCode = "BJ"
	// St. Barthélemy.
	CountryCodeBl CountryCode = "BL"
	// Bermuda.
	CountryCodeBm CountryCode = "BM"
	// Brunei.
	CountryCodeBn CountryCode = "BN"
	// Bolivia.
	CountryCodeBo CountryCode = "BO"
	// Caribbean Netherlands.
	CountryCodeBq CountryCode = "BQ"
	// Brazil.
	CountryCodeBr CountryCode = "BR"
	// Bahamas.
	CountryCodeBs CountryCode = "BS"
	// Bhutan.
	CountryCodeBt CountryCode = "BT"
	// Bouvet Island.
	CountryCodeBv CountryCode = "BV"
	// Botswana.
	CountryCodeBw CountryCode = "BW"
	// Belarus.
	CountryCodeBy CountryCode = "BY"
	// Belize.
	CountryCodeBz CountryCode = "BZ"
	// Canada.
	CountryCodeCa CountryCode = "CA"
	// Cocos (Keeling) Islands.
	CountryCodeCc CountryCode = "CC"
	// Congo - Kinshasa.
	CountryCodeCd CountryCode = "CD"
	// Central African Republic.
	CountryCodeCf CountryCode = "CF"
	// Congo - Brazzaville.
	CountryCodeCg CountryCode = "CG"
	// Switzerland.
	CountryCodeCh CountryCode = "CH"
	// Côte d’Ivoire.
	CountryCodeCi CountryCode = "CI"
	// Cook Islands.
	CountryCodeCk CountryCode = "CK"
	// Chile.
	CountryCodeCl CountryCode = "CL"
	// Cameroon.
	CountryCodeCm CountryCode = "CM"
	// China.
	CountryCodeCn CountryCode = "CN"
	// Colombia.
	CountryCodeCo CountryCode = "CO"
	// Costa Rica.
	CountryCodeCr CountryCode = "CR"
	// Cuba.
	CountryCodeCu CountryCode = "CU"
	// Cape Verde.
	CountryCodeCv CountryCode = "CV"
	// Curaçao.
	CountryCodeCw CountryCode = "CW"
	// Christmas Island.
	CountryCodeCx CountryCode = "CX"
	// Cyprus.
	CountryCodeCy CountryCode = "CY"
	// Czechia.
	CountryCodeCz CountryCode = "CZ"
	// Germany.
	CountryCodeDe CountryCode = "DE"
	// Djibouti.
	CountryCodeDj CountryCode = "DJ"
	// Denmark.
	CountryCodeDk CountryCode = "DK"
	// Dominica.
	CountryCodeDm CountryCode = "DM"
	// Dominican Republic.
	CountryCodeDo CountryCode = "DO"
	// Algeria.
	CountryCodeDz CountryCode = "DZ"
	// Ecuador.
	CountryCodeEc CountryCode = "EC"
	// Estonia.
	CountryCodeEe CountryCode = "EE"
	// Egypt.
	CountryCodeEg CountryCode = "EG"
	// Western Sahara.
	CountryCodeEh CountryCode = "EH"
	// Eritrea.
	CountryCodeEr CountryCode = "ER"
	// Spain.
	CountryCodeEs CountryCode = "ES"
	// Ethiopia.
	CountryCodeEt CountryCode = "ET"
	// Finland.
	CountryCodeFi CountryCode = "FI"
	// Fiji.
	CountryCodeFj CountryCode = "FJ"
	// Falkland Islands.
	CountryCodeFk CountryCode = "FK"
	// Faroe Islands.
	CountryCodeFo CountryCode = "FO"
	// France.
	CountryCodeFr CountryCode = "FR"
	// Gabon.
	CountryCodeGa CountryCode = "GA"
	// United Kingdom.
	CountryCodeGb CountryCode = "GB"
	// Grenada.
	CountryCodeGd CountryCode = "GD"
	// Georgia.
	CountryCodeGe CountryCode = "GE"
	// French Guiana.
	CountryCodeGf CountryCode = "GF"
	// Guernsey.
	CountryCodeGg CountryCode = "GG"
	// Ghana.
	CountryCodeGh CountryCode = "GH"
	// Gibraltar.
	CountryCodeGi CountryCode = "GI"
	// Greenland.
	CountryCodeGl CountryCode = "GL"
	// Gambia.
	CountryCodeGm CountryCode = "GM"
	// Guinea.
	CountryCodeGn CountryCode = "GN"
	// Guadeloupe.
	CountryCodeGp CountryCode = "GP"
	// Equatorial Guinea.
	CountryCodeGq CountryCode = "GQ"
	// Greece.
	CountryCodeGr CountryCode = "GR"
	// South Georgia & South Sandwich Islands.
	CountryCodeGs CountryCode = "GS"
	// Guatemala.
	CountryCodeGt CountryCode = "GT"
	// Guinea-Bissau.
	CountryCodeGw CountryCode = "GW"
	// Guyana.
	CountryCodeGy CountryCode = "GY"
	// Hong Kong SAR.
	CountryCodeHk CountryCode = "HK"
	// Heard & McDonald Islands.
	CountryCodeHm CountryCode = "HM"
	// Honduras.
	CountryCodeHn CountryCode = "HN"
	// Croatia.
	CountryCodeHr CountryCode = "HR"
	// Haiti.
	CountryCodeHt CountryCode = "HT"
	// Hungary.
	CountryCodeHu CountryCode = "HU"
	// Indonesia.
	CountryCodeID CountryCode = "ID"
	// Ireland.
	CountryCodeIe CountryCode = "IE"
	// Israel.
	CountryCodeIl CountryCode = "IL"
	// Isle of Man.
	CountryCodeIm CountryCode = "IM"
	// India.
	CountryCodeIn CountryCode = "IN"
	// British Indian Ocean Territory.
	CountryCodeIo CountryCode = "IO"
	// Iraq.
	CountryCodeIq CountryCode = "IQ"
	// Iran.
	CountryCodeIr CountryCode = "IR"
	// Iceland.
	CountryCodeIs CountryCode = "IS"
	// Italy.
	CountryCodeIt CountryCode = "IT"
	// Jersey.
	CountryCodeJe CountryCode = "JE"
	// Jamaica.
	CountryCodeJm CountryCode = "JM"
	// Jordan.
	CountryCodeJo CountryCode = "JO"
	// Japan.
	CountryCodeJp CountryCode = "JP"
	// Kenya.
	CountryCodeKe CountryCode = "KE"
	// Kyrgyzstan.
	CountryCodeKg CountryCode = "KG"
	// Cambodia.
	CountryCodeKh CountryCode = "KH"
	// Kiribati.
	CountryCodeKi CountryCode = "KI"
	// Comoros.
	CountryCodeKm CountryCode = "KM"
	// St. Kitts & Nevis.
	CountryCodeKn CountryCode = "KN"
	// North Korea.
	CountryCodeKp CountryCode = "KP"
	// South Korea.
	CountryCodeKr CountryCode = "KR"
	// Kuwait.
	CountryCodeKw CountryCode = "KW"
	// Cayman Islands.
	CountryCodeKy CountryCode = "KY"
	// Kazakhstan.
	CountryCodeKz CountryCode = "KZ"
	// Laos.
	CountryCodeLa CountryCode = "LA"
	// Lebanon.
	CountryCodeLb CountryCode = "LB"
	// St. Lucia.
	CountryCodeLc CountryCode = "LC"
	// Liechtenstein.
	CountryCodeLi CountryCode = "LI"
	// Sri Lanka.
	CountryCodeLk CountryCode = "LK"
	// Liberia.
	CountryCodeLr CountryCode = "LR"
	// Lesotho.
	CountryCodeLs CountryCode = "LS"
	// Lithuania.
	CountryCodeLt CountryCode = "LT"
	// Luxembourg.
	CountryCodeLu CountryCode = "LU"
	// Latvia.
	CountryCodeLv CountryCode = "LV"
	// Libya.
	CountryCodeLy CountryCode = "LY"
	// Morocco.
	CountryCodeMa CountryCode = "MA"
	// Monaco.
	CountryCodeMc CountryCode = "MC"
	// Moldova.
	CountryCodeMd CountryCode = "MD"
	// Montenegro.
	CountryCodeMe CountryCode = "ME"
	// St. Martin.
	CountryCodeMf CountryCode = "MF"
	// Madagascar.
	CountryCodeMg CountryCode = "MG"
	// North Macedonia.
	CountryCodeMk CountryCode = "MK"
	// Mali.
	CountryCodeMl CountryCode = "ML"
	// Myanmar (Burma).
	CountryCodeMm CountryCode = "MM"
	// Mongolia.
	CountryCodeMn CountryCode = "MN"
	// Macao SAR.
	CountryCodeMo CountryCode = "MO"
	// Martinique.
	CountryCodeMq CountryCode = "MQ"
	// Mauritania.
	CountryCodeMr CountryCode = "MR"
	// Montserrat.
	CountryCodeMs CountryCode = "MS"
	// Malta.
	CountryCodeMt CountryCode = "MT"
	// Mauritius.
	CountryCodeMu CountryCode = "MU"
	// Maldives.
	CountryCodeMv CountryCode = "MV"
	// Malawi.
	CountryCodeMw CountryCode = "MW"
	// Mexico.
	CountryCodeMx CountryCode = "MX"
	// Malaysia.
	CountryCodeMy CountryCode = "MY"
	// Mozambique.
	CountryCodeMz CountryCode = "MZ"
	// Namibia.
	CountryCodeNa CountryCode = "NA"
	// New Caledonia.
	CountryCodeNc CountryCode = "NC"
	// Niger.
	CountryCodeNe CountryCode = "NE"
	// Norfolk Island.
	CountryCodeNf CountryCode = "NF"
	// Nigeria.
	CountryCodeNg CountryCode = "NG"
	// Nicaragua.
	CountryCodeNi CountryCode = "NI"
	// Netherlands.
	CountryCodeNl CountryCode = "NL"
	// Norway.
	CountryCodeNo CountryCode = "NO"
	// Nepal.
	CountryCodeNp CountryCode = "NP"
	// Nauru.
	CountryCodeNr CountryCode = "NR"
	// Niue.
	CountryCodeNu CountryCode = "NU"
	// New Zealand.
	CountryCodeNz CountryCode = "NZ"
	// Oman.
	CountryCodeOm CountryCode = "OM"
	// Panama.
	CountryCodePa CountryCode = "PA"
	// Peru.
	CountryCodePe CountryCode = "PE"
	// French Polynesia.
	CountryCodePf CountryCode = "PF"
	// Papua New Guinea.
	CountryCodePg CountryCode = "PG"
	// Philippines.
	CountryCodePh CountryCode = "PH"
	// Pakistan.
	CountryCodePk CountryCode = "PK"
	// Poland.
	CountryCodePl CountryCode = "PL"
	// St. Pierre & Miquelon.
	CountryCodePm CountryCode = "PM"
	// Pitcairn Islands.
	CountryCodePn CountryCode = "PN"
	// Palestinian Territories.
	CountryCodePs CountryCode = "PS"
	// Portugal.
	CountryCodePt CountryCode = "PT"
	// Paraguay.
	CountryCodePy CountryCode = "PY"
	// Qatar.
	CountryCodeQa CountryCode = "QA"
	// Réunion.
	CountryCodeRe CountryCode = "RE"
	// Romania.
	CountryCodeRo CountryCode = "RO"
	// Serbia.
	CountryCodeRs CountryCode = "RS"
	// Russia.
	CountryCodeRu CountryCode = "RU"
	// Rwanda.
	CountryCodeRw CountryCode = "RW"
	// Saudi Arabia.
	CountryCodeSa CountryCode = "SA"
	// Solomon Islands.
	CountryCodeSb CountryCode = "SB"
	// Seychelles.
	CountryCodeSc CountryCode = "SC"
	// Sudan.
	CountryCodeSd CountryCode = "SD"
	// Sweden.
	CountryCodeSe CountryCode = "SE"
	// Singapore.
	CountryCodeSg CountryCode = "SG"
	// St. Helena.
	CountryCodeSh CountryCode = "SH"
	// Slovenia.
	CountryCodeSi CountryCode = "SI"
	// Svalbard & Jan Mayen.
	CountryCodeSj CountryCode = "SJ"
	// Slovakia.
	CountryCodeSk CountryCode = "SK"
	// Sierra Leone.
	CountryCodeSl CountryCode = "SL"
	// San Marino.
	CountryCodeSm CountryCode = "SM"
	// Senegal.
	CountryCodeSn CountryCode = "SN"
	// Somalia.
	CountryCodeSo CountryCode = "SO"
	// Suriname.
	CountryCodeSr CountryCode = "SR"
	// South Sudan.
	CountryCodeSs CountryCode = "SS"
	// São Tomé & Príncipe.
	CountryCodeSt CountryCode = "ST"
	// El Salvador.
	CountryCodeSv CountryCode = "SV"
	// Sint Maarten.
	CountryCodeSx CountryCode = "SX"
	// Syria.
	CountryCodeSy CountryCode = "SY"
	// Eswatini.
	CountryCodeSz CountryCode = "SZ"
	// Tristan da Cunha.
	CountryCodeTa CountryCode = "TA"
	// Turks & Caicos Islands.
	CountryCodeTc CountryCode = "TC"
	// Chad.
	CountryCodeTd CountryCode = "TD"
	// French Southern Territories.
	CountryCodeTf CountryCode = "TF"
	// Togo.
	CountryCodeTg CountryCode = "TG"
	// Thailand.
	CountryCodeTh CountryCode = "TH"
	// Tajikistan.
	CountryCodeTj CountryCode = "TJ"
	// Tokelau.
	CountryCodeTk CountryCode = "TK"
	// Timor-Leste.
	CountryCodeTl CountryCode = "TL"
	// Turkmenistan.
	CountryCodeTm CountryCode = "TM"
	// Tunisia.
	CountryCodeTn CountryCode = "TN"
	// Tonga.
	CountryCodeTo CountryCode = "TO"
	// Türkiye.
	CountryCodeTr CountryCode = "TR"
	// Trinidad & Tobago.
	CountryCodeTt CountryCode = "TT"
	// Tuvalu.
	CountryCodeTv CountryCode = "TV"
	// Taiwan.
	CountryCodeTw CountryCode = "TW"
	// Tanzania.
	CountryCodeTz CountryCode = "TZ"
	// Ukraine.
	CountryCodeUa CountryCode = "UA"
	// Uganda.
	CountryCodeUg CountryCode = "UG"
	// U.S. Outlying Islands.
	CountryCodeUm CountryCode = "UM"
	// United States.
	CountryCodeUs CountryCode = "US"
	// Uruguay.
	CountryCodeUy CountryCode = "UY"
	// Uzbekistan.
	CountryCodeUz CountryCode = "UZ"
	// Vatican City.
	CountryCodeVa CountryCode = "VA"
	// St. Vincent & Grenadines.
	CountryCodeVc CountryCode = "VC"
	// Venezuela.
	CountryCodeVe CountryCode = "VE"
	// British Virgin Islands.
	CountryCodeVg CountryCode = "VG"
	// Vietnam.
	CountryCodeVn CountryCode = "VN"
	// Vanuatu.
	CountryCodeVu CountryCode = "VU"
	// Wallis & Futuna.
	CountryCodeWf CountryCode = "WF"
	// Samoa.
	CountryCodeWs CountryCode = "WS"
	// Kosovo.
	CountryCodeXk CountryCode = "XK"
	// Yemen.
	CountryCodeYe CountryCode = "YE"
	// Mayotte.
	CountryCodeYt CountryCode = "YT"
	// South Africa.
	CountryCodeZa CountryCode = "ZA"
	// Zambia.
	CountryCodeZm CountryCode = "ZM"
	// Zimbabwe.
	CountryCodeZw CountryCode = "ZW"
	// Unknown Region.
	CountryCodeZz CountryCode = "ZZ"
)

var AllCountryCode = []CountryCode{
	CountryCodeAc,
	CountryCodeAd,
	CountryCodeAe,
	CountryCodeAf,
	CountryCodeAg,
	CountryCodeAi,
	CountryCodeAl,
	CountryCodeAm,
	CountryCodeAn,
	CountryCodeAo,
	CountryCodeAr,
	CountryCodeAt,
	CountryCodeAu,
	CountryCodeAw,
	CountryCodeAx,
	CountryCodeAz,
	CountryCodeBa,
	CountryCodeBb,
	CountryCodeBd,
	CountryCodeBe,
	CountryCodeBf,
	CountryCodeBg,
	CountryCodeBh,
	CountryCodeBi,
	CountryCodeBj,
	CountryCodeBl,
	CountryCodeBm,
	CountryCodeBn,
	CountryCodeBo,
	CountryCodeBq,
	CountryCodeBr,
	CountryCodeBs,
	CountryCodeBt,
	CountryCodeBv,
	CountryCodeBw,
	CountryCodeBy,
	CountryCodeBz,
	CountryCodeCa,
	CountryCodeCc,
	CountryCodeCd,
	CountryCodeCf,
	CountryCodeCg,
	CountryCodeCh,
	CountryCodeCi,
	CountryCodeCk,
	CountryCodeCl,
	CountryCodeCm,
	CountryCodeCn,
	CountryCodeCo,
	CountryCodeCr,
	CountryCodeCu,
	CountryCodeCv,
	CountryCodeCw,
	CountryCodeCx,
	CountryCodeCy,
	CountryCodeCz,
	CountryCodeDe,
	CountryCodeDj,
	CountryCodeDk,
	CountryCodeDm,
	CountryCodeDo,
	CountryCodeDz,
	CountryCodeEc,
	CountryCodeEe,
	CountryCodeEg,
	CountryCodeEh,
	CountryCodeEr,
	CountryCodeEs,
	CountryCodeEt,
	CountryCodeFi,
	CountryCodeFj,
	CountryCodeFk,
	CountryCodeFo,
	CountryCodeFr,
	CountryCodeGa,
	CountryCodeGb,
	CountryCodeGd,
	CountryCodeGe,
	CountryCodeGf,
	CountryCodeGg,
	CountryCodeGh,
	CountryCodeGi,
	CountryCodeGl,
	CountryCodeGm,
	CountryCodeGn,
	CountryCodeGp,
	CountryCodeGq,
	CountryCodeGr,
	CountryCodeGs,
	CountryCodeGt,
	CountryCodeGw,
	CountryCodeGy,
	CountryCodeHk,
	CountryCodeHm,
	CountryCodeHn,
	CountryCodeHr,
	CountryCodeHt,
	CountryCodeHu,
	CountryCodeID,
	CountryCodeIe,
	CountryCodeIl,
	CountryCodeIm,
	CountryCodeIn,
	CountryCodeIo,
	CountryCodeIq,
	CountryCodeIr,
	CountryCodeIs,
	CountryCodeIt,
	CountryCodeJe,
	CountryCodeJm,
	CountryCodeJo,
	CountryCodeJp,
	CountryCodeKe,
	CountryCodeKg,
	CountryCodeKh,
	CountryCodeKi,
	CountryCodeKm,
	CountryCodeKn,
	CountryCodeKp,
	CountryCodeKr,
	CountryCodeKw,
	CountryCodeKy,
	CountryCodeKz,
	CountryCodeLa,
	CountryCodeLb,
	CountryCodeLc,
	CountryCodeLi,
	CountryCodeLk,
	CountryCodeLr,
	CountryCodeLs,
	CountryCodeLt,
	CountryCodeLu,
	CountryCodeLv,
	CountryCodeLy,
	CountryCodeMa,
	CountryCodeMc,
	CountryCodeMd,
	CountryCodeMe,
	CountryCodeMf,
	CountryCodeMg,
	CountryCodeMk,
	CountryCodeMl,
	CountryCodeMm,
	CountryCodeMn,
	CountryCodeMo,
	CountryCodeMq,
	CountryCodeMr,
	CountryCodeMs,
	CountryCodeMt,
	CountryCodeMu,
	CountryCodeMv,
	CountryCodeMw,
	CountryCodeMx,
	CountryCodeMy,
	CountryCodeMz,
	CountryCodeNa,
	CountryCodeNc,
	CountryCodeNe,
	CountryCodeNf,
	CountryCodeNg,
	CountryCodeNi,
	CountryCodeNl,
	CountryCodeNo,
	CountryCodeNp,
	CountryCodeNr,
	CountryCodeNu,
	CountryCodeNz,
	CountryCodeOm,
	CountryCodePa,
	CountryCodePe,
	CountryCodePf,
	CountryCodePg,
	CountryCodePh,
	CountryCodePk,
	CountryCodePl,
	CountryCodePm,
	CountryCodePn,
	CountryCodePs,
	CountryCodePt,
	CountryCodePy,
	CountryCodeQa,
	CountryCodeRe,
	CountryCodeRo,
	CountryCodeRs,
	CountryCodeRu,
	CountryCodeRw,
	CountryCodeSa,
	CountryCodeSb,
	CountryCodeSc,
	CountryCodeSd,
	CountryCodeSe,
	CountryCodeSg,
	CountryCodeSh,
	CountryCodeSi,
	CountryCodeSj,
	CountryCodeSk,
	CountryCodeSl,
	CountryCodeSm,
	CountryCodeSn,
	CountryCodeSo,
	CountryCodeSr,
	CountryCodeSs,
	CountryCodeSt,
	CountryCodeSv,
	CountryCodeSx,
	CountryCodeSy,
	CountryCodeSz,
	CountryCodeTa,
	CountryCodeTc,
	CountryCodeTd,
	CountryCodeTf,
	CountryCodeTg,
	CountryCodeTh,
	CountryCodeTj,
	CountryCodeTk,
	CountryCodeTl,
	CountryCodeTm,
	CountryCodeTn,
	CountryCodeTo,
	CountryCodeTr,
	CountryCodeTt,
	CountryCodeTv,
	CountryCodeTw,
	CountryCodeTz,
	CountryCodeUa,
	CountryCodeUg,
	CountryCodeUm,
	CountryCodeUs,
	CountryCodeUy,
	CountryCodeUz,
	CountryCodeVa,
	CountryCodeVc,
	CountryCodeVe,
	CountryCodeVg,
	CountryCodeVn,
	CountryCodeVu,
	CountryCodeWf,
	CountryCodeWs,
	CountryCodeXk,
	CountryCodeYe,
	CountryCodeYt,
	CountryCodeZa,
	CountryCodeZm,
	CountryCodeZw,
	CountryCodeZz,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeAc, CountryCodeAd, CountryCodeAe, CountryCodeAf, CountryCodeAg, CountryCodeAi, CountryCodeAl, CountryCodeAm, CountryCodeAn, CountryCodeAo, CountryCodeAr, CountryCodeAt, CountryCodeAu, CountryCodeAw, CountryCodeAx, CountryCodeAz, CountryCodeBa, CountryCodeBb, CountryCodeBd, CountryCodeBe, CountryCodeBf, CountryCodeBg, CountryCodeBh, CountryCodeBi, CountryCodeBj, CountryCodeBl, CountryCodeBm, CountryCodeBn, CountryCodeBo, CountryCodeBq, CountryCodeBr, CountryCodeBs, CountryCodeBt, CountryCodeBv, CountryCodeBw, CountryCodeBy, CountryCodeBz, CountryCodeCa, CountryCodeCc, CountryCodeCd, CountryCodeCf, CountryCodeCg, CountryCodeCh, CountryCodeCi, CountryCodeCk, CountryCodeCl, CountryCodeCm, CountryCodeCn, CountryCodeCo, CountryCodeCr, CountryCodeCu, CountryCodeCv, CountryCodeCw, CountryCodeCx, CountryCodeCy, CountryCodeCz, CountryCodeDe, CountryCodeDj, CountryCodeDk, CountryCodeDm, CountryCodeDo, CountryCodeDz, CountryCodeEc, CountryCodeEe, CountryCodeEg, CountryCodeEh, CountryCodeEr, CountryCodeEs, CountryCodeEt, CountryCodeFi, CountryCodeFj, CountryCodeFk, CountryCodeFo, CountryCodeFr, CountryCodeGa, CountryCodeGb, CountryCodeGd, CountryCodeGe, CountryCodeGf, CountryCodeGg, CountryCodeGh, CountryCodeGi, CountryCodeGl, CountryCodeGm, CountryCodeGn, CountryCodeGp, CountryCodeGq, CountryCodeGr, CountryCodeGs, CountryCodeGt, CountryCodeGw, CountryCodeGy, CountryCodeHk, CountryCodeHm, CountryCodeHn, CountryCodeHr, CountryCodeHt, CountryCodeHu, CountryCodeID, CountryCodeIe, CountryCodeIl, CountryCodeIm, CountryCodeIn, CountryCodeIo, CountryCodeIq, CountryCodeIr, CountryCodeIs, CountryCodeIt, CountryCodeJe, CountryCodeJm, CountryCodeJo, CountryCodeJp, CountryCodeKe, CountryCodeKg, CountryCodeKh, CountryCodeKi, CountryCodeKm, CountryCodeKn, CountryCodeKp, CountryCodeKr, CountryCodeKw, CountryCodeKy, CountryCodeKz, CountryCodeLa, CountryCodeLb, CountryCodeLc, CountryCodeLi, CountryCodeLk, CountryCodeLr, CountryCodeLs, CountryCodeLt, CountryCodeLu, CountryCodeLv, CountryCodeLy, CountryCodeMa, CountryCodeMc, CountryCodeMd, CountryCodeMe, CountryCodeMf, CountryCodeMg, CountryCodeMk, CountryCodeMl, CountryCodeMm, CountryCodeMn, CountryCodeMo, CountryCodeMq, CountryCodeMr, CountryCodeMs, CountryCodeMt, CountryCodeMu, CountryCodeMv, CountryCodeMw, CountryCodeMx, CountryCodeMy, CountryCodeMz, CountryCodeNa, CountryCodeNc, CountryCodeNe, CountryCodeNf, CountryCodeNg, CountryCodeNi, CountryCodeNl, CountryCodeNo, CountryCodeNp, CountryCodeNr, CountryCodeNu, CountryCodeNz, CountryCodeOm, CountryCodePa, CountryCodePe, CountryCodePf, CountryCodePg, CountryCodePh, CountryCodePk, CountryCodePl, CountryCodePm, CountryCodePn, CountryCodePs, CountryCodePt, CountryCodePy, CountryCodeQa, CountryCodeRe, CountryCodeRo, CountryCodeRs, CountryCodeRu, CountryCodeRw, CountryCodeSa, CountryCodeSb, CountryCodeSc, CountryCodeSd, CountryCodeSe, CountryCodeSg, CountryCodeSh, CountryCodeSi, CountryCodeSj, CountryCodeSk, CountryCodeSl, CountryCodeSm, CountryCodeSn, CountryCodeSo, CountryCodeSr, CountryCodeSs, CountryCodeSt, CountryCodeSv, CountryCodeSx, CountryCodeSy, CountryCodeSz, CountryCodeTa, CountryCodeTc, CountryCodeTd, CountryCodeTf, CountryCodeTg, CountryCodeTh, CountryCodeTj, CountryCodeTk, CountryCodeTl, CountryCodeTm, CountryCodeTn, CountryCodeTo, CountryCodeTr, CountryCodeTt, CountryCodeTv, CountryCodeTw, CountryCodeTz, CountryCodeUa, CountryCodeUg, CountryCodeUm, CountryCodeUs, CountryCodeUy, CountryCodeUz, CountryCodeVa, CountryCodeVc, CountryCodeVe, CountryCodeVg, CountryCodeVn, CountryCodeVu, CountryCodeWf, CountryCodeWs, CountryCodeXk, CountryCodeYe, CountryCodeYt, CountryCodeZa, CountryCodeZm, CountryCodeZw, CountryCodeZz:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CountryCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CountryCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The part of the image that should remain after cropping.
type CropRegion string

const (
	// Keep the bottom of the image.
	CropRegionBottom CropRegion = "BOTTOM"
	// Keep the center of the image.
	CropRegionCenter CropRegion = "CENTER"
	// Keep the left of the image.
	CropRegionLeft CropRegion = "LEFT"
	// Keep the right of the image.
	CropRegionRight CropRegion = "RIGHT"
	// Keep the top of the image.
	CropRegionTop CropRegion = "TOP"
)

var AllCropRegion = []CropRegion{
	CropRegionBottom,
	CropRegionCenter,
	CropRegionLeft,
	CropRegionRight,
	CropRegionTop,
}

func (e CropRegion) IsValid() bool {
	switch e {
	case CropRegionBottom, CropRegionCenter, CropRegionLeft, CropRegionRight, CropRegionTop:
		return true
	}
	return false
}

func (e CropRegion) String() string {
	return string(e)
}

func (e *CropRegion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CropRegion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CropRegion", str)
	}
	return nil
}

func (e CropRegion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CropRegion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CropRegion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The three-letter currency codes that represent the world currencies used in
// stores. These include standard ISO 4217 codes, legacy codes,
// and non-standard codes.
type CurrencyCode string

const (
	// United Arab Emirates Dirham (AED).
	CurrencyCodeAed CurrencyCode = "AED"
	// Afghan Afghani (AFN).
	CurrencyCodeAfn CurrencyCode = "AFN"
	// Albanian Lek (ALL).
	CurrencyCodeAll CurrencyCode = "ALL"
	// Armenian Dram (AMD).
	CurrencyCodeAmd CurrencyCode = "AMD"
	// Netherlands Antillean Guilder.
	CurrencyCodeAng CurrencyCode = "ANG"
	// Angolan Kwanza (AOA).
	CurrencyCodeAoa CurrencyCode = "AOA"
	// Argentine Pesos (ARS).
	CurrencyCodeArs CurrencyCode = "ARS"
	// Australian Dollars (AUD).
	CurrencyCodeAud CurrencyCode = "AUD"
	// Aruban Florin (AWG).
	CurrencyCodeAwg CurrencyCode = "AWG"
	// Azerbaijani Manat (AZN).
	CurrencyCodeAzn CurrencyCode = "AZN"
	// Bosnia and Herzegovina Convertible Mark (BAM).
	CurrencyCodeBam CurrencyCode = "BAM"
	// Barbadian Dollar (BBD).
	CurrencyCodeBbd CurrencyCode = "BBD"
	// Bangladesh Taka (BDT).
	CurrencyCodeBdt CurrencyCode = "BDT"
	// Bulgarian Lev (BGN).
	CurrencyCodeBgn CurrencyCode = "BGN"
	// Bahraini Dinar (BHD).
	CurrencyCodeBhd CurrencyCode = "BHD"
	// Burundian Franc (BIF).
	CurrencyCodeBif CurrencyCode = "BIF"
	// Bermudian Dollar (BMD).
	CurrencyCodeBmd CurrencyCode = "BMD"
	// Brunei Dollar (BND).
	CurrencyCodeBnd CurrencyCode = "BND"
	// Bolivian Boliviano (BOB).
	CurrencyCodeBob CurrencyCode = "BOB"
	// Brazilian Real (BRL).
	CurrencyCodeBrl CurrencyCode = "BRL"
	// Bahamian Dollar (BSD).
	CurrencyCodeBsd CurrencyCode = "BSD"
	// Bhutanese Ngultrum (BTN).
	CurrencyCodeBtn CurrencyCode = "BTN"
	// Botswana Pula (BWP).
	CurrencyCodeBwp CurrencyCode = "BWP"
	// Belarusian Ruble (BYN).
	CurrencyCodeByn CurrencyCode = "BYN"
	// Belarusian Ruble (BYR).
	CurrencyCodeByr CurrencyCode = "BYR"
	// Belize Dollar (BZD).
	CurrencyCodeBzd CurrencyCode = "BZD"
	// Canadian Dollars (CAD).
	CurrencyCodeCad CurrencyCode = "CAD"
	// Congolese franc (CDF).
	CurrencyCodeCdf CurrencyCode = "CDF"
	// Swiss Francs (CHF).
	CurrencyCodeChf CurrencyCode = "CHF"
	// Chilean Peso (CLP).
	CurrencyCodeClp CurrencyCode = "CLP"
	// Chinese Yuan Renminbi (CNY).
	CurrencyCodeCny CurrencyCode = "CNY"
	// Colombian Peso (COP).
	CurrencyCodeCop CurrencyCode = "COP"
	// Costa Rican Colones (CRC).
	CurrencyCodeCrc CurrencyCode = "CRC"
	// Cape Verdean escudo (CVE).
	CurrencyCodeCve CurrencyCode = "CVE"
	// Czech Koruny (CZK).
	CurrencyCodeCzk CurrencyCode = "CZK"
	// Djiboutian Franc (DJF).
	CurrencyCodeDjf CurrencyCode = "DJF"
	// Danish Kroner (DKK).
	CurrencyCodeDkk CurrencyCode = "DKK"
	// Dominican Peso (DOP).
	CurrencyCodeDop CurrencyCode = "DOP"
	// Algerian Dinar (DZD).
	CurrencyCodeDzd CurrencyCode = "DZD"
	// Egyptian Pound (EGP).
	CurrencyCodeEgp CurrencyCode = "EGP"
	// Eritrean Nakfa (ERN).
	CurrencyCodeErn CurrencyCode = "ERN"
	// Ethiopian Birr (ETB).
	CurrencyCodeEtb CurrencyCode = "ETB"
	// Euro (EUR).
	CurrencyCodeEur CurrencyCode = "EUR"
	// Fijian Dollars (FJD).
	CurrencyCodeFjd CurrencyCode = "FJD"
	// Falkland Islands Pounds (FKP).
	CurrencyCodeFkp CurrencyCode = "FKP"
	// United Kingdom Pounds (GBP).
	CurrencyCodeGbp CurrencyCode = "GBP"
	// Georgian Lari (GEL).
	CurrencyCodeGel CurrencyCode = "GEL"
	// Ghanaian Cedi (GHS).
	CurrencyCodeGhs CurrencyCode = "GHS"
	// Gibraltar Pounds (GIP).
	CurrencyCodeGip CurrencyCode = "GIP"
	// Gambian Dalasi (GMD).
	CurrencyCodeGmd CurrencyCode = "GMD"
	// Guinean Franc (GNF).
	CurrencyCodeGnf CurrencyCode = "GNF"
	// Guatemalan Quetzal (GTQ).
	CurrencyCodeGtq CurrencyCode = "GTQ"
	// Guyanese Dollar (GYD).
	CurrencyCodeGyd CurrencyCode = "GYD"
	// Hong Kong Dollars (HKD).
	CurrencyCodeHkd CurrencyCode = "HKD"
	// Honduran Lempira (HNL).
	CurrencyCodeHnl CurrencyCode = "HNL"
	// Croatian Kuna (HRK).
	CurrencyCodeHrk CurrencyCode = "HRK"
	// Haitian Gourde (HTG).
	CurrencyCodeHtg CurrencyCode = "HTG"
	// Hungarian Forint (HUF).
	CurrencyCodeHuf CurrencyCode = "HUF"
	// Indonesian Rupiah (IDR).
	CurrencyCodeIDR CurrencyCode = "IDR"
	// Israeli New Shekel (NIS).
	CurrencyCodeIls CurrencyCode = "ILS"
	// Indian Rupees (INR).
	CurrencyCodeInr CurrencyCode = "INR"
	// Iraqi Dinar (IQD).
	CurrencyCodeIqd CurrencyCode = "IQD"
	// Iranian Rial (IRR).
	CurrencyCodeIrr CurrencyCode = "IRR"
	// Icelandic Kronur (ISK).
	CurrencyCodeIsk CurrencyCode = "ISK"
	// Jersey Pound.
	CurrencyCodeJep CurrencyCode = "JEP"
	// Jamaican Dollars (JMD).
	CurrencyCodeJmd CurrencyCode = "JMD"
	// Jordanian Dinar (JOD).
	CurrencyCodeJod CurrencyCode = "JOD"
	// Japanese Yen (JPY).
	CurrencyCodeJpy CurrencyCode = "JPY"
	// Kenyan Shilling (KES).
	CurrencyCodeKes CurrencyCode = "KES"
	// Kyrgyzstani Som (KGS).
	CurrencyCodeKgs CurrencyCode = "KGS"
	// Cambodian Riel.
	CurrencyCodeKhr CurrencyCode = "KHR"
	// Kiribati Dollar (KID).
	CurrencyCodeKid CurrencyCode = "KID"
	// Comorian Franc (KMF).
	CurrencyCodeKmf CurrencyCode = "KMF"
	// South Korean Won (KRW).
	CurrencyCodeKrw CurrencyCode = "KRW"
	// Kuwaiti Dinar (KWD).
	CurrencyCodeKwd CurrencyCode = "KWD"
	// Cayman Dollars (KYD).
	CurrencyCodeKyd CurrencyCode = "KYD"
	// Kazakhstani Tenge (KZT).
	CurrencyCodeKzt CurrencyCode = "KZT"
	// Laotian Kip (LAK).
	CurrencyCodeLak CurrencyCode = "LAK"
	// Lebanese Pounds (LBP).
	CurrencyCodeLbp CurrencyCode = "LBP"
	// Sri Lankan Rupees (LKR).
	CurrencyCodeLkr CurrencyCode = "LKR"
	// Liberian Dollar (LRD).
	CurrencyCodeLrd CurrencyCode = "LRD"
	// Lesotho Loti (LSL).
	CurrencyCodeLsl CurrencyCode = "LSL"
	// Lithuanian Litai (LTL).
	CurrencyCodeLtl CurrencyCode = "LTL"
	// Latvian Lati (LVL).
	CurrencyCodeLvl CurrencyCode = "LVL"
	// Libyan Dinar (LYD).
	CurrencyCodeLyd CurrencyCode = "LYD"
	// Moroccan Dirham.
	CurrencyCodeMad CurrencyCode = "MAD"
	// Moldovan Leu (MDL).
	CurrencyCodeMdl CurrencyCode = "MDL"
	// Malagasy Ariary (MGA).
	CurrencyCodeMga CurrencyCode = "MGA"
	// Macedonia Denar (MKD).
	CurrencyCodeMkd CurrencyCode = "MKD"
	// Burmese Kyat (MMK).
	CurrencyCodeMmk CurrencyCode = "MMK"
	// Mongolian Tugrik.
	CurrencyCodeMnt CurrencyCode = "MNT"
	// Macanese Pataca (MOP).
	CurrencyCodeMop CurrencyCode = "MOP"
	// Mauritanian Ouguiya (MRU).
	CurrencyCodeMru CurrencyCode = "MRU"
	// Mauritian Rupee (MUR).
	CurrencyCodeMur CurrencyCode = "MUR"
	// Maldivian Rufiyaa (MVR).
	CurrencyCodeMvr CurrencyCode = "MVR"
	// Malawian Kwacha (MWK).
	CurrencyCodeMwk CurrencyCode = "MWK"
	// Mexican Pesos (MXN).
	CurrencyCodeMxn CurrencyCode = "MXN"
	// Malaysian Ringgits (MYR).
	CurrencyCodeMyr CurrencyCode = "MYR"
	// Mozambican Metical.
	CurrencyCodeMzn CurrencyCode = "MZN"
	// Namibian Dollar.
	CurrencyCodeNad CurrencyCode = "NAD"
	// Nigerian Naira (NGN).
	CurrencyCodeNgn CurrencyCode = "NGN"
	// Nicaraguan Córdoba (NIO).
	CurrencyCodeNio CurrencyCode = "NIO"
	// Norwegian Kroner (NOK).
	CurrencyCodeNok CurrencyCode = "NOK"
	// Nepalese Rupee (NPR).
	CurrencyCodeNpr CurrencyCode = "NPR"
	// New Zealand Dollars (NZD).
	CurrencyCodeNzd CurrencyCode = "NZD"
	// Omani Rial (OMR).
	CurrencyCodeOmr CurrencyCode = "OMR"
	// Panamian Balboa (PAB).
	CurrencyCodePab CurrencyCode = "PAB"
	// Peruvian Nuevo Sol (PEN).
	CurrencyCodePen CurrencyCode = "PEN"
	// Papua New Guinean Kina (PGK).
	CurrencyCodePgk CurrencyCode = "PGK"
	// Philippine Peso (PHP).
	CurrencyCodePhp CurrencyCode = "PHP"
	// Pakistani Rupee (PKR).
	CurrencyCodePkr CurrencyCode = "PKR"
	// Polish Zlotych (PLN).
	CurrencyCodePln CurrencyCode = "PLN"
	// Paraguayan Guarani (PYG).
	CurrencyCodePyg CurrencyCode = "PYG"
	// Qatari Rial (QAR).
	CurrencyCodeQar CurrencyCode = "QAR"
	// Romanian Lei (RON).
	CurrencyCodeRon CurrencyCode = "RON"
	// Serbian dinar (RSD).
	CurrencyCodeRsd CurrencyCode = "RSD"
	// Russian Rubles (RUB).
	CurrencyCodeRub CurrencyCode = "RUB"
	// Rwandan Franc (RWF).
	CurrencyCodeRwf CurrencyCode = "RWF"
	// Saudi Riyal (SAR).
	CurrencyCodeSar CurrencyCode = "SAR"
	// Solomon Islands Dollar (SBD).
	CurrencyCodeSbd CurrencyCode = "SBD"
	// Seychellois Rupee (SCR).
	CurrencyCodeScr CurrencyCode = "SCR"
	// Sudanese Pound (SDG).
	CurrencyCodeSdg CurrencyCode = "SDG"
	// Swedish Kronor (SEK).
	CurrencyCodeSek CurrencyCode = "SEK"
	// Singapore Dollars (SGD).
	CurrencyCodeSgd CurrencyCode = "SGD"
	// Saint Helena Pounds (SHP).
	CurrencyCodeShp CurrencyCode = "SHP"
	// Sierra Leonean Leone (SLL).
	CurrencyCodeSll CurrencyCode = "SLL"
	// Somali Shilling (SOS).
	CurrencyCodeSos CurrencyCode = "SOS"
	// Surinamese Dollar (SRD).
	CurrencyCodeSrd CurrencyCode = "SRD"
	// South Sudanese Pound (SSP).
	CurrencyCodeSsp CurrencyCode = "SSP"
	// Sao Tome And Principe Dobra (STD).
	CurrencyCodeStd CurrencyCode = "STD"
	// Sao Tome And Principe Dobra (STN).
	CurrencyCodeStn CurrencyCode = "STN"
	// Syrian Pound (SYP).
	CurrencyCodeSyp CurrencyCode = "SYP"
	// Swazi Lilangeni (SZL).
	CurrencyCodeSzl CurrencyCode = "SZL"
	// Thai baht (THB).
	CurrencyCodeThb CurrencyCode = "THB"
	// Tajikistani Somoni (TJS).
	CurrencyCodeTjs CurrencyCode = "TJS"
	// Turkmenistani Manat (TMT).
	CurrencyCodeTmt CurrencyCode = "TMT"
	// Tunisian Dinar (TND).
	CurrencyCodeTnd CurrencyCode = "TND"
	// Tongan Pa'anga (TOP).
	CurrencyCodeTop CurrencyCode = "TOP"
	// Turkish Lira (TRY).
	CurrencyCodeTry CurrencyCode = "TRY"
	// Trinidad and Tobago Dollars (TTD).
	CurrencyCodeTtd CurrencyCode = "TTD"
	// Taiwan Dollars (TWD).
	CurrencyCodeTwd CurrencyCode = "TWD"
	// Tanzanian Shilling (TZS).
	CurrencyCodeTzs CurrencyCode = "TZS"
	// Ukrainian Hryvnia (UAH).
	CurrencyCodeUah CurrencyCode = "UAH"
	// Ugandan Shilling (UGX).
	CurrencyCodeUgx CurrencyCode = "UGX"
	// United States Dollars (USD).
	CurrencyCodeUsd CurrencyCode = "USD"
	// Uruguayan Pesos (UYU).
	CurrencyCodeUyu CurrencyCode = "UYU"
	// Uzbekistan som (UZS).
	CurrencyCodeUzs CurrencyCode = "UZS"
	// Venezuelan Bolivares (VED).
	CurrencyCodeVed CurrencyCode = "VED"
	// Venezuelan Bolivares (VEF).
	CurrencyCodeVef CurrencyCode = "VEF"
	// Venezuelan Bolivares Soberanos (VES).
	CurrencyCodeVes CurrencyCode = "VES"
	// Vietnamese đồng (VND).
	CurrencyCodeVnd CurrencyCode = "VND"
	// Vanuatu Vatu (VUV).
	CurrencyCodeVuv CurrencyCode = "VUV"
	// Samoan Tala (WST).
	CurrencyCodeWst CurrencyCode = "WST"
	// Central African CFA Franc (XAF).
	CurrencyCodeXaf CurrencyCode = "XAF"
	// East Caribbean Dollar (XCD).
	CurrencyCodeXcd CurrencyCode = "XCD"
	// West African CFA franc (XOF).
	CurrencyCodeXof CurrencyCode = "XOF"
	// CFP Franc (XPF).
	CurrencyCodeXpf CurrencyCode = "XPF"
	// Unrecognized currency.
	CurrencyCodeXxx CurrencyCode = "XXX"
	// Yemeni Rial (YER).
	CurrencyCodeYer CurrencyCode = "YER"
	// South African Rand (ZAR).
	CurrencyCodeZar CurrencyCode = "ZAR"
	// Zambian Kwacha (ZMW).
	CurrencyCodeZmw CurrencyCode = "ZMW"
)

var AllCurrencyCode = []CurrencyCode{
	CurrencyCodeAed,
	CurrencyCodeAfn,
	CurrencyCodeAll,
	CurrencyCodeAmd,
	CurrencyCodeAng,
	CurrencyCodeAoa,
	CurrencyCodeArs,
	CurrencyCodeAud,
	CurrencyCodeAwg,
	CurrencyCodeAzn,
	CurrencyCodeBam,
	CurrencyCodeBbd,
	CurrencyCodeBdt,
	CurrencyCodeBgn,
	CurrencyCodeBhd,
	CurrencyCodeBif,
	CurrencyCodeBmd,
	CurrencyCodeBnd,
	CurrencyCodeBob,
	CurrencyCodeBrl,
	CurrencyCodeBsd,
	CurrencyCodeBtn,
	CurrencyCodeBwp,
	CurrencyCodeByn,
	CurrencyCodeByr,
	CurrencyCodeBzd,
	CurrencyCodeCad,
	CurrencyCodeCdf,
	CurrencyCodeChf,
	CurrencyCodeClp,
	CurrencyCodeCny,
	CurrencyCodeCop,
	CurrencyCodeCrc,
	CurrencyCodeCve,
	CurrencyCodeCzk,
	CurrencyCodeDjf,
	CurrencyCodeDkk,
	CurrencyCodeDop,
	CurrencyCodeDzd,
	CurrencyCodeEgp,
	CurrencyCodeErn,
	CurrencyCodeEtb,
	CurrencyCodeEur,
	CurrencyCodeFjd,
	CurrencyCodeFkp,
	CurrencyCodeGbp,
	CurrencyCodeGel,
	CurrencyCodeGhs,
	CurrencyCodeGip,
	CurrencyCodeGmd,
	CurrencyCodeGnf,
	CurrencyCodeGtq,
	CurrencyCodeGyd,
	CurrencyCodeHkd,
	CurrencyCodeHnl,
	CurrencyCodeHrk,
	CurrencyCodeHtg,
	CurrencyCodeHuf,
	CurrencyCodeIDR,
	CurrencyCodeIls,
	CurrencyCodeInr,
	CurrencyCodeIqd,
	CurrencyCodeIrr,
	CurrencyCodeIsk,
	CurrencyCodeJep,
	CurrencyCodeJmd,
	CurrencyCodeJod,
	CurrencyCodeJpy,
	CurrencyCodeKes,
	CurrencyCodeKgs,
	CurrencyCodeKhr,
	CurrencyCodeKid,
	CurrencyCodeKmf,
	CurrencyCodeKrw,
	CurrencyCodeKwd,
	CurrencyCodeKyd,
	CurrencyCodeKzt,
	CurrencyCodeLak,
	CurrencyCodeLbp,
	CurrencyCodeLkr,
	CurrencyCodeLrd,
	CurrencyCodeLsl,
	CurrencyCodeLtl,
	CurrencyCodeLvl,
	CurrencyCodeLyd,
	CurrencyCodeMad,
	CurrencyCodeMdl,
	CurrencyCodeMga,
	CurrencyCodeMkd,
	CurrencyCodeMmk,
	CurrencyCodeMnt,
	CurrencyCodeMop,
	CurrencyCodeMru,
	CurrencyCodeMur,
	CurrencyCodeMvr,
	CurrencyCodeMwk,
	CurrencyCodeMxn,
	CurrencyCodeMyr,
	CurrencyCodeMzn,
	CurrencyCodeNad,
	CurrencyCodeNgn,
	CurrencyCodeNio,
	CurrencyCodeNok,
	CurrencyCodeNpr,
	CurrencyCodeNzd,
	CurrencyCodeOmr,
	CurrencyCodePab,
	CurrencyCodePen,
	CurrencyCodePgk,
	CurrencyCodePhp,
	CurrencyCodePkr,
	CurrencyCodePln,
	CurrencyCodePyg,
	CurrencyCodeQar,
	CurrencyCodeRon,
	CurrencyCodeRsd,
	CurrencyCodeRub,
	CurrencyCodeRwf,
	CurrencyCodeSar,
	CurrencyCodeSbd,
	CurrencyCodeScr,
	CurrencyCodeSdg,
	CurrencyCodeSek,
	CurrencyCodeSgd,
	CurrencyCodeShp,
	CurrencyCodeSll,
	CurrencyCodeSos,
	CurrencyCodeSrd,
	CurrencyCodeSsp,
	CurrencyCodeStd,
	CurrencyCodeStn,
	CurrencyCodeSyp,
	CurrencyCodeSzl,
	CurrencyCodeThb,
	CurrencyCodeTjs,
	CurrencyCodeTmt,
	CurrencyCodeTnd,
	CurrencyCodeTop,
	CurrencyCodeTry,
	CurrencyCodeTtd,
	CurrencyCodeTwd,
	CurrencyCodeTzs,
	CurrencyCodeUah,
	CurrencyCodeUgx,
	CurrencyCodeUsd,
	CurrencyCodeUyu,
	CurrencyCodeUzs,
	CurrencyCodeVed,
	CurrencyCodeVef,
	CurrencyCodeVes,
	CurrencyCodeVnd,
	CurrencyCodeVuv,
	CurrencyCodeWst,
	CurrencyCodeXaf,
	CurrencyCodeXcd,
	CurrencyCodeXof,
	CurrencyCodeXpf,
	CurrencyCodeXxx,
	CurrencyCodeYer,
	CurrencyCodeZar,
	CurrencyCodeZmw,
}

func (e CurrencyCode) IsValid() bool {
	switch e {
	case CurrencyCodeAed, CurrencyCodeAfn, CurrencyCodeAll, CurrencyCodeAmd, CurrencyCodeAng, CurrencyCodeAoa, CurrencyCodeArs, CurrencyCodeAud, CurrencyCodeAwg, CurrencyCodeAzn, CurrencyCodeBam, CurrencyCodeBbd, CurrencyCodeBdt, CurrencyCodeBgn, CurrencyCodeBhd, CurrencyCodeBif, CurrencyCodeBmd, CurrencyCodeBnd, CurrencyCodeBob, CurrencyCodeBrl, CurrencyCodeBsd, CurrencyCodeBtn, CurrencyCodeBwp, CurrencyCodeByn, CurrencyCodeByr, CurrencyCodeBzd, CurrencyCodeCad, CurrencyCodeCdf, CurrencyCodeChf, CurrencyCodeClp, CurrencyCodeCny, CurrencyCodeCop, CurrencyCodeCrc, CurrencyCodeCve, CurrencyCodeCzk, CurrencyCodeDjf, CurrencyCodeDkk, CurrencyCodeDop, CurrencyCodeDzd, CurrencyCodeEgp, CurrencyCodeErn, CurrencyCodeEtb, CurrencyCodeEur, CurrencyCodeFjd, CurrencyCodeFkp, CurrencyCodeGbp, CurrencyCodeGel, CurrencyCodeGhs, CurrencyCodeGip, CurrencyCodeGmd, CurrencyCodeGnf, CurrencyCodeGtq, CurrencyCodeGyd, CurrencyCodeHkd, CurrencyCodeHnl, CurrencyCodeHrk, CurrencyCodeHtg, CurrencyCodeHuf, CurrencyCodeIDR, CurrencyCodeIls, CurrencyCodeInr, CurrencyCodeIqd, CurrencyCodeIrr, CurrencyCodeIsk, CurrencyCodeJep, CurrencyCodeJmd, CurrencyCodeJod, CurrencyCodeJpy, CurrencyCodeKes, CurrencyCodeKgs, CurrencyCodeKhr, CurrencyCodeKid, CurrencyCodeKmf, CurrencyCodeKrw, CurrencyCodeKwd, CurrencyCodeKyd, CurrencyCodeKzt, CurrencyCodeLak, CurrencyCodeLbp, CurrencyCodeLkr, CurrencyCodeLrd, CurrencyCodeLsl, CurrencyCodeLtl, CurrencyCodeLvl, CurrencyCodeLyd, CurrencyCodeMad, CurrencyCodeMdl, CurrencyCodeMga, CurrencyCodeMkd, CurrencyCodeMmk, CurrencyCodeMnt, CurrencyCodeMop, CurrencyCodeMru, CurrencyCodeMur, CurrencyCodeMvr, CurrencyCodeMwk, CurrencyCodeMxn, CurrencyCodeMyr, CurrencyCodeMzn, CurrencyCodeNad, CurrencyCodeNgn, CurrencyCodeNio, CurrencyCodeNok, CurrencyCodeNpr, CurrencyCodeNzd, CurrencyCodeOmr, CurrencyCodePab, CurrencyCodePen, CurrencyCodePgk, CurrencyCodePhp, CurrencyCodePkr, CurrencyCodePln, CurrencyCodePyg, CurrencyCodeQar, CurrencyCodeRon, CurrencyCodeRsd, CurrencyCodeRub, CurrencyCodeRwf, CurrencyCodeSar, CurrencyCodeSbd, CurrencyCodeScr, CurrencyCodeSdg, CurrencyCodeSek, CurrencyCodeSgd, CurrencyCodeShp, CurrencyCodeSll, CurrencyCodeSos, CurrencyCodeSrd, CurrencyCodeSsp, CurrencyCodeStd, CurrencyCodeStn, CurrencyCodeSyp, CurrencyCodeSzl, CurrencyCodeThb, CurrencyCodeTjs, CurrencyCodeTmt, CurrencyCodeTnd, CurrencyCodeTop, CurrencyCodeTry, CurrencyCodeTtd, CurrencyCodeTwd, CurrencyCodeTzs, CurrencyCodeUah, CurrencyCodeUgx, CurrencyCodeUsd, CurrencyCodeUyu, CurrencyCodeUzs, CurrencyCodeVed, CurrencyCodeVef, CurrencyCodeVes, CurrencyCodeVnd, CurrencyCodeVuv, CurrencyCodeWst, CurrencyCodeXaf, CurrencyCodeXcd, CurrencyCodeXof, CurrencyCodeXpf, CurrencyCodeXxx, CurrencyCodeYer, CurrencyCodeZar, CurrencyCodeZmw:
		return true
	}
	return false
}

func (e CurrencyCode) String() string {
	return string(e)
}

func (e *CurrencyCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyCode", str)
	}
	return nil
}

func (e CurrencyCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CurrencyCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CurrencyCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `CustomerUserError`.
type CustomerErrorCode string

const (
	// Customer already enabled.
	CustomerErrorCodeAlreadyEnabled CustomerErrorCode = "ALREADY_ENABLED"
	// Input email contains an invalid domain name.
	CustomerErrorCodeBadDomain CustomerErrorCode = "BAD_DOMAIN"
	// The input value is blank.
	CustomerErrorCodeBlank CustomerErrorCode = "BLANK"
	// Input contains HTML tags.
	CustomerErrorCodeContainsHTMLTags CustomerErrorCode = "CONTAINS_HTML_TAGS"
	// Input contains URL.
	CustomerErrorCodeContainsURL CustomerErrorCode = "CONTAINS_URL"
	// Customer is disabled.
	CustomerErrorCodeCustomerDisabled CustomerErrorCode = "CUSTOMER_DISABLED"
	// The input value is invalid.
	CustomerErrorCodeInvalid CustomerErrorCode = "INVALID"
	// Multipass token is not valid.
	CustomerErrorCodeInvalidMultipassRequest CustomerErrorCode = "INVALID_MULTIPASS_REQUEST"
	// Address does not exist.
	CustomerErrorCodeNotFound CustomerErrorCode = "NOT_FOUND"
	// Input password starts or ends with whitespace.
	CustomerErrorCodePasswordStartsOrEndsWithWhitespace CustomerErrorCode = "PASSWORD_STARTS_OR_ENDS_WITH_WHITESPACE"
	// The input value is already taken.
	CustomerErrorCodeTaken CustomerErrorCode = "TAKEN"
	// Invalid activation token.
	CustomerErrorCodeTokenInvalid CustomerErrorCode = "TOKEN_INVALID"
	// The input value is too long.
	CustomerErrorCodeTooLong CustomerErrorCode = "TOO_LONG"
	// The input value is too short.
	CustomerErrorCodeTooShort CustomerErrorCode = "TOO_SHORT"
	// Unidentified customer.
	CustomerErrorCodeUnidentifiedCustomer CustomerErrorCode = "UNIDENTIFIED_CUSTOMER"
)

var AllCustomerErrorCode = []CustomerErrorCode{
	CustomerErrorCodeAlreadyEnabled,
	CustomerErrorCodeBadDomain,
	CustomerErrorCodeBlank,
	CustomerErrorCodeContainsHTMLTags,
	CustomerErrorCodeContainsURL,
	CustomerErrorCodeCustomerDisabled,
	CustomerErrorCodeInvalid,
	CustomerErrorCodeInvalidMultipassRequest,
	CustomerErrorCodeNotFound,
	CustomerErrorCodePasswordStartsOrEndsWithWhitespace,
	CustomerErrorCodeTaken,
	CustomerErrorCodeTokenInvalid,
	CustomerErrorCodeTooLong,
	CustomerErrorCodeTooShort,
	CustomerErrorCodeUnidentifiedCustomer,
}

func (e CustomerErrorCode) IsValid() bool {
	switch e {
	case CustomerErrorCodeAlreadyEnabled, CustomerErrorCodeBadDomain, CustomerErrorCodeBlank, CustomerErrorCodeContainsHTMLTags, CustomerErrorCodeContainsURL, CustomerErrorCodeCustomerDisabled, CustomerErrorCodeInvalid, CustomerErrorCodeInvalidMultipassRequest, CustomerErrorCodeNotFound, CustomerErrorCodePasswordStartsOrEndsWithWhitespace, CustomerErrorCodeTaken, CustomerErrorCodeTokenInvalid, CustomerErrorCodeTooLong, CustomerErrorCodeTooShort, CustomerErrorCodeUnidentifiedCustomer:
		return true
	}
	return false
}

func (e CustomerErrorCode) String() string {
	return string(e)
}

func (e *CustomerErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerErrorCode", str)
	}
	return nil
}

func (e CustomerErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CustomerErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CustomerErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Defines the types of available validation strategies for delivery addresses.
type DeliveryAddressValidationStrategy string

const (
	// Only the country code is validated.
	DeliveryAddressValidationStrategyCountryCodeOnly DeliveryAddressValidationStrategy = "COUNTRY_CODE_ONLY"
	// Strict validation is performed, i.e. all fields in the address are validated
	// according to Shopify's checkout rules. If the address fails validation, the cart will not be updated.
	DeliveryAddressValidationStrategyStrict DeliveryAddressValidationStrategy = "STRICT"
)

var AllDeliveryAddressValidationStrategy = []DeliveryAddressValidationStrategy{
	DeliveryAddressValidationStrategyCountryCodeOnly,
	DeliveryAddressValidationStrategyStrict,
}

func (e DeliveryAddressValidationStrategy) IsValid() bool {
	switch e {
	case DeliveryAddressValidationStrategyCountryCodeOnly, DeliveryAddressValidationStrategyStrict:
		return true
	}
	return false
}

func (e DeliveryAddressValidationStrategy) String() string {
	return string(e)
}

func (e *DeliveryAddressValidationStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryAddressValidationStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryAddressValidationStrategy", str)
	}
	return nil
}

func (e DeliveryAddressValidationStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeliveryAddressValidationStrategy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeliveryAddressValidationStrategy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// List of different delivery method types.
type DeliveryMethodType string

const (
	// Local Delivery.
	DeliveryMethodTypeLocal DeliveryMethodType = "LOCAL"
	// None.
	DeliveryMethodTypeNone DeliveryMethodType = "NONE"
	// Shipping to a Pickup Point.
	DeliveryMethodTypePickupPoint DeliveryMethodType = "PICKUP_POINT"
	// Local Pickup.
	DeliveryMethodTypePickUp DeliveryMethodType = "PICK_UP"
	// Retail.
	DeliveryMethodTypeRetail DeliveryMethodType = "RETAIL"
	// Shipping.
	DeliveryMethodTypeShipping DeliveryMethodType = "SHIPPING"
)

var AllDeliveryMethodType = []DeliveryMethodType{
	DeliveryMethodTypeLocal,
	DeliveryMethodTypeNone,
	DeliveryMethodTypePickupPoint,
	DeliveryMethodTypePickUp,
	DeliveryMethodTypeRetail,
	DeliveryMethodTypeShipping,
}

func (e DeliveryMethodType) IsValid() bool {
	switch e {
	case DeliveryMethodTypeLocal, DeliveryMethodTypeNone, DeliveryMethodTypePickupPoint, DeliveryMethodTypePickUp, DeliveryMethodTypeRetail, DeliveryMethodTypeShipping:
		return true
	}
	return false
}

func (e DeliveryMethodType) String() string {
	return string(e)
}

func (e *DeliveryMethodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryMethodType", str)
	}
	return nil
}

func (e DeliveryMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeliveryMethodType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeliveryMethodType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Digital wallet, such as Apple Pay, which can be used for accelerated checkouts.
type DigitalWallet string

const (
	// Android Pay.
	DigitalWalletAndroidPay DigitalWallet = "ANDROID_PAY"
	// Apple Pay.
	DigitalWalletApplePay DigitalWallet = "APPLE_PAY"
	// Google Pay.
	DigitalWalletGooglePay DigitalWallet = "GOOGLE_PAY"
	// Shopify Pay.
	DigitalWalletShopifyPay DigitalWallet = "SHOPIFY_PAY"
)

var AllDigitalWallet = []DigitalWallet{
	DigitalWalletAndroidPay,
	DigitalWalletApplePay,
	DigitalWalletGooglePay,
	DigitalWalletShopifyPay,
}

func (e DigitalWallet) IsValid() bool {
	switch e {
	case DigitalWalletAndroidPay, DigitalWalletApplePay, DigitalWalletGooglePay, DigitalWalletShopifyPay:
		return true
	}
	return false
}

func (e DigitalWallet) String() string {
	return string(e)
}

func (e *DigitalWallet) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DigitalWallet(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DigitalWallet", str)
	}
	return nil
}

func (e DigitalWallet) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DigitalWallet) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DigitalWallet) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The method by which the discount's value is allocated onto its entitled lines.
type DiscountApplicationAllocationMethod string

const (
	// The value is spread across all entitled lines.
	DiscountApplicationAllocationMethodAcross DiscountApplicationAllocationMethod = "ACROSS"
	// The value is applied onto every entitled line.
	DiscountApplicationAllocationMethodEach DiscountApplicationAllocationMethod = "EACH"
	// The value is specifically applied onto a particular line.
	DiscountApplicationAllocationMethodOne DiscountApplicationAllocationMethod = "ONE"
)

var AllDiscountApplicationAllocationMethod = []DiscountApplicationAllocationMethod{
	DiscountApplicationAllocationMethodAcross,
	DiscountApplicationAllocationMethodEach,
	DiscountApplicationAllocationMethodOne,
}

func (e DiscountApplicationAllocationMethod) IsValid() bool {
	switch e {
	case DiscountApplicationAllocationMethodAcross, DiscountApplicationAllocationMethodEach, DiscountApplicationAllocationMethodOne:
		return true
	}
	return false
}

func (e DiscountApplicationAllocationMethod) String() string {
	return string(e)
}

func (e *DiscountApplicationAllocationMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationAllocationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationAllocationMethod", str)
	}
	return nil
}

func (e DiscountApplicationAllocationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DiscountApplicationAllocationMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DiscountApplicationAllocationMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The lines on the order to which the discount is applied, of the type defined by
// the discount application's `targetType`. For example, the value `ENTITLED`, combined with a `targetType` of
// `LINE_ITEM`, applies the discount on all line items that are entitled to the discount.
// The value `ALL`, combined with a `targetType` of `SHIPPING_LINE`, applies the discount on all shipping lines.
type DiscountApplicationTargetSelection string

const (
	// The discount is allocated onto all the lines.
	DiscountApplicationTargetSelectionAll DiscountApplicationTargetSelection = "ALL"
	// The discount is allocated onto only the lines that it's entitled for.
	DiscountApplicationTargetSelectionEntitled DiscountApplicationTargetSelection = "ENTITLED"
	// The discount is allocated onto explicitly chosen lines.
	DiscountApplicationTargetSelectionExplicit DiscountApplicationTargetSelection = "EXPLICIT"
)

var AllDiscountApplicationTargetSelection = []DiscountApplicationTargetSelection{
	DiscountApplicationTargetSelectionAll,
	DiscountApplicationTargetSelectionEntitled,
	DiscountApplicationTargetSelectionExplicit,
}

func (e DiscountApplicationTargetSelection) IsValid() bool {
	switch e {
	case DiscountApplicationTargetSelectionAll, DiscountApplicationTargetSelectionEntitled, DiscountApplicationTargetSelectionExplicit:
		return true
	}
	return false
}

func (e DiscountApplicationTargetSelection) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetSelection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetSelection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetSelection", str)
	}
	return nil
}

func (e DiscountApplicationTargetSelection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DiscountApplicationTargetSelection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DiscountApplicationTargetSelection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
type DiscountApplicationTargetType string

const (
	// The discount applies onto line items.
	DiscountApplicationTargetTypeLineItem DiscountApplicationTargetType = "LINE_ITEM"
	// The discount applies onto shipping lines.
	DiscountApplicationTargetTypeShippingLine DiscountApplicationTargetType = "SHIPPING_LINE"
)

var AllDiscountApplicationTargetType = []DiscountApplicationTargetType{
	DiscountApplicationTargetTypeLineItem,
	DiscountApplicationTargetTypeShippingLine,
}

func (e DiscountApplicationTargetType) IsValid() bool {
	switch e {
	case DiscountApplicationTargetTypeLineItem, DiscountApplicationTargetTypeShippingLine:
		return true
	}
	return false
}

func (e DiscountApplicationTargetType) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetType", str)
	}
	return nil
}

func (e DiscountApplicationTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DiscountApplicationTargetType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DiscountApplicationTargetType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Defines how to present the filter values, specifies the presentation of the filter.
type FilterPresentation string

const (
	// Image presentation, filter values display an image.
	FilterPresentationImage FilterPresentation = "IMAGE"
	// Swatch presentation, filter values display color or image patterns.
	FilterPresentationSwatch FilterPresentation = "SWATCH"
	// Text presentation, no additional visual display for filter values.
	FilterPresentationText FilterPresentation = "TEXT"
)

var AllFilterPresentation = []FilterPresentation{
	FilterPresentationImage,
	FilterPresentationSwatch,
	FilterPresentationText,
}

func (e FilterPresentation) IsValid() bool {
	switch e {
	case FilterPresentationImage, FilterPresentationSwatch, FilterPresentationText:
		return true
	}
	return false
}

func (e FilterPresentation) String() string {
	return string(e)
}

func (e *FilterPresentation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterPresentation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterPresentation", str)
	}
	return nil
}

func (e FilterPresentation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilterPresentation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilterPresentation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The type of data that the filter group represents.
//
// For more information, refer to [Filter products in a collection with the Storefront API]
// (https://shopify.dev/custom-storefronts/products-collections/filter-products).
type FilterType string

const (
	// A boolean value.
	FilterTypeBoolean FilterType = "BOOLEAN"
	// A list of selectable values.
	FilterTypeList FilterType = "LIST"
	// A range of prices.
	FilterTypePriceRange FilterType = "PRICE_RANGE"
)

var AllFilterType = []FilterType{
	FilterTypeBoolean,
	FilterTypeList,
	FilterTypePriceRange,
}

func (e FilterType) IsValid() bool {
	switch e {
	case FilterTypeBoolean, FilterTypeList, FilterTypePriceRange:
		return true
	}
	return false
}

func (e FilterType) String() string {
	return string(e)
}

func (e *FilterType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterType", str)
	}
	return nil
}

func (e FilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilterType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilterType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// List of supported image content types.
type ImageContentType string

const (
	// A JPG image.
	ImageContentTypeJpg ImageContentType = "JPG"
	// A PNG image.
	ImageContentTypePng ImageContentType = "PNG"
	// A WEBP image.
	ImageContentTypeWebp ImageContentType = "WEBP"
)

var AllImageContentType = []ImageContentType{
	ImageContentTypeJpg,
	ImageContentTypePng,
	ImageContentTypeWebp,
}

func (e ImageContentType) IsValid() bool {
	switch e {
	case ImageContentTypeJpg, ImageContentTypePng, ImageContentTypeWebp:
		return true
	}
	return false
}

func (e ImageContentType) String() string {
	return string(e)
}

func (e *ImageContentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageContentType", str)
	}
	return nil
}

func (e ImageContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageContentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageContentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Language codes supported by Shopify.
type LanguageCode string

const (
	// Afrikaans.
	LanguageCodeAf LanguageCode = "AF"
	// Akan.
	LanguageCodeAk LanguageCode = "AK"
	// Amharic.
	LanguageCodeAm LanguageCode = "AM"
	// Arabic.
	LanguageCodeAr LanguageCode = "AR"
	// Assamese.
	LanguageCodeAs LanguageCode = "AS"
	// Azerbaijani.
	LanguageCodeAz LanguageCode = "AZ"
	// Belarusian.
	LanguageCodeBe LanguageCode = "BE"
	// Bulgarian.
	LanguageCodeBg LanguageCode = "BG"
	// Bambara.
	LanguageCodeBm LanguageCode = "BM"
	// Bangla.
	LanguageCodeBn LanguageCode = "BN"
	// Tibetan.
	LanguageCodeBo LanguageCode = "BO"
	// Breton.
	LanguageCodeBr LanguageCode = "BR"
	// Bosnian.
	LanguageCodeBs LanguageCode = "BS"
	// Catalan.
	LanguageCodeCa LanguageCode = "CA"
	// Chechen.
	LanguageCodeCe LanguageCode = "CE"
	// Central Kurdish.
	LanguageCodeCkb LanguageCode = "CKB"
	// Czech.
	LanguageCodeCs LanguageCode = "CS"
	// Church Slavic.
	LanguageCodeCu LanguageCode = "CU"
	// Welsh.
	LanguageCodeCy LanguageCode = "CY"
	// Danish.
	LanguageCodeDa LanguageCode = "DA"
	// German.
	LanguageCodeDe LanguageCode = "DE"
	// Dzongkha.
	LanguageCodeDz LanguageCode = "DZ"
	// Ewe.
	LanguageCodeEe LanguageCode = "EE"
	// Greek.
	LanguageCodeEl LanguageCode = "EL"
	// English.
	LanguageCodeEn LanguageCode = "EN"
	// Esperanto.
	LanguageCodeEo LanguageCode = "EO"
	// Spanish.
	LanguageCodeEs LanguageCode = "ES"
	// Estonian.
	LanguageCodeEt LanguageCode = "ET"
	// Basque.
	LanguageCodeEu LanguageCode = "EU"
	// Persian.
	LanguageCodeFa LanguageCode = "FA"
	// Fulah.
	LanguageCodeFf LanguageCode = "FF"
	// Finnish.
	LanguageCodeFi LanguageCode = "FI"
	// Filipino.
	LanguageCodeFil LanguageCode = "FIL"
	// Faroese.
	LanguageCodeFo LanguageCode = "FO"
	// French.
	LanguageCodeFr LanguageCode = "FR"
	// Western Frisian.
	LanguageCodeFy LanguageCode = "FY"
	// Irish.
	LanguageCodeGa LanguageCode = "GA"
	// Scottish Gaelic.
	LanguageCodeGd LanguageCode = "GD"
	// Galician.
	LanguageCodeGl LanguageCode = "GL"
	// Gujarati.
	LanguageCodeGu LanguageCode = "GU"
	// Manx.
	LanguageCodeGv LanguageCode = "GV"
	// Hausa.
	LanguageCodeHa LanguageCode = "HA"
	// Hebrew.
	LanguageCodeHe LanguageCode = "HE"
	// Hindi.
	LanguageCodeHi LanguageCode = "HI"
	// Croatian.
	LanguageCodeHr LanguageCode = "HR"
	// Hungarian.
	LanguageCodeHu LanguageCode = "HU"
	// Armenian.
	LanguageCodeHy LanguageCode = "HY"
	// Interlingua.
	LanguageCodeIa LanguageCode = "IA"
	// Indonesian.
	LanguageCodeID LanguageCode = "ID"
	// Igbo.
	LanguageCodeIg LanguageCode = "IG"
	// Sichuan Yi.
	LanguageCodeIi LanguageCode = "II"
	// Icelandic.
	LanguageCodeIs LanguageCode = "IS"
	// Italian.
	LanguageCodeIt LanguageCode = "IT"
	// Japanese.
	LanguageCodeJa LanguageCode = "JA"
	// Javanese.
	LanguageCodeJv LanguageCode = "JV"
	// Georgian.
	LanguageCodeKa LanguageCode = "KA"
	// Kikuyu.
	LanguageCodeKi LanguageCode = "KI"
	// Kazakh.
	LanguageCodeKk LanguageCode = "KK"
	// Kalaallisut.
	LanguageCodeKl LanguageCode = "KL"
	// Khmer.
	LanguageCodeKm LanguageCode = "KM"
	// Kannada.
	LanguageCodeKn LanguageCode = "KN"
	// Korean.
	LanguageCodeKo LanguageCode = "KO"
	// Kashmiri.
	LanguageCodeKs LanguageCode = "KS"
	// Kurdish.
	LanguageCodeKu LanguageCode = "KU"
	// Cornish.
	LanguageCodeKw LanguageCode = "KW"
	// Kyrgyz.
	LanguageCodeKy LanguageCode = "KY"
	// Latin.
	LanguageCodeLa LanguageCode = "LA"
	// Luxembourgish.
	LanguageCodeLb LanguageCode = "LB"
	// Ganda.
	LanguageCodeLg LanguageCode = "LG"
	// Lingala.
	LanguageCodeLn LanguageCode = "LN"
	// Lao.
	LanguageCodeLo LanguageCode = "LO"
	// Lithuanian.
	LanguageCodeLt LanguageCode = "LT"
	// Luba-Katanga.
	LanguageCodeLu LanguageCode = "LU"
	// Latvian.
	LanguageCodeLv LanguageCode = "LV"
	// Malagasy.
	LanguageCodeMg LanguageCode = "MG"
	// Māori.
	LanguageCodeMi LanguageCode = "MI"
	// Macedonian.
	LanguageCodeMk LanguageCode = "MK"
	// Malayalam.
	LanguageCodeMl LanguageCode = "ML"
	// Mongolian.
	LanguageCodeMn LanguageCode = "MN"
	// Moldavian.
	LanguageCodeMo LanguageCode = "MO"
	// Marathi.
	LanguageCodeMr LanguageCode = "MR"
	// Malay.
	LanguageCodeMs LanguageCode = "MS"
	// Maltese.
	LanguageCodeMt LanguageCode = "MT"
	// Burmese.
	LanguageCodeMy LanguageCode = "MY"
	// Norwegian (Bokmål).
	LanguageCodeNb LanguageCode = "NB"
	// North Ndebele.
	LanguageCodeNd LanguageCode = "ND"
	// Nepali.
	LanguageCodeNe LanguageCode = "NE"
	// Dutch.
	LanguageCodeNl LanguageCode = "NL"
	// Norwegian Nynorsk.
	LanguageCodeNn LanguageCode = "NN"
	// Norwegian.
	LanguageCodeNo LanguageCode = "NO"
	// Oromo.
	LanguageCodeOm LanguageCode = "OM"
	// Odia.
	LanguageCodeOr LanguageCode = "OR"
	// Ossetic.
	LanguageCodeOs LanguageCode = "OS"
	// Punjabi.
	LanguageCodePa LanguageCode = "PA"
	// Polish.
	LanguageCodePl LanguageCode = "PL"
	// Pashto.
	LanguageCodePs LanguageCode = "PS"
	// Portuguese.
	LanguageCodePt LanguageCode = "PT"
	// Portuguese (Brazil).
	LanguageCodePtBr LanguageCode = "PT_BR"
	// Portuguese (Portugal).
	LanguageCodePtPt LanguageCode = "PT_PT"
	// Quechua.
	LanguageCodeQu LanguageCode = "QU"
	// Romansh.
	LanguageCodeRm LanguageCode = "RM"
	// Rundi.
	LanguageCodeRn LanguageCode = "RN"
	// Romanian.
	LanguageCodeRo LanguageCode = "RO"
	// Russian.
	LanguageCodeRu LanguageCode = "RU"
	// Kinyarwanda.
	LanguageCodeRw LanguageCode = "RW"
	// Sanskrit.
	LanguageCodeSa LanguageCode = "SA"
	// Sardinian.
	LanguageCodeSc LanguageCode = "SC"
	// Sindhi.
	LanguageCodeSd LanguageCode = "SD"
	// Northern Sami.
	LanguageCodeSe LanguageCode = "SE"
	// Sango.
	LanguageCodeSg LanguageCode = "SG"
	// Serbo-Croatian.
	LanguageCodeSh LanguageCode = "SH"
	// Sinhala.
	LanguageCodeSi LanguageCode = "SI"
	// Slovak.
	LanguageCodeSk LanguageCode = "SK"
	// Slovenian.
	LanguageCodeSl LanguageCode = "SL"
	// Shona.
	LanguageCodeSn LanguageCode = "SN"
	// Somali.
	LanguageCodeSo LanguageCode = "SO"
	// Albanian.
	LanguageCodeSq LanguageCode = "SQ"
	// Serbian.
	LanguageCodeSr LanguageCode = "SR"
	// Sundanese.
	LanguageCodeSu LanguageCode = "SU"
	// Swedish.
	LanguageCodeSv LanguageCode = "SV"
	// Swahili.
	LanguageCodeSw LanguageCode = "SW"
	// Tamil.
	LanguageCodeTa LanguageCode = "TA"
	// Telugu.
	LanguageCodeTe LanguageCode = "TE"
	// Tajik.
	LanguageCodeTg LanguageCode = "TG"
	// Thai.
	LanguageCodeTh LanguageCode = "TH"
	// Tigrinya.
	LanguageCodeTi LanguageCode = "TI"
	// Turkmen.
	LanguageCodeTk LanguageCode = "TK"
	// Tongan.
	LanguageCodeTo LanguageCode = "TO"
	// Turkish.
	LanguageCodeTr LanguageCode = "TR"
	// Tatar.
	LanguageCodeTt LanguageCode = "TT"
	// Uyghur.
	LanguageCodeUg LanguageCode = "UG"
	// Ukrainian.
	LanguageCodeUk LanguageCode = "UK"
	// Urdu.
	LanguageCodeUr LanguageCode = "UR"
	// Uzbek.
	LanguageCodeUz LanguageCode = "UZ"
	// Vietnamese.
	LanguageCodeVi LanguageCode = "VI"
	// Volapük.
	LanguageCodeVo LanguageCode = "VO"
	// Wolof.
	LanguageCodeWo LanguageCode = "WO"
	// Xhosa.
	LanguageCodeXh LanguageCode = "XH"
	// Yiddish.
	LanguageCodeYi LanguageCode = "YI"
	// Yoruba.
	LanguageCodeYo LanguageCode = "YO"
	// Chinese.
	LanguageCodeZh LanguageCode = "ZH"
	// Chinese (Simplified).
	LanguageCodeZhCn LanguageCode = "ZH_CN"
	// Chinese (Traditional).
	LanguageCodeZhTw LanguageCode = "ZH_TW"
	// Zulu.
	LanguageCodeZu LanguageCode = "ZU"
)

var AllLanguageCode = []LanguageCode{
	LanguageCodeAf,
	LanguageCodeAk,
	LanguageCodeAm,
	LanguageCodeAr,
	LanguageCodeAs,
	LanguageCodeAz,
	LanguageCodeBe,
	LanguageCodeBg,
	LanguageCodeBm,
	LanguageCodeBn,
	LanguageCodeBo,
	LanguageCodeBr,
	LanguageCodeBs,
	LanguageCodeCa,
	LanguageCodeCe,
	LanguageCodeCkb,
	LanguageCodeCs,
	LanguageCodeCu,
	LanguageCodeCy,
	LanguageCodeDa,
	LanguageCodeDe,
	LanguageCodeDz,
	LanguageCodeEe,
	LanguageCodeEl,
	LanguageCodeEn,
	LanguageCodeEo,
	LanguageCodeEs,
	LanguageCodeEt,
	LanguageCodeEu,
	LanguageCodeFa,
	LanguageCodeFf,
	LanguageCodeFi,
	LanguageCodeFil,
	LanguageCodeFo,
	LanguageCodeFr,
	LanguageCodeFy,
	LanguageCodeGa,
	LanguageCodeGd,
	LanguageCodeGl,
	LanguageCodeGu,
	LanguageCodeGv,
	LanguageCodeHa,
	LanguageCodeHe,
	LanguageCodeHi,
	LanguageCodeHr,
	LanguageCodeHu,
	LanguageCodeHy,
	LanguageCodeIa,
	LanguageCodeID,
	LanguageCodeIg,
	LanguageCodeIi,
	LanguageCodeIs,
	LanguageCodeIt,
	LanguageCodeJa,
	LanguageCodeJv,
	LanguageCodeKa,
	LanguageCodeKi,
	LanguageCodeKk,
	LanguageCodeKl,
	LanguageCodeKm,
	LanguageCodeKn,
	LanguageCodeKo,
	LanguageCodeKs,
	LanguageCodeKu,
	LanguageCodeKw,
	LanguageCodeKy,
	LanguageCodeLa,
	LanguageCodeLb,
	LanguageCodeLg,
	LanguageCodeLn,
	LanguageCodeLo,
	LanguageCodeLt,
	LanguageCodeLu,
	LanguageCodeLv,
	LanguageCodeMg,
	LanguageCodeMi,
	LanguageCodeMk,
	LanguageCodeMl,
	LanguageCodeMn,
	LanguageCodeMo,
	LanguageCodeMr,
	LanguageCodeMs,
	LanguageCodeMt,
	LanguageCodeMy,
	LanguageCodeNb,
	LanguageCodeNd,
	LanguageCodeNe,
	LanguageCodeNl,
	LanguageCodeNn,
	LanguageCodeNo,
	LanguageCodeOm,
	LanguageCodeOr,
	LanguageCodeOs,
	LanguageCodePa,
	LanguageCodePl,
	LanguageCodePs,
	LanguageCodePt,
	LanguageCodePtBr,
	LanguageCodePtPt,
	LanguageCodeQu,
	LanguageCodeRm,
	LanguageCodeRn,
	LanguageCodeRo,
	LanguageCodeRu,
	LanguageCodeRw,
	LanguageCodeSa,
	LanguageCodeSc,
	LanguageCodeSd,
	LanguageCodeSe,
	LanguageCodeSg,
	LanguageCodeSh,
	LanguageCodeSi,
	LanguageCodeSk,
	LanguageCodeSl,
	LanguageCodeSn,
	LanguageCodeSo,
	LanguageCodeSq,
	LanguageCodeSr,
	LanguageCodeSu,
	LanguageCodeSv,
	LanguageCodeSw,
	LanguageCodeTa,
	LanguageCodeTe,
	LanguageCodeTg,
	LanguageCodeTh,
	LanguageCodeTi,
	LanguageCodeTk,
	LanguageCodeTo,
	LanguageCodeTr,
	LanguageCodeTt,
	LanguageCodeUg,
	LanguageCodeUk,
	LanguageCodeUr,
	LanguageCodeUz,
	LanguageCodeVi,
	LanguageCodeVo,
	LanguageCodeWo,
	LanguageCodeXh,
	LanguageCodeYi,
	LanguageCodeYo,
	LanguageCodeZh,
	LanguageCodeZhCn,
	LanguageCodeZhTw,
	LanguageCodeZu,
}

func (e LanguageCode) IsValid() bool {
	switch e {
	case LanguageCodeAf, LanguageCodeAk, LanguageCodeAm, LanguageCodeAr, LanguageCodeAs, LanguageCodeAz, LanguageCodeBe, LanguageCodeBg, LanguageCodeBm, LanguageCodeBn, LanguageCodeBo, LanguageCodeBr, LanguageCodeBs, LanguageCodeCa, LanguageCodeCe, LanguageCodeCkb, LanguageCodeCs, LanguageCodeCu, LanguageCodeCy, LanguageCodeDa, LanguageCodeDe, LanguageCodeDz, LanguageCodeEe, LanguageCodeEl, LanguageCodeEn, LanguageCodeEo, LanguageCodeEs, LanguageCodeEt, LanguageCodeEu, LanguageCodeFa, LanguageCodeFf, LanguageCodeFi, LanguageCodeFil, LanguageCodeFo, LanguageCodeFr, LanguageCodeFy, LanguageCodeGa, LanguageCodeGd, LanguageCodeGl, LanguageCodeGu, LanguageCodeGv, LanguageCodeHa, LanguageCodeHe, LanguageCodeHi, LanguageCodeHr, LanguageCodeHu, LanguageCodeHy, LanguageCodeIa, LanguageCodeID, LanguageCodeIg, LanguageCodeIi, LanguageCodeIs, LanguageCodeIt, LanguageCodeJa, LanguageCodeJv, LanguageCodeKa, LanguageCodeKi, LanguageCodeKk, LanguageCodeKl, LanguageCodeKm, LanguageCodeKn, LanguageCodeKo, LanguageCodeKs, LanguageCodeKu, LanguageCodeKw, LanguageCodeKy, LanguageCodeLa, LanguageCodeLb, LanguageCodeLg, LanguageCodeLn, LanguageCodeLo, LanguageCodeLt, LanguageCodeLu, LanguageCodeLv, LanguageCodeMg, LanguageCodeMi, LanguageCodeMk, LanguageCodeMl, LanguageCodeMn, LanguageCodeMo, LanguageCodeMr, LanguageCodeMs, LanguageCodeMt, LanguageCodeMy, LanguageCodeNb, LanguageCodeNd, LanguageCodeNe, LanguageCodeNl, LanguageCodeNn, LanguageCodeNo, LanguageCodeOm, LanguageCodeOr, LanguageCodeOs, LanguageCodePa, LanguageCodePl, LanguageCodePs, LanguageCodePt, LanguageCodePtBr, LanguageCodePtPt, LanguageCodeQu, LanguageCodeRm, LanguageCodeRn, LanguageCodeRo, LanguageCodeRu, LanguageCodeRw, LanguageCodeSa, LanguageCodeSc, LanguageCodeSd, LanguageCodeSe, LanguageCodeSg, LanguageCodeSh, LanguageCodeSi, LanguageCodeSk, LanguageCodeSl, LanguageCodeSn, LanguageCodeSo, LanguageCodeSq, LanguageCodeSr, LanguageCodeSu, LanguageCodeSv, LanguageCodeSw, LanguageCodeTa, LanguageCodeTe, LanguageCodeTg, LanguageCodeTh, LanguageCodeTi, LanguageCodeTk, LanguageCodeTo, LanguageCodeTr, LanguageCodeTt, LanguageCodeUg, LanguageCodeUk, LanguageCodeUr, LanguageCodeUz, LanguageCodeVi, LanguageCodeVo, LanguageCodeWo, LanguageCodeXh, LanguageCodeYi, LanguageCodeYo, LanguageCodeZh, LanguageCodeZhCn, LanguageCodeZhTw, LanguageCodeZu:
		return true
	}
	return false
}

func (e LanguageCode) String() string {
	return string(e)
}

func (e *LanguageCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LanguageCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LanguageCode", str)
	}
	return nil
}

func (e LanguageCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LanguageCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LanguageCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Location query.
type LocationSortKeys string

const (
	// Sort by the `city` value.
	LocationSortKeysCity LocationSortKeys = "CITY"
	// Sort by the `distance` value.
	LocationSortKeysDistance LocationSortKeys = "DISTANCE"
	// Sort by the `id` value.
	LocationSortKeysID LocationSortKeys = "ID"
	// Sort by the `name` value.
	LocationSortKeysName LocationSortKeys = "NAME"
)

var AllLocationSortKeys = []LocationSortKeys{
	LocationSortKeysCity,
	LocationSortKeysDistance,
	LocationSortKeysID,
	LocationSortKeysName,
}

func (e LocationSortKeys) IsValid() bool {
	switch e {
	case LocationSortKeysCity, LocationSortKeysDistance, LocationSortKeysID, LocationSortKeysName:
		return true
	}
	return false
}

func (e LocationSortKeys) String() string {
	return string(e)
}

func (e *LocationSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationSortKeys", str)
	}
	return nil
}

func (e LocationSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LocationSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LocationSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The possible content types for a media object.
type MediaContentType string

const (
	// An externally hosted video.
	MediaContentTypeExternalVideo MediaContentType = "EXTERNAL_VIDEO"
	// A Shopify hosted image.
	MediaContentTypeImage MediaContentType = "IMAGE"
	// A 3d model.
	MediaContentTypeModel3d MediaContentType = "MODEL_3D"
	// A Shopify hosted video.
	MediaContentTypeVideo MediaContentType = "VIDEO"
)

var AllMediaContentType = []MediaContentType{
	MediaContentTypeExternalVideo,
	MediaContentTypeImage,
	MediaContentTypeModel3d,
	MediaContentTypeVideo,
}

func (e MediaContentType) IsValid() bool {
	switch e {
	case MediaContentTypeExternalVideo, MediaContentTypeImage, MediaContentTypeModel3d, MediaContentTypeVideo:
		return true
	}
	return false
}

func (e MediaContentType) String() string {
	return string(e)
}

func (e *MediaContentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaContentType", str)
	}
	return nil
}

func (e MediaContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaContentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaContentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Host for a Media Resource.
type MediaHost string

const (
	// Host for Vimeo embedded videos.
	MediaHostVimeo MediaHost = "VIMEO"
	// Host for YouTube embedded videos.
	MediaHostYoutube MediaHost = "YOUTUBE"
)

var AllMediaHost = []MediaHost{
	MediaHostVimeo,
	MediaHostYoutube,
}

func (e MediaHost) IsValid() bool {
	switch e {
	case MediaHostVimeo, MediaHostYoutube:
		return true
	}
	return false
}

func (e MediaHost) String() string {
	return string(e)
}

func (e *MediaHost) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaHost(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaHost", str)
	}
	return nil
}

func (e MediaHost) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaHost) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaHost) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The possible formats for a media presentation.
type MediaPresentationFormat string

const (
	// A media image presentation.
	MediaPresentationFormatImage MediaPresentationFormat = "IMAGE"
	// A model viewer presentation.
	MediaPresentationFormatModelViewer MediaPresentationFormat = "MODEL_VIEWER"
)

var AllMediaPresentationFormat = []MediaPresentationFormat{
	MediaPresentationFormatImage,
	MediaPresentationFormatModelViewer,
}

func (e MediaPresentationFormat) IsValid() bool {
	switch e {
	case MediaPresentationFormatImage, MediaPresentationFormatModelViewer:
		return true
	}
	return false
}

func (e MediaPresentationFormat) String() string {
	return string(e)
}

func (e *MediaPresentationFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaPresentationFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaPresentationFormat", str)
	}
	return nil
}

func (e MediaPresentationFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaPresentationFormat) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaPresentationFormat) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// A menu item type.
type MenuItemType string

const (
	// An article link.
	MenuItemTypeArticle MenuItemType = "ARTICLE"
	// A blog link.
	MenuItemTypeBlog MenuItemType = "BLOG"
	// A catalog link.
	MenuItemTypeCatalog MenuItemType = "CATALOG"
	// A collection link.
	MenuItemTypeCollection MenuItemType = "COLLECTION"
	// A collection link.
	MenuItemTypeCollections MenuItemType = "COLLECTIONS"
	// A customer account page link.
	MenuItemTypeCustomerAccountPage MenuItemType = "CUSTOMER_ACCOUNT_PAGE"
	// A frontpage link.
	MenuItemTypeFrontpage MenuItemType = "FRONTPAGE"
	// An http link.
	MenuItemTypeHTTP MenuItemType = "HTTP"
	// A metaobject page link.
	MenuItemTypeMetaobject MenuItemType = "METAOBJECT"
	// A page link.
	MenuItemTypePage MenuItemType = "PAGE"
	// A product link.
	MenuItemTypeProduct MenuItemType = "PRODUCT"
	// A search link.
	MenuItemTypeSearch MenuItemType = "SEARCH"
	// A shop policy link.
	MenuItemTypeShopPolicy MenuItemType = "SHOP_POLICY"
)

var AllMenuItemType = []MenuItemType{
	MenuItemTypeArticle,
	MenuItemTypeBlog,
	MenuItemTypeCatalog,
	MenuItemTypeCollection,
	MenuItemTypeCollections,
	MenuItemTypeCustomerAccountPage,
	MenuItemTypeFrontpage,
	MenuItemTypeHTTP,
	MenuItemTypeMetaobject,
	MenuItemTypePage,
	MenuItemTypeProduct,
	MenuItemTypeSearch,
	MenuItemTypeShopPolicy,
}

func (e MenuItemType) IsValid() bool {
	switch e {
	case MenuItemTypeArticle, MenuItemTypeBlog, MenuItemTypeCatalog, MenuItemTypeCollection, MenuItemTypeCollections, MenuItemTypeCustomerAccountPage, MenuItemTypeFrontpage, MenuItemTypeHTTP, MenuItemTypeMetaobject, MenuItemTypePage, MenuItemTypeProduct, MenuItemTypeSearch, MenuItemTypeShopPolicy:
		return true
	}
	return false
}

func (e MenuItemType) String() string {
	return string(e)
}

func (e *MenuItemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MenuItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MenuItemType", str)
	}
	return nil
}

func (e MenuItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MenuItemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MenuItemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `MetafieldDeleteUserError`.
type MetafieldDeleteErrorCode string

const (
	// The owner ID is invalid.
	MetafieldDeleteErrorCodeInvalidOwner MetafieldDeleteErrorCode = "INVALID_OWNER"
	// Metafield not found.
	MetafieldDeleteErrorCodeMetafieldDoesNotExist MetafieldDeleteErrorCode = "METAFIELD_DOES_NOT_EXIST"
)

var AllMetafieldDeleteErrorCode = []MetafieldDeleteErrorCode{
	MetafieldDeleteErrorCodeInvalidOwner,
	MetafieldDeleteErrorCodeMetafieldDoesNotExist,
}

func (e MetafieldDeleteErrorCode) IsValid() bool {
	switch e {
	case MetafieldDeleteErrorCodeInvalidOwner, MetafieldDeleteErrorCodeMetafieldDoesNotExist:
		return true
	}
	return false
}

func (e MetafieldDeleteErrorCode) String() string {
	return string(e)
}

func (e *MetafieldDeleteErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetafieldDeleteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetafieldDeleteErrorCode", str)
	}
	return nil
}

func (e MetafieldDeleteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetafieldDeleteErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetafieldDeleteErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `MetafieldsSetUserError`.
type MetafieldsSetUserErrorCode string

const (
	// The input value is blank.
	MetafieldsSetUserErrorCodeBlank MetafieldsSetUserErrorCode = "BLANK"
	// The input value isn't included in the list.
	MetafieldsSetUserErrorCodeInclusion MetafieldsSetUserErrorCode = "INCLUSION"
	// The owner ID is invalid.
	MetafieldsSetUserErrorCodeInvalidOwner MetafieldsSetUserErrorCode = "INVALID_OWNER"
	// The type is invalid.
	MetafieldsSetUserErrorCodeInvalidType MetafieldsSetUserErrorCode = "INVALID_TYPE"
	// The value is invalid for metafield type or for definition options.
	MetafieldsSetUserErrorCodeInvalidValue MetafieldsSetUserErrorCode = "INVALID_VALUE"
	// The input value should be less than or equal to the maximum value allowed.
	MetafieldsSetUserErrorCodeLessThanOrEqualTo MetafieldsSetUserErrorCode = "LESS_THAN_OR_EQUAL_TO"
	// The input value needs to be blank.
	MetafieldsSetUserErrorCodePresent MetafieldsSetUserErrorCode = "PRESENT"
	// The input value is too long.
	MetafieldsSetUserErrorCodeTooLong MetafieldsSetUserErrorCode = "TOO_LONG"
	// The input value is too short.
	MetafieldsSetUserErrorCodeTooShort MetafieldsSetUserErrorCode = "TOO_SHORT"
)

var AllMetafieldsSetUserErrorCode = []MetafieldsSetUserErrorCode{
	MetafieldsSetUserErrorCodeBlank,
	MetafieldsSetUserErrorCodeInclusion,
	MetafieldsSetUserErrorCodeInvalidOwner,
	MetafieldsSetUserErrorCodeInvalidType,
	MetafieldsSetUserErrorCodeInvalidValue,
	MetafieldsSetUserErrorCodeLessThanOrEqualTo,
	MetafieldsSetUserErrorCodePresent,
	MetafieldsSetUserErrorCodeTooLong,
	MetafieldsSetUserErrorCodeTooShort,
}

func (e MetafieldsSetUserErrorCode) IsValid() bool {
	switch e {
	case MetafieldsSetUserErrorCodeBlank, MetafieldsSetUserErrorCodeInclusion, MetafieldsSetUserErrorCodeInvalidOwner, MetafieldsSetUserErrorCodeInvalidType, MetafieldsSetUserErrorCodeInvalidValue, MetafieldsSetUserErrorCodeLessThanOrEqualTo, MetafieldsSetUserErrorCodePresent, MetafieldsSetUserErrorCodeTooLong, MetafieldsSetUserErrorCodeTooShort:
		return true
	}
	return false
}

func (e MetafieldsSetUserErrorCode) String() string {
	return string(e)
}

func (e *MetafieldsSetUserErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetafieldsSetUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetafieldsSetUserErrorCode", str)
	}
	return nil
}

func (e MetafieldsSetUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetafieldsSetUserErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetafieldsSetUserErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the reason for the order's cancellation.
type OrderCancelReason string

const (
	// The customer wanted to cancel the order.
	OrderCancelReasonCustomer OrderCancelReason = "CUSTOMER"
	// Payment was declined.
	OrderCancelReasonDeclined OrderCancelReason = "DECLINED"
	// The order was fraudulent.
	OrderCancelReasonFraud OrderCancelReason = "FRAUD"
	// There was insufficient inventory.
	OrderCancelReasonInventory OrderCancelReason = "INVENTORY"
	// The order was canceled for an unlisted reason.
	OrderCancelReasonOther OrderCancelReason = "OTHER"
	// Staff made an error.
	OrderCancelReasonStaff OrderCancelReason = "STAFF"
)

var AllOrderCancelReason = []OrderCancelReason{
	OrderCancelReasonCustomer,
	OrderCancelReasonDeclined,
	OrderCancelReasonFraud,
	OrderCancelReasonInventory,
	OrderCancelReasonOther,
	OrderCancelReasonStaff,
}

func (e OrderCancelReason) IsValid() bool {
	switch e {
	case OrderCancelReasonCustomer, OrderCancelReasonDeclined, OrderCancelReasonFraud, OrderCancelReasonInventory, OrderCancelReasonOther, OrderCancelReasonStaff:
		return true
	}
	return false
}

func (e OrderCancelReason) String() string {
	return string(e)
}

func (e *OrderCancelReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderCancelReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderCancelReason", str)
	}
	return nil
}

func (e OrderCancelReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderCancelReason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderCancelReason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the order's current financial status.
type OrderFinancialStatus string

const (
	// Displayed as **Authorized**.
	OrderFinancialStatusAuthorized OrderFinancialStatus = "AUTHORIZED"
	// Displayed as **Paid**.
	OrderFinancialStatusPaid OrderFinancialStatus = "PAID"
	// Displayed as **Partially paid**.
	OrderFinancialStatusPartiallyPaid OrderFinancialStatus = "PARTIALLY_PAID"
	// Displayed as **Partially refunded**.
	OrderFinancialStatusPartiallyRefunded OrderFinancialStatus = "PARTIALLY_REFUNDED"
	// Displayed as **Pending**.
	OrderFinancialStatusPending OrderFinancialStatus = "PENDING"
	// Displayed as **Refunded**.
	OrderFinancialStatusRefunded OrderFinancialStatus = "REFUNDED"
	// Displayed as **Voided**.
	OrderFinancialStatusVoided OrderFinancialStatus = "VOIDED"
)

var AllOrderFinancialStatus = []OrderFinancialStatus{
	OrderFinancialStatusAuthorized,
	OrderFinancialStatusPaid,
	OrderFinancialStatusPartiallyPaid,
	OrderFinancialStatusPartiallyRefunded,
	OrderFinancialStatusPending,
	OrderFinancialStatusRefunded,
	OrderFinancialStatusVoided,
}

func (e OrderFinancialStatus) IsValid() bool {
	switch e {
	case OrderFinancialStatusAuthorized, OrderFinancialStatusPaid, OrderFinancialStatusPartiallyPaid, OrderFinancialStatusPartiallyRefunded, OrderFinancialStatusPending, OrderFinancialStatusRefunded, OrderFinancialStatusVoided:
		return true
	}
	return false
}

func (e OrderFinancialStatus) String() string {
	return string(e)
}

func (e *OrderFinancialStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderFinancialStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderFinancialStatus", str)
	}
	return nil
}

func (e OrderFinancialStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderFinancialStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderFinancialStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the order's aggregated fulfillment status for display purposes.
type OrderFulfillmentStatus string

const (
	// Displayed as **Fulfilled**. All of the items in the order have been fulfilled.
	OrderFulfillmentStatusFulfilled OrderFulfillmentStatus = "FULFILLED"
	// Displayed as **In progress**. Some of the items in the order have been fulfilled, or a request for fulfillment has been sent to the fulfillment service.
	OrderFulfillmentStatusInProgress OrderFulfillmentStatus = "IN_PROGRESS"
	// Displayed as **On hold**. All of the unfulfilled items in this order are on hold.
	OrderFulfillmentStatusOnHold OrderFulfillmentStatus = "ON_HOLD"
	// Displayed as **Open**. None of the items in the order have been fulfilled. Replaced by "UNFULFILLED" status.
	OrderFulfillmentStatusOpen OrderFulfillmentStatus = "OPEN"
	// Displayed as **Partially fulfilled**. Some of the items in the order have been fulfilled.
	OrderFulfillmentStatusPartiallyFulfilled OrderFulfillmentStatus = "PARTIALLY_FULFILLED"
	// Displayed as **Pending fulfillment**. A request for fulfillment of some items awaits a response from the fulfillment service. Replaced by "IN_PROGRESS" status.
	OrderFulfillmentStatusPendingFulfillment OrderFulfillmentStatus = "PENDING_FULFILLMENT"
	// Displayed as **Ready for delivery**.
	OrderFulfillmentStatusReadyForDelivery OrderFulfillmentStatus = "READY_FOR_DELIVERY"
	// Displayed as **Restocked**. All of the items in the order have been restocked. Replaced by "UNFULFILLED" status.
	OrderFulfillmentStatusRestocked OrderFulfillmentStatus = "RESTOCKED"
	// Displayed as **Scheduled**. All of the unfulfilled items in this order are scheduled for fulfillment at later time.
	OrderFulfillmentStatusScheduled OrderFulfillmentStatus = "SCHEDULED"
	// Displayed as **Unfulfilled**. None of the items in the order have been fulfilled.
	OrderFulfillmentStatusUnfulfilled OrderFulfillmentStatus = "UNFULFILLED"
)

var AllOrderFulfillmentStatus = []OrderFulfillmentStatus{
	OrderFulfillmentStatusFulfilled,
	OrderFulfillmentStatusInProgress,
	OrderFulfillmentStatusOnHold,
	OrderFulfillmentStatusOpen,
	OrderFulfillmentStatusPartiallyFulfilled,
	OrderFulfillmentStatusPendingFulfillment,
	OrderFulfillmentStatusReadyForDelivery,
	OrderFulfillmentStatusRestocked,
	OrderFulfillmentStatusScheduled,
	OrderFulfillmentStatusUnfulfilled,
}

func (e OrderFulfillmentStatus) IsValid() bool {
	switch e {
	case OrderFulfillmentStatusFulfilled, OrderFulfillmentStatusInProgress, OrderFulfillmentStatusOnHold, OrderFulfillmentStatusOpen, OrderFulfillmentStatusPartiallyFulfilled, OrderFulfillmentStatusPendingFulfillment, OrderFulfillmentStatusReadyForDelivery, OrderFulfillmentStatusRestocked, OrderFulfillmentStatusScheduled, OrderFulfillmentStatusUnfulfilled:
		return true
	}
	return false
}

func (e OrderFulfillmentStatus) String() string {
	return string(e)
}

func (e *OrderFulfillmentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderFulfillmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderFulfillmentStatus", str)
	}
	return nil
}

func (e OrderFulfillmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderFulfillmentStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderFulfillmentStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Order query.
type OrderSortKeys string

const (
	// Sort by the `id` value.
	OrderSortKeysID OrderSortKeys = "ID"
	// Sort by the `processed_at` value.
	OrderSortKeysProcessedAt OrderSortKeys = "PROCESSED_AT"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	OrderSortKeysRelevance OrderSortKeys = "RELEVANCE"
	// Sort by the `total_price` value.
	OrderSortKeysTotalPrice OrderSortKeys = "TOTAL_PRICE"
)

var AllOrderSortKeys = []OrderSortKeys{
	OrderSortKeysID,
	OrderSortKeysProcessedAt,
	OrderSortKeysRelevance,
	OrderSortKeysTotalPrice,
}

func (e OrderSortKeys) IsValid() bool {
	switch e {
	case OrderSortKeysID, OrderSortKeysProcessedAt, OrderSortKeysRelevance, OrderSortKeysTotalPrice:
		return true
	}
	return false
}

func (e OrderSortKeys) String() string {
	return string(e)
}

func (e *OrderSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderSortKeys", str)
	}
	return nil
}

func (e OrderSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Page query.
type PageSortKeys string

const (
	// Sort by the `id` value.
	PageSortKeysID PageSortKeys = "ID"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	PageSortKeysRelevance PageSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	PageSortKeysTitle PageSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	PageSortKeysUpdatedAt PageSortKeys = "UPDATED_AT"
)

var AllPageSortKeys = []PageSortKeys{
	PageSortKeysID,
	PageSortKeysRelevance,
	PageSortKeysTitle,
	PageSortKeysUpdatedAt,
}

func (e PageSortKeys) IsValid() bool {
	switch e {
	case PageSortKeysID, PageSortKeysRelevance, PageSortKeysTitle, PageSortKeysUpdatedAt:
		return true
	}
	return false
}

func (e PageSortKeys) String() string {
	return string(e)
}

func (e *PageSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PageSortKeys", str)
	}
	return nil
}

func (e PageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PageSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PageSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The valid values for the types of payment token.
type PaymentTokenType string

const (
	// Apple Pay token type.
	PaymentTokenTypeApplePay PaymentTokenType = "APPLE_PAY"
	// Google Pay token type.
	PaymentTokenTypeGooglePay PaymentTokenType = "GOOGLE_PAY"
	// Shopify Pay token type.
	PaymentTokenTypeShopifyPay PaymentTokenType = "SHOPIFY_PAY"
	// Stripe token type.
	PaymentTokenTypeStripeVaultToken PaymentTokenType = "STRIPE_VAULT_TOKEN"
	// Vault payment token type.
	PaymentTokenTypeVault PaymentTokenType = "VAULT"
)

var AllPaymentTokenType = []PaymentTokenType{
	PaymentTokenTypeApplePay,
	PaymentTokenTypeGooglePay,
	PaymentTokenTypeShopifyPay,
	PaymentTokenTypeStripeVaultToken,
	PaymentTokenTypeVault,
}

func (e PaymentTokenType) IsValid() bool {
	switch e {
	case PaymentTokenTypeApplePay, PaymentTokenTypeGooglePay, PaymentTokenTypeShopifyPay, PaymentTokenTypeStripeVaultToken, PaymentTokenTypeVault:
		return true
	}
	return false
}

func (e PaymentTokenType) String() string {
	return string(e)
}

func (e *PaymentTokenType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentTokenType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentTokenType", str)
	}
	return nil
}

func (e PaymentTokenType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentTokenType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentTokenType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Decides the distribution of results.
type PredictiveSearchLimitScope string

const (
	// Return results up to limit across all types.
	PredictiveSearchLimitScopeAll PredictiveSearchLimitScope = "ALL"
	// Return results up to limit per type.
	PredictiveSearchLimitScopeEach PredictiveSearchLimitScope = "EACH"
)

var AllPredictiveSearchLimitScope = []PredictiveSearchLimitScope{
	PredictiveSearchLimitScopeAll,
	PredictiveSearchLimitScopeEach,
}

func (e PredictiveSearchLimitScope) IsValid() bool {
	switch e {
	case PredictiveSearchLimitScopeAll, PredictiveSearchLimitScopeEach:
		return true
	}
	return false
}

func (e PredictiveSearchLimitScope) String() string {
	return string(e)
}

func (e *PredictiveSearchLimitScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredictiveSearchLimitScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredictiveSearchLimitScope", str)
	}
	return nil
}

func (e PredictiveSearchLimitScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PredictiveSearchLimitScope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PredictiveSearchLimitScope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The types of search items to perform predictive search on.
type PredictiveSearchType string

const (
	// Returns matching articles.
	PredictiveSearchTypeArticle PredictiveSearchType = "ARTICLE"
	// Returns matching collections.
	PredictiveSearchTypeCollection PredictiveSearchType = "COLLECTION"
	// Returns matching pages.
	PredictiveSearchTypePage PredictiveSearchType = "PAGE"
	// Returns matching products.
	PredictiveSearchTypeProduct PredictiveSearchType = "PRODUCT"
	// Returns matching query strings.
	PredictiveSearchTypeQuery PredictiveSearchType = "QUERY"
)

var AllPredictiveSearchType = []PredictiveSearchType{
	PredictiveSearchTypeArticle,
	PredictiveSearchTypeCollection,
	PredictiveSearchTypePage,
	PredictiveSearchTypeProduct,
	PredictiveSearchTypeQuery,
}

func (e PredictiveSearchType) IsValid() bool {
	switch e {
	case PredictiveSearchTypeArticle, PredictiveSearchTypeCollection, PredictiveSearchTypePage, PredictiveSearchTypeProduct, PredictiveSearchTypeQuery:
		return true
	}
	return false
}

func (e PredictiveSearchType) String() string {
	return string(e)
}

func (e *PredictiveSearchType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredictiveSearchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredictiveSearchType", str)
	}
	return nil
}

func (e PredictiveSearchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PredictiveSearchType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PredictiveSearchType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The preferred delivery methods such as shipping, local pickup or through pickup points.
type PreferenceDeliveryMethodType string

const (
	// A delivery method used to let buyers collect purchases at designated locations like parcel lockers.
	PreferenceDeliveryMethodTypePickupPoint PreferenceDeliveryMethodType = "PICKUP_POINT"
	// A delivery method used to let buyers receive items directly from a specific location within an area.
	PreferenceDeliveryMethodTypePickUp PreferenceDeliveryMethodType = "PICK_UP"
	// A delivery method used to send items directly to a buyer’s specified address.
	PreferenceDeliveryMethodTypeShipping PreferenceDeliveryMethodType = "SHIPPING"
)

var AllPreferenceDeliveryMethodType = []PreferenceDeliveryMethodType{
	PreferenceDeliveryMethodTypePickupPoint,
	PreferenceDeliveryMethodTypePickUp,
	PreferenceDeliveryMethodTypeShipping,
}

func (e PreferenceDeliveryMethodType) IsValid() bool {
	switch e {
	case PreferenceDeliveryMethodTypePickupPoint, PreferenceDeliveryMethodTypePickUp, PreferenceDeliveryMethodTypeShipping:
		return true
	}
	return false
}

func (e PreferenceDeliveryMethodType) String() string {
	return string(e)
}

func (e *PreferenceDeliveryMethodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreferenceDeliveryMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PreferenceDeliveryMethodType", str)
	}
	return nil
}

func (e PreferenceDeliveryMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PreferenceDeliveryMethodType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PreferenceDeliveryMethodType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the ProductCollection query.
type ProductCollectionSortKeys string

const (
	// Sort by the `best-selling` value.
	ProductCollectionSortKeysBestSelling ProductCollectionSortKeys = "BEST_SELLING"
	// Sort by the `collection-default` value.
	ProductCollectionSortKeysCollectionDefault ProductCollectionSortKeys = "COLLECTION_DEFAULT"
	// Sort by the `created` value.
	ProductCollectionSortKeysCreated ProductCollectionSortKeys = "CREATED"
	// Sort by the `id` value.
	ProductCollectionSortKeysID ProductCollectionSortKeys = "ID"
	// Sort by the `manual` value.
	ProductCollectionSortKeysManual ProductCollectionSortKeys = "MANUAL"
	// Sort by the `price` value.
	ProductCollectionSortKeysPrice ProductCollectionSortKeys = "PRICE"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ProductCollectionSortKeysRelevance ProductCollectionSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	ProductCollectionSortKeysTitle ProductCollectionSortKeys = "TITLE"
)

var AllProductCollectionSortKeys = []ProductCollectionSortKeys{
	ProductCollectionSortKeysBestSelling,
	ProductCollectionSortKeysCollectionDefault,
	ProductCollectionSortKeysCreated,
	ProductCollectionSortKeysID,
	ProductCollectionSortKeysManual,
	ProductCollectionSortKeysPrice,
	ProductCollectionSortKeysRelevance,
	ProductCollectionSortKeysTitle,
}

func (e ProductCollectionSortKeys) IsValid() bool {
	switch e {
	case ProductCollectionSortKeysBestSelling, ProductCollectionSortKeysCollectionDefault, ProductCollectionSortKeysCreated, ProductCollectionSortKeysID, ProductCollectionSortKeysManual, ProductCollectionSortKeysPrice, ProductCollectionSortKeysRelevance, ProductCollectionSortKeysTitle:
		return true
	}
	return false
}

func (e ProductCollectionSortKeys) String() string {
	return string(e)
}

func (e *ProductCollectionSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductCollectionSortKeys", str)
	}
	return nil
}

func (e ProductCollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductCollectionSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductCollectionSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the ProductImage query.
type ProductImageSortKeys string

const (
	// Sort by the `created_at` value.
	ProductImageSortKeysCreatedAt ProductImageSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	ProductImageSortKeysID ProductImageSortKeys = "ID"
	// Sort by the `position` value.
	ProductImageSortKeysPosition ProductImageSortKeys = "POSITION"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ProductImageSortKeysRelevance ProductImageSortKeys = "RELEVANCE"
)

var AllProductImageSortKeys = []ProductImageSortKeys{
	ProductImageSortKeysCreatedAt,
	ProductImageSortKeysID,
	ProductImageSortKeysPosition,
	ProductImageSortKeysRelevance,
}

func (e ProductImageSortKeys) IsValid() bool {
	switch e {
	case ProductImageSortKeysCreatedAt, ProductImageSortKeysID, ProductImageSortKeysPosition, ProductImageSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductImageSortKeys) String() string {
	return string(e)
}

func (e *ProductImageSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductImageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductImageSortKeys", str)
	}
	return nil
}

func (e ProductImageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductImageSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductImageSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the ProductMedia query.
type ProductMediaSortKeys string

const (
	// Sort by the `id` value.
	ProductMediaSortKeysID ProductMediaSortKeys = "ID"
	// Sort by the `position` value.
	ProductMediaSortKeysPosition ProductMediaSortKeys = "POSITION"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ProductMediaSortKeysRelevance ProductMediaSortKeys = "RELEVANCE"
)

var AllProductMediaSortKeys = []ProductMediaSortKeys{
	ProductMediaSortKeysID,
	ProductMediaSortKeysPosition,
	ProductMediaSortKeysRelevance,
}

func (e ProductMediaSortKeys) IsValid() bool {
	switch e {
	case ProductMediaSortKeysID, ProductMediaSortKeysPosition, ProductMediaSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductMediaSortKeys) String() string {
	return string(e)
}

func (e *ProductMediaSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductMediaSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductMediaSortKeys", str)
	}
	return nil
}

func (e ProductMediaSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductMediaSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductMediaSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The recommendation intent that is used to generate product recommendations.
// You can use intent to generate product recommendations according to different strategies.
type ProductRecommendationIntent string

const (
	// Offer customers products that are complementary to a product for which recommendations are to be fetched. An example is add-on products that display in a Pair it with section.
	ProductRecommendationIntentComplementary ProductRecommendationIntent = "COMPLEMENTARY"
	// Offer customers a mix of products that are similar or complementary to a product for which recommendations are to be fetched. An example is substitutable products that display in a You may also like section.
	ProductRecommendationIntentRelated ProductRecommendationIntent = "RELATED"
)

var AllProductRecommendationIntent = []ProductRecommendationIntent{
	ProductRecommendationIntentComplementary,
	ProductRecommendationIntentRelated,
}

func (e ProductRecommendationIntent) IsValid() bool {
	switch e {
	case ProductRecommendationIntentComplementary, ProductRecommendationIntentRelated:
		return true
	}
	return false
}

func (e ProductRecommendationIntent) String() string {
	return string(e)
}

func (e *ProductRecommendationIntent) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductRecommendationIntent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductRecommendationIntent", str)
	}
	return nil
}

func (e ProductRecommendationIntent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductRecommendationIntent) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductRecommendationIntent) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the Product query.
type ProductSortKeys string

const (
	// Sort by the `best_selling` value.
	ProductSortKeysBestSelling ProductSortKeys = "BEST_SELLING"
	// Sort by the `created_at` value.
	ProductSortKeysCreatedAt ProductSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	ProductSortKeysID ProductSortKeys = "ID"
	// Sort by the `price` value.
	ProductSortKeysPrice ProductSortKeys = "PRICE"
	// Sort by the `product_type` value.
	ProductSortKeysProductType ProductSortKeys = "PRODUCT_TYPE"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ProductSortKeysRelevance ProductSortKeys = "RELEVANCE"
	// Sort by the `title` value.
	ProductSortKeysTitle ProductSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	ProductSortKeysUpdatedAt ProductSortKeys = "UPDATED_AT"
	// Sort by the `vendor` value.
	ProductSortKeysVendor ProductSortKeys = "VENDOR"
)

var AllProductSortKeys = []ProductSortKeys{
	ProductSortKeysBestSelling,
	ProductSortKeysCreatedAt,
	ProductSortKeysID,
	ProductSortKeysPrice,
	ProductSortKeysProductType,
	ProductSortKeysRelevance,
	ProductSortKeysTitle,
	ProductSortKeysUpdatedAt,
	ProductSortKeysVendor,
}

func (e ProductSortKeys) IsValid() bool {
	switch e {
	case ProductSortKeysBestSelling, ProductSortKeysCreatedAt, ProductSortKeysID, ProductSortKeysPrice, ProductSortKeysProductType, ProductSortKeysRelevance, ProductSortKeysTitle, ProductSortKeysUpdatedAt, ProductSortKeysVendor:
		return true
	}
	return false
}

func (e ProductSortKeys) String() string {
	return string(e)
}

func (e *ProductSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortKeys", str)
	}
	return nil
}

func (e ProductSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the ProductVariant query.
type ProductVariantSortKeys string

const (
	// Sort by the `id` value.
	ProductVariantSortKeysID ProductVariantSortKeys = "ID"
	// Sort by the `position` value.
	ProductVariantSortKeysPosition ProductVariantSortKeys = "POSITION"
	// Sort by relevance to the search terms when the `query` parameter is specified on the connection.
	// Don't use this sort key when no search query is specified.
	ProductVariantSortKeysRelevance ProductVariantSortKeys = "RELEVANCE"
	// Sort by the `sku` value.
	ProductVariantSortKeysSku ProductVariantSortKeys = "SKU"
	// Sort by the `title` value.
	ProductVariantSortKeysTitle ProductVariantSortKeys = "TITLE"
)

var AllProductVariantSortKeys = []ProductVariantSortKeys{
	ProductVariantSortKeysID,
	ProductVariantSortKeysPosition,
	ProductVariantSortKeysRelevance,
	ProductVariantSortKeysSku,
	ProductVariantSortKeysTitle,
}

func (e ProductVariantSortKeys) IsValid() bool {
	switch e {
	case ProductVariantSortKeysID, ProductVariantSortKeysPosition, ProductVariantSortKeysRelevance, ProductVariantSortKeysSku, ProductVariantSortKeysTitle:
		return true
	}
	return false
}

func (e ProductVariantSortKeys) String() string {
	return string(e)
}

func (e *ProductVariantSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductVariantSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductVariantSortKeys", str)
	}
	return nil
}

func (e ProductVariantSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProductVariantSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProductVariantSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Specifies whether to perform a partial word match on the last search term.
type SearchPrefixQueryType string

const (
	// Perform a partial word match on the last search term.
	SearchPrefixQueryTypeLast SearchPrefixQueryType = "LAST"
	// Don't perform a partial word match on the last search term.
	SearchPrefixQueryTypeNone SearchPrefixQueryType = "NONE"
)

var AllSearchPrefixQueryType = []SearchPrefixQueryType{
	SearchPrefixQueryTypeLast,
	SearchPrefixQueryTypeNone,
}

func (e SearchPrefixQueryType) IsValid() bool {
	switch e {
	case SearchPrefixQueryTypeLast, SearchPrefixQueryTypeNone:
		return true
	}
	return false
}

func (e SearchPrefixQueryType) String() string {
	return string(e)
}

func (e *SearchPrefixQueryType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchPrefixQueryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchPrefixQueryType", str)
	}
	return nil
}

func (e SearchPrefixQueryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchPrefixQueryType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchPrefixQueryType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The set of valid sort keys for the search query.
type SearchSortKeys string

const (
	// Sort by the `price` value.
	SearchSortKeysPrice SearchSortKeys = "PRICE"
	// Sort by relevance to the search terms.
	SearchSortKeysRelevance SearchSortKeys = "RELEVANCE"
)

var AllSearchSortKeys = []SearchSortKeys{
	SearchSortKeysPrice,
	SearchSortKeysRelevance,
}

func (e SearchSortKeys) IsValid() bool {
	switch e {
	case SearchSortKeysPrice, SearchSortKeysRelevance:
		return true
	}
	return false
}

func (e SearchSortKeys) String() string {
	return string(e)
}

func (e *SearchSortKeys) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchSortKeys", str)
	}
	return nil
}

func (e SearchSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchSortKeys) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchSortKeys) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The types of search items to perform search within.
type SearchType string

const (
	// Returns matching articles.
	SearchTypeArticle SearchType = "ARTICLE"
	// Returns matching pages.
	SearchTypePage SearchType = "PAGE"
	// Returns matching products.
	SearchTypeProduct SearchType = "PRODUCT"
)

var AllSearchType = []SearchType{
	SearchTypeArticle,
	SearchTypePage,
	SearchTypeProduct,
}

func (e SearchType) IsValid() bool {
	switch e {
	case SearchTypeArticle, SearchTypePage, SearchTypeProduct:
		return true
	}
	return false
}

func (e SearchType) String() string {
	return string(e)
}

func (e *SearchType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchType", str)
	}
	return nil
}

func (e SearchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Specifies whether to display results for unavailable products.
type SearchUnavailableProductsType string

const (
	// Exclude unavailable products.
	SearchUnavailableProductsTypeHide SearchUnavailableProductsType = "HIDE"
	// Show unavailable products after all other matching results. This is the default.
	SearchUnavailableProductsTypeLast SearchUnavailableProductsType = "LAST"
	// Show unavailable products in the order that they're found.
	SearchUnavailableProductsTypeShow SearchUnavailableProductsType = "SHOW"
)

var AllSearchUnavailableProductsType = []SearchUnavailableProductsType{
	SearchUnavailableProductsTypeHide,
	SearchUnavailableProductsTypeLast,
	SearchUnavailableProductsTypeShow,
}

func (e SearchUnavailableProductsType) IsValid() bool {
	switch e {
	case SearchUnavailableProductsTypeHide, SearchUnavailableProductsTypeLast, SearchUnavailableProductsTypeShow:
		return true
	}
	return false
}

func (e SearchUnavailableProductsType) String() string {
	return string(e)
}

func (e *SearchUnavailableProductsType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchUnavailableProductsType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchUnavailableProductsType", str)
	}
	return nil
}

func (e SearchUnavailableProductsType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchUnavailableProductsType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchUnavailableProductsType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Specifies the list of resource fields to search.
type SearchableField string

const (
	// Author of the page or article.
	SearchableFieldAuthor SearchableField = "AUTHOR"
	// Body of the page or article or product description or collection description.
	SearchableFieldBody SearchableField = "BODY"
	// Product type.
	SearchableFieldProductType SearchableField = "PRODUCT_TYPE"
	// Tag associated with the product or article.
	SearchableFieldTag SearchableField = "TAG"
	// Title of the page or article or product title or collection title.
	SearchableFieldTitle SearchableField = "TITLE"
	// Variant barcode.
	SearchableFieldVariantsBarcode SearchableField = "VARIANTS_BARCODE"
	// Variant SKU.
	SearchableFieldVariantsSku SearchableField = "VARIANTS_SKU"
	// Variant title.
	SearchableFieldVariantsTitle SearchableField = "VARIANTS_TITLE"
	// Product vendor.
	SearchableFieldVendor SearchableField = "VENDOR"
)

var AllSearchableField = []SearchableField{
	SearchableFieldAuthor,
	SearchableFieldBody,
	SearchableFieldProductType,
	SearchableFieldTag,
	SearchableFieldTitle,
	SearchableFieldVariantsBarcode,
	SearchableFieldVariantsSku,
	SearchableFieldVariantsTitle,
	SearchableFieldVendor,
}

func (e SearchableField) IsValid() bool {
	switch e {
	case SearchableFieldAuthor, SearchableFieldBody, SearchableFieldProductType, SearchableFieldTag, SearchableFieldTitle, SearchableFieldVariantsBarcode, SearchableFieldVariantsSku, SearchableFieldVariantsTitle, SearchableFieldVendor:
		return true
	}
	return false
}

func (e SearchableField) String() string {
	return string(e)
}

func (e *SearchableField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableField", str)
	}
	return nil
}

func (e SearchableField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The checkout charge when the full amount isn't charged at checkout.
type SellingPlanCheckoutChargeType string

const (
	// The checkout charge is a percentage of the product or variant price.
	SellingPlanCheckoutChargeTypePercentage SellingPlanCheckoutChargeType = "PERCENTAGE"
	// The checkout charge is a fixed price amount.
	SellingPlanCheckoutChargeTypePrice SellingPlanCheckoutChargeType = "PRICE"
)

var AllSellingPlanCheckoutChargeType = []SellingPlanCheckoutChargeType{
	SellingPlanCheckoutChargeTypePercentage,
	SellingPlanCheckoutChargeTypePrice,
}

func (e SellingPlanCheckoutChargeType) IsValid() bool {
	switch e {
	case SellingPlanCheckoutChargeTypePercentage, SellingPlanCheckoutChargeTypePrice:
		return true
	}
	return false
}

func (e SellingPlanCheckoutChargeType) String() string {
	return string(e)
}

func (e *SellingPlanCheckoutChargeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SellingPlanCheckoutChargeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SellingPlanCheckoutChargeType", str)
	}
	return nil
}

func (e SellingPlanCheckoutChargeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SellingPlanCheckoutChargeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SellingPlanCheckoutChargeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents a valid selling plan interval.
type SellingPlanInterval string

const (
	// Day interval.
	SellingPlanIntervalDay SellingPlanInterval = "DAY"
	// Month interval.
	SellingPlanIntervalMonth SellingPlanInterval = "MONTH"
	// Week interval.
	SellingPlanIntervalWeek SellingPlanInterval = "WEEK"
	// Year interval.
	SellingPlanIntervalYear SellingPlanInterval = "YEAR"
)

var AllSellingPlanInterval = []SellingPlanInterval{
	SellingPlanIntervalDay,
	SellingPlanIntervalMonth,
	SellingPlanIntervalWeek,
	SellingPlanIntervalYear,
}

func (e SellingPlanInterval) IsValid() bool {
	switch e {
	case SellingPlanIntervalDay, SellingPlanIntervalMonth, SellingPlanIntervalWeek, SellingPlanIntervalYear:
		return true
	}
	return false
}

func (e SellingPlanInterval) String() string {
	return string(e)
}

func (e *SellingPlanInterval) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SellingPlanInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SellingPlanInterval", str)
	}
	return nil
}

func (e SellingPlanInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SellingPlanInterval) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SellingPlanInterval) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The payment frequency for a Shop Pay Installments Financing Plan.
type ShopPayInstallmentsFinancingPlanFrequency string

const (
	// Monthly payment frequency.
	ShopPayInstallmentsFinancingPlanFrequencyMonthly ShopPayInstallmentsFinancingPlanFrequency = "MONTHLY"
	// Weekly payment frequency.
	ShopPayInstallmentsFinancingPlanFrequencyWeekly ShopPayInstallmentsFinancingPlanFrequency = "WEEKLY"
)

var AllShopPayInstallmentsFinancingPlanFrequency = []ShopPayInstallmentsFinancingPlanFrequency{
	ShopPayInstallmentsFinancingPlanFrequencyMonthly,
	ShopPayInstallmentsFinancingPlanFrequencyWeekly,
}

func (e ShopPayInstallmentsFinancingPlanFrequency) IsValid() bool {
	switch e {
	case ShopPayInstallmentsFinancingPlanFrequencyMonthly, ShopPayInstallmentsFinancingPlanFrequencyWeekly:
		return true
	}
	return false
}

func (e ShopPayInstallmentsFinancingPlanFrequency) String() string {
	return string(e)
}

func (e *ShopPayInstallmentsFinancingPlanFrequency) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopPayInstallmentsFinancingPlanFrequency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopPayInstallmentsFinancingPlanFrequency", str)
	}
	return nil
}

func (e ShopPayInstallmentsFinancingPlanFrequency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ShopPayInstallmentsFinancingPlanFrequency) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ShopPayInstallmentsFinancingPlanFrequency) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The loan type for a Shop Pay Installments Financing Plan Term.
type ShopPayInstallmentsLoan string

const (
	// An interest-bearing loan type.
	ShopPayInstallmentsLoanInterest ShopPayInstallmentsLoan = "INTEREST"
	// A split-pay loan type.
	ShopPayInstallmentsLoanSplitPay ShopPayInstallmentsLoan = "SPLIT_PAY"
	// A zero-percent loan type.
	ShopPayInstallmentsLoanZeroPercent ShopPayInstallmentsLoan = "ZERO_PERCENT"
)

var AllShopPayInstallmentsLoan = []ShopPayInstallmentsLoan{
	ShopPayInstallmentsLoanInterest,
	ShopPayInstallmentsLoanSplitPay,
	ShopPayInstallmentsLoanZeroPercent,
}

func (e ShopPayInstallmentsLoan) IsValid() bool {
	switch e {
	case ShopPayInstallmentsLoanInterest, ShopPayInstallmentsLoanSplitPay, ShopPayInstallmentsLoanZeroPercent:
		return true
	}
	return false
}

func (e ShopPayInstallmentsLoan) String() string {
	return string(e)
}

func (e *ShopPayInstallmentsLoan) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopPayInstallmentsLoan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopPayInstallmentsLoan", str)
	}
	return nil
}

func (e ShopPayInstallmentsLoan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ShopPayInstallmentsLoan) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ShopPayInstallmentsLoan) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Represents the delivery method type for a Shop Pay payment request.
type ShopPayPaymentRequestDeliveryMethodType string

const (
	// The delivery method type is pickup.
	ShopPayPaymentRequestDeliveryMethodTypePickup ShopPayPaymentRequestDeliveryMethodType = "PICKUP"
	// The delivery method type is shipping.
	ShopPayPaymentRequestDeliveryMethodTypeShipping ShopPayPaymentRequestDeliveryMethodType = "SHIPPING"
)

var AllShopPayPaymentRequestDeliveryMethodType = []ShopPayPaymentRequestDeliveryMethodType{
	ShopPayPaymentRequestDeliveryMethodTypePickup,
	ShopPayPaymentRequestDeliveryMethodTypeShipping,
}

func (e ShopPayPaymentRequestDeliveryMethodType) IsValid() bool {
	switch e {
	case ShopPayPaymentRequestDeliveryMethodTypePickup, ShopPayPaymentRequestDeliveryMethodTypeShipping:
		return true
	}
	return false
}

func (e ShopPayPaymentRequestDeliveryMethodType) String() string {
	return string(e)
}

func (e *ShopPayPaymentRequestDeliveryMethodType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopPayPaymentRequestDeliveryMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopPayPaymentRequestDeliveryMethodType", str)
	}
	return nil
}

func (e ShopPayPaymentRequestDeliveryMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ShopPayPaymentRequestDeliveryMethodType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ShopPayPaymentRequestDeliveryMethodType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The types of resources potentially present in a sitemap.
type SitemapType string

const (
	// Articles present in the sitemap.
	SitemapTypeArticle SitemapType = "ARTICLE"
	// Blogs present in the sitemap.
	SitemapTypeBlog SitemapType = "BLOG"
	// Collections present in the sitemap.
	SitemapTypeCollection SitemapType = "COLLECTION"
	// Metaobjects present in the sitemap. Only metaobject types with the
	// [`renderable` capability](https://shopify.dev/docs/apps/build/custom-data/metaobjects/use-metaobject-capabilities#render-metaobjects-as-web-pages)
	// are included in sitemap.
	SitemapTypeMetaobject SitemapType = "METAOBJECT"
	// Pages present in the sitemap.
	SitemapTypePage SitemapType = "PAGE"
	// Products present in the sitemap.
	SitemapTypeProduct SitemapType = "PRODUCT"
)

var AllSitemapType = []SitemapType{
	SitemapTypeArticle,
	SitemapTypeBlog,
	SitemapTypeCollection,
	SitemapTypeMetaobject,
	SitemapTypePage,
	SitemapTypeProduct,
}

func (e SitemapType) IsValid() bool {
	switch e {
	case SitemapTypeArticle, SitemapTypeBlog, SitemapTypeCollection, SitemapTypeMetaobject, SitemapTypePage, SitemapTypeProduct:
		return true
	}
	return false
}

func (e SitemapType) String() string {
	return string(e)
}

func (e *SitemapType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SitemapType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SitemapType", str)
	}
	return nil
}

func (e SitemapType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SitemapType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SitemapType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The code of the error that occurred during cart submit for completion.
type SubmissionErrorCode string

const (
	SubmissionErrorCodeBuyerIdentityEmailIsInvalid                                 SubmissionErrorCode = "BUYER_IDENTITY_EMAIL_IS_INVALID"
	SubmissionErrorCodeBuyerIdentityEmailRequired                                  SubmissionErrorCode = "BUYER_IDENTITY_EMAIL_REQUIRED"
	SubmissionErrorCodeBuyerIdentityPhoneIsInvalid                                 SubmissionErrorCode = "BUYER_IDENTITY_PHONE_IS_INVALID"
	SubmissionErrorCodeDeliveryAddress1Invalid                                     SubmissionErrorCode = "DELIVERY_ADDRESS1_INVALID"
	SubmissionErrorCodeDeliveryAddress1Required                                    SubmissionErrorCode = "DELIVERY_ADDRESS1_REQUIRED"
	SubmissionErrorCodeDeliveryAddress1TooLong                                     SubmissionErrorCode = "DELIVERY_ADDRESS1_TOO_LONG"
	SubmissionErrorCodeDeliveryAddress2Invalid                                     SubmissionErrorCode = "DELIVERY_ADDRESS2_INVALID"
	SubmissionErrorCodeDeliveryAddress2Required                                    SubmissionErrorCode = "DELIVERY_ADDRESS2_REQUIRED"
	SubmissionErrorCodeDeliveryAddress2TooLong                                     SubmissionErrorCode = "DELIVERY_ADDRESS2_TOO_LONG"
	SubmissionErrorCodeDeliveryAddressRequired                                     SubmissionErrorCode = "DELIVERY_ADDRESS_REQUIRED"
	SubmissionErrorCodeDeliveryCityInvalid                                         SubmissionErrorCode = "DELIVERY_CITY_INVALID"
	SubmissionErrorCodeDeliveryCityRequired                                        SubmissionErrorCode = "DELIVERY_CITY_REQUIRED"
	SubmissionErrorCodeDeliveryCityTooLong                                         SubmissionErrorCode = "DELIVERY_CITY_TOO_LONG"
	SubmissionErrorCodeDeliveryCompanyInvalid                                      SubmissionErrorCode = "DELIVERY_COMPANY_INVALID"
	SubmissionErrorCodeDeliveryCompanyRequired                                     SubmissionErrorCode = "DELIVERY_COMPANY_REQUIRED"
	SubmissionErrorCodeDeliveryCompanyTooLong                                      SubmissionErrorCode = "DELIVERY_COMPANY_TOO_LONG"
	SubmissionErrorCodeDeliveryCountryRequired                                     SubmissionErrorCode = "DELIVERY_COUNTRY_REQUIRED"
	SubmissionErrorCodeDeliveryFirstNameInvalid                                    SubmissionErrorCode = "DELIVERY_FIRST_NAME_INVALID"
	SubmissionErrorCodeDeliveryFirstNameRequired                                   SubmissionErrorCode = "DELIVERY_FIRST_NAME_REQUIRED"
	SubmissionErrorCodeDeliveryFirstNameTooLong                                    SubmissionErrorCode = "DELIVERY_FIRST_NAME_TOO_LONG"
	SubmissionErrorCodeDeliveryInvalidPostalCodeForCountry                         SubmissionErrorCode = "DELIVERY_INVALID_POSTAL_CODE_FOR_COUNTRY"
	SubmissionErrorCodeDeliveryInvalidPostalCodeForZone                            SubmissionErrorCode = "DELIVERY_INVALID_POSTAL_CODE_FOR_ZONE"
	SubmissionErrorCodeDeliveryLastNameInvalid                                     SubmissionErrorCode = "DELIVERY_LAST_NAME_INVALID"
	SubmissionErrorCodeDeliveryLastNameRequired                                    SubmissionErrorCode = "DELIVERY_LAST_NAME_REQUIRED"
	SubmissionErrorCodeDeliveryLastNameTooLong                                     SubmissionErrorCode = "DELIVERY_LAST_NAME_TOO_LONG"
	SubmissionErrorCodeDeliveryNoDeliveryAvailable                                 SubmissionErrorCode = "DELIVERY_NO_DELIVERY_AVAILABLE"
	SubmissionErrorCodeDeliveryNoDeliveryAvailableForMerchandiseLine               SubmissionErrorCode = "DELIVERY_NO_DELIVERY_AVAILABLE_FOR_MERCHANDISE_LINE"
	SubmissionErrorCodeDeliveryOptionsPhoneNumberInvalid                           SubmissionErrorCode = "DELIVERY_OPTIONS_PHONE_NUMBER_INVALID"
	SubmissionErrorCodeDeliveryOptionsPhoneNumberRequired                          SubmissionErrorCode = "DELIVERY_OPTIONS_PHONE_NUMBER_REQUIRED"
	SubmissionErrorCodeDeliveryPhoneNumberInvalid                                  SubmissionErrorCode = "DELIVERY_PHONE_NUMBER_INVALID"
	SubmissionErrorCodeDeliveryPhoneNumberRequired                                 SubmissionErrorCode = "DELIVERY_PHONE_NUMBER_REQUIRED"
	SubmissionErrorCodeDeliveryPostalCodeInvalid                                   SubmissionErrorCode = "DELIVERY_POSTAL_CODE_INVALID"
	SubmissionErrorCodeDeliveryPostalCodeRequired                                  SubmissionErrorCode = "DELIVERY_POSTAL_CODE_REQUIRED"
	SubmissionErrorCodeDeliveryZoneNotFound                                        SubmissionErrorCode = "DELIVERY_ZONE_NOT_FOUND"
	SubmissionErrorCodeDeliveryZoneRequiredForCountry                              SubmissionErrorCode = "DELIVERY_ZONE_REQUIRED_FOR_COUNTRY"
	SubmissionErrorCodeError                                                       SubmissionErrorCode = "ERROR"
	SubmissionErrorCodeMerchandiseLineLimitReached                                 SubmissionErrorCode = "MERCHANDISE_LINE_LIMIT_REACHED"
	SubmissionErrorCodeMerchandiseNotApplicable                                    SubmissionErrorCode = "MERCHANDISE_NOT_APPLICABLE"
	SubmissionErrorCodeMerchandiseNotEnoughStockAvailable                          SubmissionErrorCode = "MERCHANDISE_NOT_ENOUGH_STOCK_AVAILABLE"
	SubmissionErrorCodeMerchandiseOutOfStock                                       SubmissionErrorCode = "MERCHANDISE_OUT_OF_STOCK"
	SubmissionErrorCodeMerchandiseProductNotPublished                              SubmissionErrorCode = "MERCHANDISE_PRODUCT_NOT_PUBLISHED"
	SubmissionErrorCodeNoDeliveryGroupSelected                                     SubmissionErrorCode = "NO_DELIVERY_GROUP_SELECTED"
	SubmissionErrorCodePaymentsAddress1Invalid                                     SubmissionErrorCode = "PAYMENTS_ADDRESS1_INVALID"
	SubmissionErrorCodePaymentsAddress1Required                                    SubmissionErrorCode = "PAYMENTS_ADDRESS1_REQUIRED"
	SubmissionErrorCodePaymentsAddress1TooLong                                     SubmissionErrorCode = "PAYMENTS_ADDRESS1_TOO_LONG"
	SubmissionErrorCodePaymentsAddress2Invalid                                     SubmissionErrorCode = "PAYMENTS_ADDRESS2_INVALID"
	SubmissionErrorCodePaymentsAddress2Required                                    SubmissionErrorCode = "PAYMENTS_ADDRESS2_REQUIRED"
	SubmissionErrorCodePaymentsAddress2TooLong                                     SubmissionErrorCode = "PAYMENTS_ADDRESS2_TOO_LONG"
	SubmissionErrorCodePaymentsBillingAddressZoneNotFound                          SubmissionErrorCode = "PAYMENTS_BILLING_ADDRESS_ZONE_NOT_FOUND"
	SubmissionErrorCodePaymentsBillingAddressZoneRequiredForCountry                SubmissionErrorCode = "PAYMENTS_BILLING_ADDRESS_ZONE_REQUIRED_FOR_COUNTRY"
	SubmissionErrorCodePaymentsCityInvalid                                         SubmissionErrorCode = "PAYMENTS_CITY_INVALID"
	SubmissionErrorCodePaymentsCityRequired                                        SubmissionErrorCode = "PAYMENTS_CITY_REQUIRED"
	SubmissionErrorCodePaymentsCityTooLong                                         SubmissionErrorCode = "PAYMENTS_CITY_TOO_LONG"
	SubmissionErrorCodePaymentsCompanyInvalid                                      SubmissionErrorCode = "PAYMENTS_COMPANY_INVALID"
	SubmissionErrorCodePaymentsCompanyRequired                                     SubmissionErrorCode = "PAYMENTS_COMPANY_REQUIRED"
	SubmissionErrorCodePaymentsCompanyTooLong                                      SubmissionErrorCode = "PAYMENTS_COMPANY_TOO_LONG"
	SubmissionErrorCodePaymentsCountryRequired                                     SubmissionErrorCode = "PAYMENTS_COUNTRY_REQUIRED"
	SubmissionErrorCodePaymentsCreditCardBaseExpired                               SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_BASE_EXPIRED"
	SubmissionErrorCodePaymentsCreditCardBaseGatewayNotSupported                   SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_BASE_GATEWAY_NOT_SUPPORTED"
	SubmissionErrorCodePaymentsCreditCardBaseInvalidStartDateOrIssueNumberForDebit SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_BASE_INVALID_START_DATE_OR_ISSUE_NUMBER_FOR_DEBIT"
	SubmissionErrorCodePaymentsCreditCardBrandNotSupported                         SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_BRAND_NOT_SUPPORTED"
	SubmissionErrorCodePaymentsCreditCardFirstNameBlank                            SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_FIRST_NAME_BLANK"
	SubmissionErrorCodePaymentsCreditCardGeneric                                   SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_GENERIC"
	SubmissionErrorCodePaymentsCreditCardLastNameBlank                             SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_LAST_NAME_BLANK"
	SubmissionErrorCodePaymentsCreditCardMonthInclusion                            SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_MONTH_INCLUSION"
	SubmissionErrorCodePaymentsCreditCardNameInvalid                               SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_NAME_INVALID"
	SubmissionErrorCodePaymentsCreditCardNumberInvalid                             SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_NUMBER_INVALID"
	SubmissionErrorCodePaymentsCreditCardNumberInvalidFormat                       SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_NUMBER_INVALID_FORMAT"
	SubmissionErrorCodePaymentsCreditCardSessionID                                 SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_SESSION_ID"
	SubmissionErrorCodePaymentsCreditCardVerificationValueBlank                    SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_BLANK"
	SubmissionErrorCodePaymentsCreditCardVerificationValueInvalidForCardType       SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_INVALID_FOR_CARD_TYPE"
	SubmissionErrorCodePaymentsCreditCardYearExpired                               SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_YEAR_EXPIRED"
	SubmissionErrorCodePaymentsCreditCardYearInvalidExpiryYear                     SubmissionErrorCode = "PAYMENTS_CREDIT_CARD_YEAR_INVALID_EXPIRY_YEAR"
	SubmissionErrorCodePaymentsFirstNameInvalid                                    SubmissionErrorCode = "PAYMENTS_FIRST_NAME_INVALID"
	SubmissionErrorCodePaymentsFirstNameRequired                                   SubmissionErrorCode = "PAYMENTS_FIRST_NAME_REQUIRED"
	SubmissionErrorCodePaymentsFirstNameTooLong                                    SubmissionErrorCode = "PAYMENTS_FIRST_NAME_TOO_LONG"
	SubmissionErrorCodePaymentsInvalidPostalCodeForCountry                         SubmissionErrorCode = "PAYMENTS_INVALID_POSTAL_CODE_FOR_COUNTRY"
	SubmissionErrorCodePaymentsInvalidPostalCodeForZone                            SubmissionErrorCode = "PAYMENTS_INVALID_POSTAL_CODE_FOR_ZONE"
	SubmissionErrorCodePaymentsLastNameInvalid                                     SubmissionErrorCode = "PAYMENTS_LAST_NAME_INVALID"
	SubmissionErrorCodePaymentsLastNameRequired                                    SubmissionErrorCode = "PAYMENTS_LAST_NAME_REQUIRED"
	SubmissionErrorCodePaymentsLastNameTooLong                                     SubmissionErrorCode = "PAYMENTS_LAST_NAME_TOO_LONG"
	SubmissionErrorCodePaymentsMethodRequired                                      SubmissionErrorCode = "PAYMENTS_METHOD_REQUIRED"
	SubmissionErrorCodePaymentsMethodUnavailable                                   SubmissionErrorCode = "PAYMENTS_METHOD_UNAVAILABLE"
	SubmissionErrorCodePaymentsPhoneNumberInvalid                                  SubmissionErrorCode = "PAYMENTS_PHONE_NUMBER_INVALID"
	SubmissionErrorCodePaymentsPhoneNumberRequired                                 SubmissionErrorCode = "PAYMENTS_PHONE_NUMBER_REQUIRED"
	SubmissionErrorCodePaymentsPostalCodeInvalid                                   SubmissionErrorCode = "PAYMENTS_POSTAL_CODE_INVALID"
	SubmissionErrorCodePaymentsPostalCodeRequired                                  SubmissionErrorCode = "PAYMENTS_POSTAL_CODE_REQUIRED"
	SubmissionErrorCodePaymentsShopifyPaymentsRequired                             SubmissionErrorCode = "PAYMENTS_SHOPIFY_PAYMENTS_REQUIRED"
	SubmissionErrorCodePaymentsUnacceptablePaymentAmount                           SubmissionErrorCode = "PAYMENTS_UNACCEPTABLE_PAYMENT_AMOUNT"
	SubmissionErrorCodePaymentsWalletContentMissing                                SubmissionErrorCode = "PAYMENTS_WALLET_CONTENT_MISSING"
	// Redirect to checkout required to complete this action.
	SubmissionErrorCodeRedirectToCheckoutRequired   SubmissionErrorCode = "REDIRECT_TO_CHECKOUT_REQUIRED"
	SubmissionErrorCodeTaxesDeliveryGroupIDNotFound SubmissionErrorCode = "TAXES_DELIVERY_GROUP_ID_NOT_FOUND"
	SubmissionErrorCodeTaxesLineIDNotFound          SubmissionErrorCode = "TAXES_LINE_ID_NOT_FOUND"
	SubmissionErrorCodeTaxesMustBeDefined           SubmissionErrorCode = "TAXES_MUST_BE_DEFINED"
	// Validation failed.
	SubmissionErrorCodeValidationCustom SubmissionErrorCode = "VALIDATION_CUSTOM"
)

var AllSubmissionErrorCode = []SubmissionErrorCode{
	SubmissionErrorCodeBuyerIdentityEmailIsInvalid,
	SubmissionErrorCodeBuyerIdentityEmailRequired,
	SubmissionErrorCodeBuyerIdentityPhoneIsInvalid,
	SubmissionErrorCodeDeliveryAddress1Invalid,
	SubmissionErrorCodeDeliveryAddress1Required,
	SubmissionErrorCodeDeliveryAddress1TooLong,
	SubmissionErrorCodeDeliveryAddress2Invalid,
	SubmissionErrorCodeDeliveryAddress2Required,
	SubmissionErrorCodeDeliveryAddress2TooLong,
	SubmissionErrorCodeDeliveryAddressRequired,
	SubmissionErrorCodeDeliveryCityInvalid,
	SubmissionErrorCodeDeliveryCityRequired,
	SubmissionErrorCodeDeliveryCityTooLong,
	SubmissionErrorCodeDeliveryCompanyInvalid,
	SubmissionErrorCodeDeliveryCompanyRequired,
	SubmissionErrorCodeDeliveryCompanyTooLong,
	SubmissionErrorCodeDeliveryCountryRequired,
	SubmissionErrorCodeDeliveryFirstNameInvalid,
	SubmissionErrorCodeDeliveryFirstNameRequired,
	SubmissionErrorCodeDeliveryFirstNameTooLong,
	SubmissionErrorCodeDeliveryInvalidPostalCodeForCountry,
	SubmissionErrorCodeDeliveryInvalidPostalCodeForZone,
	SubmissionErrorCodeDeliveryLastNameInvalid,
	SubmissionErrorCodeDeliveryLastNameRequired,
	SubmissionErrorCodeDeliveryLastNameTooLong,
	SubmissionErrorCodeDeliveryNoDeliveryAvailable,
	SubmissionErrorCodeDeliveryNoDeliveryAvailableForMerchandiseLine,
	SubmissionErrorCodeDeliveryOptionsPhoneNumberInvalid,
	SubmissionErrorCodeDeliveryOptionsPhoneNumberRequired,
	SubmissionErrorCodeDeliveryPhoneNumberInvalid,
	SubmissionErrorCodeDeliveryPhoneNumberRequired,
	SubmissionErrorCodeDeliveryPostalCodeInvalid,
	SubmissionErrorCodeDeliveryPostalCodeRequired,
	SubmissionErrorCodeDeliveryZoneNotFound,
	SubmissionErrorCodeDeliveryZoneRequiredForCountry,
	SubmissionErrorCodeError,
	SubmissionErrorCodeMerchandiseLineLimitReached,
	SubmissionErrorCodeMerchandiseNotApplicable,
	SubmissionErrorCodeMerchandiseNotEnoughStockAvailable,
	SubmissionErrorCodeMerchandiseOutOfStock,
	SubmissionErrorCodeMerchandiseProductNotPublished,
	SubmissionErrorCodeNoDeliveryGroupSelected,
	SubmissionErrorCodePaymentsAddress1Invalid,
	SubmissionErrorCodePaymentsAddress1Required,
	SubmissionErrorCodePaymentsAddress1TooLong,
	SubmissionErrorCodePaymentsAddress2Invalid,
	SubmissionErrorCodePaymentsAddress2Required,
	SubmissionErrorCodePaymentsAddress2TooLong,
	SubmissionErrorCodePaymentsBillingAddressZoneNotFound,
	SubmissionErrorCodePaymentsBillingAddressZoneRequiredForCountry,
	SubmissionErrorCodePaymentsCityInvalid,
	SubmissionErrorCodePaymentsCityRequired,
	SubmissionErrorCodePaymentsCityTooLong,
	SubmissionErrorCodePaymentsCompanyInvalid,
	SubmissionErrorCodePaymentsCompanyRequired,
	SubmissionErrorCodePaymentsCompanyTooLong,
	SubmissionErrorCodePaymentsCountryRequired,
	SubmissionErrorCodePaymentsCreditCardBaseExpired,
	SubmissionErrorCodePaymentsCreditCardBaseGatewayNotSupported,
	SubmissionErrorCodePaymentsCreditCardBaseInvalidStartDateOrIssueNumberForDebit,
	SubmissionErrorCodePaymentsCreditCardBrandNotSupported,
	SubmissionErrorCodePaymentsCreditCardFirstNameBlank,
	SubmissionErrorCodePaymentsCreditCardGeneric,
	SubmissionErrorCodePaymentsCreditCardLastNameBlank,
	SubmissionErrorCodePaymentsCreditCardMonthInclusion,
	SubmissionErrorCodePaymentsCreditCardNameInvalid,
	SubmissionErrorCodePaymentsCreditCardNumberInvalid,
	SubmissionErrorCodePaymentsCreditCardNumberInvalidFormat,
	SubmissionErrorCodePaymentsCreditCardSessionID,
	SubmissionErrorCodePaymentsCreditCardVerificationValueBlank,
	SubmissionErrorCodePaymentsCreditCardVerificationValueInvalidForCardType,
	SubmissionErrorCodePaymentsCreditCardYearExpired,
	SubmissionErrorCodePaymentsCreditCardYearInvalidExpiryYear,
	SubmissionErrorCodePaymentsFirstNameInvalid,
	SubmissionErrorCodePaymentsFirstNameRequired,
	SubmissionErrorCodePaymentsFirstNameTooLong,
	SubmissionErrorCodePaymentsInvalidPostalCodeForCountry,
	SubmissionErrorCodePaymentsInvalidPostalCodeForZone,
	SubmissionErrorCodePaymentsLastNameInvalid,
	SubmissionErrorCodePaymentsLastNameRequired,
	SubmissionErrorCodePaymentsLastNameTooLong,
	SubmissionErrorCodePaymentsMethodRequired,
	SubmissionErrorCodePaymentsMethodUnavailable,
	SubmissionErrorCodePaymentsPhoneNumberInvalid,
	SubmissionErrorCodePaymentsPhoneNumberRequired,
	SubmissionErrorCodePaymentsPostalCodeInvalid,
	SubmissionErrorCodePaymentsPostalCodeRequired,
	SubmissionErrorCodePaymentsShopifyPaymentsRequired,
	SubmissionErrorCodePaymentsUnacceptablePaymentAmount,
	SubmissionErrorCodePaymentsWalletContentMissing,
	SubmissionErrorCodeRedirectToCheckoutRequired,
	SubmissionErrorCodeTaxesDeliveryGroupIDNotFound,
	SubmissionErrorCodeTaxesLineIDNotFound,
	SubmissionErrorCodeTaxesMustBeDefined,
	SubmissionErrorCodeValidationCustom,
}

func (e SubmissionErrorCode) IsValid() bool {
	switch e {
	case SubmissionErrorCodeBuyerIdentityEmailIsInvalid, SubmissionErrorCodeBuyerIdentityEmailRequired, SubmissionErrorCodeBuyerIdentityPhoneIsInvalid, SubmissionErrorCodeDeliveryAddress1Invalid, SubmissionErrorCodeDeliveryAddress1Required, SubmissionErrorCodeDeliveryAddress1TooLong, SubmissionErrorCodeDeliveryAddress2Invalid, SubmissionErrorCodeDeliveryAddress2Required, SubmissionErrorCodeDeliveryAddress2TooLong, SubmissionErrorCodeDeliveryAddressRequired, SubmissionErrorCodeDeliveryCityInvalid, SubmissionErrorCodeDeliveryCityRequired, SubmissionErrorCodeDeliveryCityTooLong, SubmissionErrorCodeDeliveryCompanyInvalid, SubmissionErrorCodeDeliveryCompanyRequired, SubmissionErrorCodeDeliveryCompanyTooLong, SubmissionErrorCodeDeliveryCountryRequired, SubmissionErrorCodeDeliveryFirstNameInvalid, SubmissionErrorCodeDeliveryFirstNameRequired, SubmissionErrorCodeDeliveryFirstNameTooLong, SubmissionErrorCodeDeliveryInvalidPostalCodeForCountry, SubmissionErrorCodeDeliveryInvalidPostalCodeForZone, SubmissionErrorCodeDeliveryLastNameInvalid, SubmissionErrorCodeDeliveryLastNameRequired, SubmissionErrorCodeDeliveryLastNameTooLong, SubmissionErrorCodeDeliveryNoDeliveryAvailable, SubmissionErrorCodeDeliveryNoDeliveryAvailableForMerchandiseLine, SubmissionErrorCodeDeliveryOptionsPhoneNumberInvalid, SubmissionErrorCodeDeliveryOptionsPhoneNumberRequired, SubmissionErrorCodeDeliveryPhoneNumberInvalid, SubmissionErrorCodeDeliveryPhoneNumberRequired, SubmissionErrorCodeDeliveryPostalCodeInvalid, SubmissionErrorCodeDeliveryPostalCodeRequired, SubmissionErrorCodeDeliveryZoneNotFound, SubmissionErrorCodeDeliveryZoneRequiredForCountry, SubmissionErrorCodeError, SubmissionErrorCodeMerchandiseLineLimitReached, SubmissionErrorCodeMerchandiseNotApplicable, SubmissionErrorCodeMerchandiseNotEnoughStockAvailable, SubmissionErrorCodeMerchandiseOutOfStock, SubmissionErrorCodeMerchandiseProductNotPublished, SubmissionErrorCodeNoDeliveryGroupSelected, SubmissionErrorCodePaymentsAddress1Invalid, SubmissionErrorCodePaymentsAddress1Required, SubmissionErrorCodePaymentsAddress1TooLong, SubmissionErrorCodePaymentsAddress2Invalid, SubmissionErrorCodePaymentsAddress2Required, SubmissionErrorCodePaymentsAddress2TooLong, SubmissionErrorCodePaymentsBillingAddressZoneNotFound, SubmissionErrorCodePaymentsBillingAddressZoneRequiredForCountry, SubmissionErrorCodePaymentsCityInvalid, SubmissionErrorCodePaymentsCityRequired, SubmissionErrorCodePaymentsCityTooLong, SubmissionErrorCodePaymentsCompanyInvalid, SubmissionErrorCodePaymentsCompanyRequired, SubmissionErrorCodePaymentsCompanyTooLong, SubmissionErrorCodePaymentsCountryRequired, SubmissionErrorCodePaymentsCreditCardBaseExpired, SubmissionErrorCodePaymentsCreditCardBaseGatewayNotSupported, SubmissionErrorCodePaymentsCreditCardBaseInvalidStartDateOrIssueNumberForDebit, SubmissionErrorCodePaymentsCreditCardBrandNotSupported, SubmissionErrorCodePaymentsCreditCardFirstNameBlank, SubmissionErrorCodePaymentsCreditCardGeneric, SubmissionErrorCodePaymentsCreditCardLastNameBlank, SubmissionErrorCodePaymentsCreditCardMonthInclusion, SubmissionErrorCodePaymentsCreditCardNameInvalid, SubmissionErrorCodePaymentsCreditCardNumberInvalid, SubmissionErrorCodePaymentsCreditCardNumberInvalidFormat, SubmissionErrorCodePaymentsCreditCardSessionID, SubmissionErrorCodePaymentsCreditCardVerificationValueBlank, SubmissionErrorCodePaymentsCreditCardVerificationValueInvalidForCardType, SubmissionErrorCodePaymentsCreditCardYearExpired, SubmissionErrorCodePaymentsCreditCardYearInvalidExpiryYear, SubmissionErrorCodePaymentsFirstNameInvalid, SubmissionErrorCodePaymentsFirstNameRequired, SubmissionErrorCodePaymentsFirstNameTooLong, SubmissionErrorCodePaymentsInvalidPostalCodeForCountry, SubmissionErrorCodePaymentsInvalidPostalCodeForZone, SubmissionErrorCodePaymentsLastNameInvalid, SubmissionErrorCodePaymentsLastNameRequired, SubmissionErrorCodePaymentsLastNameTooLong, SubmissionErrorCodePaymentsMethodRequired, SubmissionErrorCodePaymentsMethodUnavailable, SubmissionErrorCodePaymentsPhoneNumberInvalid, SubmissionErrorCodePaymentsPhoneNumberRequired, SubmissionErrorCodePaymentsPostalCodeInvalid, SubmissionErrorCodePaymentsPostalCodeRequired, SubmissionErrorCodePaymentsShopifyPaymentsRequired, SubmissionErrorCodePaymentsUnacceptablePaymentAmount, SubmissionErrorCodePaymentsWalletContentMissing, SubmissionErrorCodeRedirectToCheckoutRequired, SubmissionErrorCodeTaxesDeliveryGroupIDNotFound, SubmissionErrorCodeTaxesLineIDNotFound, SubmissionErrorCodeTaxesMustBeDefined, SubmissionErrorCodeValidationCustom:
		return true
	}
	return false
}

func (e SubmissionErrorCode) String() string {
	return string(e)
}

func (e *SubmissionErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmissionErrorCode", str)
	}
	return nil
}

func (e SubmissionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubmissionErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubmissionErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The different kinds of order transactions.
type TransactionKind string

const (
	// An amount reserved against the cardholder's funding source.
	// Money does not change hands until the authorization is captured.
	TransactionKindAuthorization TransactionKind = "AUTHORIZATION"
	// A transfer of the money that was reserved during the authorization stage.
	TransactionKindCapture TransactionKind = "CAPTURE"
	// Money returned to the customer when they have paid too much.
	TransactionKindChange TransactionKind = "CHANGE"
	// An authorization for a payment taken with an EMV credit card reader.
	TransactionKindEmvAuthorization TransactionKind = "EMV_AUTHORIZATION"
	// An authorization and capture performed together in a single step.
	TransactionKindSale TransactionKind = "SALE"
)

var AllTransactionKind = []TransactionKind{
	TransactionKindAuthorization,
	TransactionKindCapture,
	TransactionKindChange,
	TransactionKindEmvAuthorization,
	TransactionKindSale,
}

func (e TransactionKind) IsValid() bool {
	switch e {
	case TransactionKindAuthorization, TransactionKindCapture, TransactionKindChange, TransactionKindEmvAuthorization, TransactionKindSale:
		return true
	}
	return false
}

func (e TransactionKind) String() string {
	return string(e)
}

func (e *TransactionKind) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionKind", str)
	}
	return nil
}

func (e TransactionKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TransactionKind) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TransactionKind) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Transaction statuses describe the status of a transaction.
type TransactionStatus string

const (
	// There was an error while processing the transaction.
	TransactionStatusError TransactionStatus = "ERROR"
	// The transaction failed.
	TransactionStatusFailure TransactionStatus = "FAILURE"
	// The transaction is pending.
	TransactionStatusPending TransactionStatus = "PENDING"
	// The transaction succeeded.
	TransactionStatusSuccess TransactionStatus = "SUCCESS"
)

var AllTransactionStatus = []TransactionStatus{
	TransactionStatusError,
	TransactionStatusFailure,
	TransactionStatusPending,
	TransactionStatusSuccess,
}

func (e TransactionStatus) IsValid() bool {
	switch e {
	case TransactionStatusError, TransactionStatusFailure, TransactionStatusPending, TransactionStatusSuccess:
		return true
	}
	return false
}

func (e TransactionStatus) String() string {
	return string(e)
}

func (e *TransactionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionStatus", str)
	}
	return nil
}

func (e TransactionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TransactionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TransactionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The accepted types of unit of measurement.
type UnitPriceMeasurementMeasuredType string

const (
	// Unit of measurements representing areas.
	UnitPriceMeasurementMeasuredTypeArea UnitPriceMeasurementMeasuredType = "AREA"
	// Unit of measurements representing counts.
	UnitPriceMeasurementMeasuredTypeCount UnitPriceMeasurementMeasuredType = "COUNT"
	// Unit of measurements representing lengths.
	UnitPriceMeasurementMeasuredTypeLength UnitPriceMeasurementMeasuredType = "LENGTH"
	// The type of measurement is unknown. Upgrade to the latest version of the API to resolve this type.
	UnitPriceMeasurementMeasuredTypeUnknown UnitPriceMeasurementMeasuredType = "UNKNOWN"
	// Unit of measurements representing volumes.
	UnitPriceMeasurementMeasuredTypeVolume UnitPriceMeasurementMeasuredType = "VOLUME"
	// Unit of measurements representing weights.
	UnitPriceMeasurementMeasuredTypeWeight UnitPriceMeasurementMeasuredType = "WEIGHT"
)

var AllUnitPriceMeasurementMeasuredType = []UnitPriceMeasurementMeasuredType{
	UnitPriceMeasurementMeasuredTypeArea,
	UnitPriceMeasurementMeasuredTypeCount,
	UnitPriceMeasurementMeasuredTypeLength,
	UnitPriceMeasurementMeasuredTypeUnknown,
	UnitPriceMeasurementMeasuredTypeVolume,
	UnitPriceMeasurementMeasuredTypeWeight,
}

func (e UnitPriceMeasurementMeasuredType) IsValid() bool {
	switch e {
	case UnitPriceMeasurementMeasuredTypeArea, UnitPriceMeasurementMeasuredTypeCount, UnitPriceMeasurementMeasuredTypeLength, UnitPriceMeasurementMeasuredTypeUnknown, UnitPriceMeasurementMeasuredTypeVolume, UnitPriceMeasurementMeasuredTypeWeight:
		return true
	}
	return false
}

func (e UnitPriceMeasurementMeasuredType) String() string {
	return string(e)
}

func (e *UnitPriceMeasurementMeasuredType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitPriceMeasurementMeasuredType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitPriceMeasurementMeasuredType", str)
	}
	return nil
}

func (e UnitPriceMeasurementMeasuredType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UnitPriceMeasurementMeasuredType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UnitPriceMeasurementMeasuredType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The valid units of measurement for a unit price measurement.
type UnitPriceMeasurementMeasuredUnit string

const (
	// 100 centiliters equals 1 liter.
	UnitPriceMeasurementMeasuredUnitCl UnitPriceMeasurementMeasuredUnit = "CL"
	// 100 centimeters equals 1 meter.
	UnitPriceMeasurementMeasuredUnitCm UnitPriceMeasurementMeasuredUnit = "CM"
	// Imperial system unit of volume (U.S. customary unit).
	UnitPriceMeasurementMeasuredUnitFloz UnitPriceMeasurementMeasuredUnit = "FLOZ"
	// 1 foot equals 12 inches.
	UnitPriceMeasurementMeasuredUnitFt UnitPriceMeasurementMeasuredUnit = "FT"
	// Imperial system unit of area.
	UnitPriceMeasurementMeasuredUnitFt2 UnitPriceMeasurementMeasuredUnit = "FT2"
	// Metric system unit of weight.
	UnitPriceMeasurementMeasuredUnitG UnitPriceMeasurementMeasuredUnit = "G"
	// 1 gallon equals 128 fluid ounces (U.S. customary unit).
	UnitPriceMeasurementMeasuredUnitGal UnitPriceMeasurementMeasuredUnit = "GAL"
	// Imperial system unit of length.
	UnitPriceMeasurementMeasuredUnitIn UnitPriceMeasurementMeasuredUnit = "IN"
	// 1 item, a unit of count.
	UnitPriceMeasurementMeasuredUnitItem UnitPriceMeasurementMeasuredUnit = "ITEM"
	// 1 kilogram equals 1000 grams.
	UnitPriceMeasurementMeasuredUnitKg UnitPriceMeasurementMeasuredUnit = "KG"
	// Metric system unit of volume.
	UnitPriceMeasurementMeasuredUnitL UnitPriceMeasurementMeasuredUnit = "L"
	// Imperial system unit of weight.
	UnitPriceMeasurementMeasuredUnitLb UnitPriceMeasurementMeasuredUnit = "LB"
	// Metric system unit of length.
	UnitPriceMeasurementMeasuredUnitM UnitPriceMeasurementMeasuredUnit = "M"
	// Metric system unit of area.
	UnitPriceMeasurementMeasuredUnitM2 UnitPriceMeasurementMeasuredUnit = "M2"
	// 1 cubic meter equals 1000 liters.
	UnitPriceMeasurementMeasuredUnitM3 UnitPriceMeasurementMeasuredUnit = "M3"
	// 1000 milligrams equals 1 gram.
	UnitPriceMeasurementMeasuredUnitMg UnitPriceMeasurementMeasuredUnit = "MG"
	// 1000 milliliters equals 1 liter.
	UnitPriceMeasurementMeasuredUnitMl UnitPriceMeasurementMeasuredUnit = "ML"
	// 1000 millimeters equals 1 meter.
	UnitPriceMeasurementMeasuredUnitMm UnitPriceMeasurementMeasuredUnit = "MM"
	// 16 ounces equals 1 pound.
	UnitPriceMeasurementMeasuredUnitOz UnitPriceMeasurementMeasuredUnit = "OZ"
	// 1 pint equals 16 fluid ounces (U.S. customary unit).
	UnitPriceMeasurementMeasuredUnitPt UnitPriceMeasurementMeasuredUnit = "PT"
	// 1 quart equals 32 fluid ounces (U.S. customary unit).
	UnitPriceMeasurementMeasuredUnitQt UnitPriceMeasurementMeasuredUnit = "QT"
	// The unit of measurement is unknown. Upgrade to the latest version of the API to resolve this unit.
	UnitPriceMeasurementMeasuredUnitUnknown UnitPriceMeasurementMeasuredUnit = "UNKNOWN"
	// 1 yard equals 36 inches.
	UnitPriceMeasurementMeasuredUnitYd UnitPriceMeasurementMeasuredUnit = "YD"
)

var AllUnitPriceMeasurementMeasuredUnit = []UnitPriceMeasurementMeasuredUnit{
	UnitPriceMeasurementMeasuredUnitCl,
	UnitPriceMeasurementMeasuredUnitCm,
	UnitPriceMeasurementMeasuredUnitFloz,
	UnitPriceMeasurementMeasuredUnitFt,
	UnitPriceMeasurementMeasuredUnitFt2,
	UnitPriceMeasurementMeasuredUnitG,
	UnitPriceMeasurementMeasuredUnitGal,
	UnitPriceMeasurementMeasuredUnitIn,
	UnitPriceMeasurementMeasuredUnitItem,
	UnitPriceMeasurementMeasuredUnitKg,
	UnitPriceMeasurementMeasuredUnitL,
	UnitPriceMeasurementMeasuredUnitLb,
	UnitPriceMeasurementMeasuredUnitM,
	UnitPriceMeasurementMeasuredUnitM2,
	UnitPriceMeasurementMeasuredUnitM3,
	UnitPriceMeasurementMeasuredUnitMg,
	UnitPriceMeasurementMeasuredUnitMl,
	UnitPriceMeasurementMeasuredUnitMm,
	UnitPriceMeasurementMeasuredUnitOz,
	UnitPriceMeasurementMeasuredUnitPt,
	UnitPriceMeasurementMeasuredUnitQt,
	UnitPriceMeasurementMeasuredUnitUnknown,
	UnitPriceMeasurementMeasuredUnitYd,
}

func (e UnitPriceMeasurementMeasuredUnit) IsValid() bool {
	switch e {
	case UnitPriceMeasurementMeasuredUnitCl, UnitPriceMeasurementMeasuredUnitCm, UnitPriceMeasurementMeasuredUnitFloz, UnitPriceMeasurementMeasuredUnitFt, UnitPriceMeasurementMeasuredUnitFt2, UnitPriceMeasurementMeasuredUnitG, UnitPriceMeasurementMeasuredUnitGal, UnitPriceMeasurementMeasuredUnitIn, UnitPriceMeasurementMeasuredUnitItem, UnitPriceMeasurementMeasuredUnitKg, UnitPriceMeasurementMeasuredUnitL, UnitPriceMeasurementMeasuredUnitLb, UnitPriceMeasurementMeasuredUnitM, UnitPriceMeasurementMeasuredUnitM2, UnitPriceMeasurementMeasuredUnitM3, UnitPriceMeasurementMeasuredUnitMg, UnitPriceMeasurementMeasuredUnitMl, UnitPriceMeasurementMeasuredUnitMm, UnitPriceMeasurementMeasuredUnitOz, UnitPriceMeasurementMeasuredUnitPt, UnitPriceMeasurementMeasuredUnitQt, UnitPriceMeasurementMeasuredUnitUnknown, UnitPriceMeasurementMeasuredUnitYd:
		return true
	}
	return false
}

func (e UnitPriceMeasurementMeasuredUnit) String() string {
	return string(e)
}

func (e *UnitPriceMeasurementMeasuredUnit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitPriceMeasurementMeasuredUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitPriceMeasurementMeasuredUnit", str)
	}
	return nil
}

func (e UnitPriceMeasurementMeasuredUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UnitPriceMeasurementMeasuredUnit) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UnitPriceMeasurementMeasuredUnit) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Systems of weights and measures.
type UnitSystem string

const (
	// Imperial system of weights and measures.
	UnitSystemImperialSystem UnitSystem = "IMPERIAL_SYSTEM"
	// Metric system of weights and measures.
	UnitSystemMetricSystem UnitSystem = "METRIC_SYSTEM"
)

var AllUnitSystem = []UnitSystem{
	UnitSystemImperialSystem,
	UnitSystemMetricSystem,
}

func (e UnitSystem) IsValid() bool {
	switch e {
	case UnitSystemImperialSystem, UnitSystemMetricSystem:
		return true
	}
	return false
}

func (e UnitSystem) String() string {
	return string(e)
}

func (e *UnitSystem) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitSystem", str)
	}
	return nil
}

func (e UnitSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UnitSystem) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UnitSystem) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible error codes that can be returned by `ShopPayPaymentRequestSessionUserErrors`.
type UserErrorsShopPayPaymentRequestSessionUserErrorsCode string

const (
	// Idempotency key has already been used.
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodeIdempotencyKeyAlreadyUsed UserErrorsShopPayPaymentRequestSessionUserErrorsCode = "IDEMPOTENCY_KEY_ALREADY_USED"
	// Payment request input is invalid.
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestInvalidInput UserErrorsShopPayPaymentRequestSessionUserErrorsCode = "PAYMENT_REQUEST_INVALID_INPUT"
	// Payment request not found.
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestNotFound UserErrorsShopPayPaymentRequestSessionUserErrorsCode = "PAYMENT_REQUEST_NOT_FOUND"
)

var AllUserErrorsShopPayPaymentRequestSessionUserErrorsCode = []UserErrorsShopPayPaymentRequestSessionUserErrorsCode{
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodeIdempotencyKeyAlreadyUsed,
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestInvalidInput,
	UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestNotFound,
}

func (e UserErrorsShopPayPaymentRequestSessionUserErrorsCode) IsValid() bool {
	switch e {
	case UserErrorsShopPayPaymentRequestSessionUserErrorsCodeIdempotencyKeyAlreadyUsed, UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestInvalidInput, UserErrorsShopPayPaymentRequestSessionUserErrorsCodePaymentRequestNotFound:
		return true
	}
	return false
}

func (e UserErrorsShopPayPaymentRequestSessionUserErrorsCode) String() string {
	return string(e)
}

func (e *UserErrorsShopPayPaymentRequestSessionUserErrorsCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserErrorsShopPayPaymentRequestSessionUserErrorsCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserErrorsShopPayPaymentRequestSessionUserErrorsCode", str)
	}
	return nil
}

func (e UserErrorsShopPayPaymentRequestSessionUserErrorsCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserErrorsShopPayPaymentRequestSessionUserErrorsCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserErrorsShopPayPaymentRequestSessionUserErrorsCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Units of measurement for weight.
type WeightUnit string

const (
	// Metric system unit of mass.
	WeightUnitGrams WeightUnit = "GRAMS"
	// 1 kilogram equals 1000 grams.
	WeightUnitKilograms WeightUnit = "KILOGRAMS"
	// Imperial system unit of mass.
	WeightUnitOunces WeightUnit = "OUNCES"
	// 1 pound equals 16 ounces.
	WeightUnitPounds WeightUnit = "POUNDS"
)

var AllWeightUnit = []WeightUnit{
	WeightUnitGrams,
	WeightUnitKilograms,
	WeightUnitOunces,
	WeightUnitPounds,
}

func (e WeightUnit) IsValid() bool {
	switch e {
	case WeightUnitGrams, WeightUnitKilograms, WeightUnitOunces, WeightUnitPounds:
		return true
	}
	return false
}

func (e WeightUnit) String() string {
	return string(e)
}

func (e *WeightUnit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeightUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeightUnit", str)
	}
	return nil
}

func (e WeightUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WeightUnit) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WeightUnit) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
